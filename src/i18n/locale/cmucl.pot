#@ cmucl

# SOME DESCRIPTIVE TITLE
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI +ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: src/code/struct.lisp
msgid "The size of a stream in-buffer."
msgstr ""

#: src/pcl/cpl.lisp src/pcl/dfun.lisp src/pcl/vector.lisp src/pcl/boot.lisp
#: src/pcl/cache.lisp src/pcl/fngen.lisp src/pcl/defs.lisp src/pcl/info.lisp
#: src/pcl/defsys.lisp src/compiler/byte-comp.lisp src/compiler/eval-comp.lisp
#: src/compiler/generic/new-genesis.lisp src/compiler/generic/core.lisp
#: src/compiler/dump.lisp src/compiler/dyncount.lisp src/compiler/xref.lisp
#: src/compiler/srctran.lisp src/compiler/ir1util.lisp src/compiler/main.lisp
#: src/compiler/knownfun.lisp src/compiler/new-assem.lisp
#: src/compiler/disassem.lisp src/compiler/meta-vmdef.lisp
#: src/compiler/vop.lisp src/compiler/ctype.lisp src/compiler/node.lisp
#: src/compiler/sset.lisp src/compiler/backend.lisp
#: src/compiler/generic/vm-macs.lisp src/compiler/macros.lisp
#: src/code/intl.lisp src/compiler/globaldb.lisp src/code/defstruct.lisp
#: src/code/remote.lisp src/code/wire.lisp src/code/internet.lisp
#: src/code/loop.lisp src/code/run-program.lisp src/code/parse-time.lisp
#: src/code/profile.lisp src/code/ntrace.lisp src/code/rand-mt19937.lisp
#: src/code/debug.lisp src/code/debug-int.lisp src/code/debug-info.lisp
#: src/code/eval.lisp src/code/filesys.lisp src/code/pathname.lisp
#: src/code/fd-stream.lisp src/code/extfmts.lisp src/code/serve-event.lisp
#: src/code/reader.lisp src/code/package.lisp src/code/format.lisp
#: src/code/pprint.lisp src/code/stream.lisp src/code/room.lisp
#: src/code/dfixnum.lisp src/code/commandline.lisp src/code/unidata.lisp
#: src/compiler/proclaim.lisp src/code/hash-new.lisp src/code/byte-interp.lisp
#: src/code/c-call.lisp src/code/alieneval.lisp src/code/type.lisp
#: src/code/class.lisp src/code/typedefs.lisp src/code/error.lisp
#: src/code/fwrappers.lisp src/code/struct.lisp
msgid "Class not yet defined: ~S"
msgstr ""

#: src/code/sysmacs.lisp
msgid ""
"Register the feature as having influenced the CMUCL build\n"
"  process. Feature is added to *feature*"
msgstr ""

#: src/code/sysmacs.lisp
msgid ""
"Register the feature as having influenced the CMUCL build process,\n"
"and also the CMUCL C runtime. Feature is added to*features* and\n"
"sys::*runtime-features*."
msgstr ""

#: src/code/sysmacs.lisp
msgid ""
"Given any Array, binds Data-Var to the array's data vector and Start-Var "
"and\n"
"  End-Var to the start and end of the designated portion of the data "
"vector.\n"
"  Svalue and Evalue are any start and end specified to the original operatio"
"n,\n"
"  and are factored into the bindings of Start-Var and End-Var.  Offset-Var "
"is\n"
"  the cumulative offset of all displacements encountered, and does not\n"
"  include Svalue."
msgstr ""

#: src/code/sysmacs.lisp
msgid "Executes the forms in the body without doing a garbage collection."
msgstr ""

#: src/code/kernel.lisp
msgid ""
"Return the 24 bits of data in the header of object X, which must be an\n"
"  other-pointer object."
msgstr ""

#: src/code/kernel.lisp
msgid ""
"Sets the 24 bits of data in the header of object X (which must be an\n"
"  other-pointer object) to VAL."
msgstr ""

#: src/code/kernel.lisp
msgid ""
"Returns the length of the closure X.  This is one more than the number\n"
"  of variables closed over."
msgstr ""

#: src/code/kernel.lisp
msgid "Returns the three-bit lowtag for the object X."
msgstr ""

#: src/code/kernel.lisp
msgid "Returns the 8-bit header type for the object X."
msgstr ""

#: src/code/kernel.lisp
msgid ""
"Return a System-Area-Pointer pointing to the data for the vector X, which\n"
"  must be simple."
msgstr ""

#: src/code/kernel.lisp
msgid "Return a System-Area-Pointer pointing to the end of the binding stack."
msgstr ""

#: src/code/kernel.lisp
msgid ""
"Returns a System-Area-Pointer pointing to the next free work of the current\n"
"  dynamic space."
msgstr ""

#: src/code/kernel.lisp
msgid "Return a System-Area-Pointer pointing to the end of the control stack."
msgstr ""

#: src/code/kernel.lisp
msgid "Return the header typecode for FUNCTION.  Can be set with SETF."
msgstr ""

#: src/code/kernel.lisp
msgid "Extracts the arglist from the function header FUNC."
msgstr ""

#: src/code/kernel.lisp
msgid "Extracts the name from the function header FUNC."
msgstr ""

#: src/code/kernel.lisp
msgid "Extracts the type from the function header FUNC."
msgstr ""

#: src/code/kernel.lisp
msgid "Extracts the function from CLOSURE."
msgstr ""

#: src/code/kernel.lisp
msgid ""
"Return the length of VECTOR.  There is no reason to use this, 'cause\n"
"  (length (the vector foo)) is the same."
msgstr ""

#: src/code/kernel.lisp
msgid "Return the SXHASH for the simple-string STRING."
msgstr ""

#: src/code/kernel.lisp
msgid ""
"Return the SXHASH for the first LENGTH characters of the simple-string\n"
"  STRING."
msgstr ""

#: src/code/kernel.lisp
msgid "Extract the INDEXth slot from CLOSURE."
msgstr ""

#: src/code/kernel.lisp
msgid ""
"Allocate a unboxed, simple vector with type code TYPE, length LENGTH, and\n"
"  WORDS words long.  Note: it is your responsibility to assure that the\n"
"  relation between LENGTH and WORDS is correct."
msgstr ""

#: src/code/kernel.lisp
msgid "Allocate an array header with type code TYPE and rank RANK."
msgstr ""

#: src/code/kernel.lisp
msgid "Return a SAP pointing to the instructions part of CODE-OBJ."
msgstr ""

#: src/code/kernel.lisp
msgid ""
"Extract the INDEXth element from the header of CODE-OBJ.  Can be set with\n"
"  setf."
msgstr ""

#: src/code/format.lisp src/code/print.lisp src/code/irrat-dd.lisp
#: src/code/irrat.lisp src/code/float.lisp src/code/numbers.lisp
#: src/code/kernel.lisp
msgid "Argument ~A is not a ~S: ~S."
msgstr ""

#: src/code/lispinit.lisp
msgid ""
"Holds a list of symbols that describe features provided by the\n"
"   implementation."
msgstr ""

#: src/code/lispinit.lisp
msgid "Features affecting the runtime.  These are written to internals.h."
msgstr ""

#: src/code/lispinit.lisp
msgid "The fixnum closest in value to positive infinity."
msgstr ""

#: src/code/lispinit.lisp
msgid "The fixnum closest in value to negative infinity."
msgstr ""

#: src/code/lispinit.lisp
msgid ""
"When (typep condition *break-on-signals*) is true, then calls to SIGNAL "
"will\n"
"   enter the debugger prior to signalling that condition."
msgstr ""

#: src/code/lispinit.lisp
msgid ""
"Invokes the signal facility on a condition formed from datum and arguments.\n"
"   If the condition is not handled, nil is returned.  If\n"
"   (TYPEP condition *BREAK-ON-SIGNALS*) is true, the debugger is invoked "
"before\n"
"   any signalling is done."
msgstr ""

#: src/code/lispinit.lisp
msgid "~A~%Break entered because of *break-on-signals* (now NIL.)"
msgstr ""

#: src/code/lispinit.lisp
msgid "Ignore the additional arguments."
msgstr ""

#: src/code/lispinit.lisp
msgid ""
"You may not supply additional arguments ~\n"
"				     when giving ~S to ~S."
msgstr ""

#: src/code/lispinit.lisp
msgid "Bad argument to ~S: ~S"
msgstr ""

#: src/code/lispinit.lisp
msgid ""
"Invokes the signal facility on a condition formed from datum and arguments.\n"
"   If the condition is not handled, the debugger is invoked."
msgstr ""

#: src/pcl/dfun.lisp src/code/interr.lisp src/code/lispinit.lisp
msgid "Help! "
msgstr ""

#: src/pcl/dfun.lisp src/code/interr.lisp src/code/lispinit.lisp
msgid " nested errors.  "
msgstr ""

#: src/pcl/dfun.lisp src/code/interr.lisp src/code/lispinit.lisp
msgid "KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded."
msgstr ""

#: src/code/lispinit.lisp
msgid ""
"Prints a message and invokes the debugger without allowing any possibility\n"
"   of condition handling occurring."
msgstr ""

#: src/code/lispinit.lisp
msgid "Return from BREAK."
msgstr ""

#: src/code/lispinit.lisp
msgid ""
"Warns about a situation by signalling a condition formed by datum and\n"
"   arguments.  While the condition is being signaled, a muffle-warning "
"restart\n"
"   exists that causes WARN to immediately return nil."
msgstr ""

#: src/code/lispinit.lisp
msgid "a warning condition"
msgstr ""

#: src/code/lispinit.lisp
msgid "Skip warning."
msgstr ""

#: src/code/lispinit.lisp
msgid "~&~@<Warning:  ~3i~:_~A~:>~%"
msgstr ""

#: src/code/lispinit.lisp
msgid ""
"Invokes the signal facility on a condition formed from datum and arguments.\n"
"   If the condition is not handled, the debugger is invoked.  This function\n"
"   is just like error, except that the condition type defaults to the type\n"
"   simple-program-error, instead of program-error."
msgstr ""

#: src/code/lispinit.lisp
msgid "Gives the world a shove and hopes it spins."
msgstr ""

#: src/code/lispinit.lisp
msgid "Functions to be invoked during cleanup at Lisp exit."
msgstr ""

#: src/code/lispinit.lisp
msgid ""
"Terminates the current Lisp.  Things are cleaned up unless Recklessly-P is\n"
"  non-Nil."
msgstr ""

#: src/code/lispinit.lisp
msgid ""
"This function causes execution to be suspended for N seconds.  N may\n"
"  be any non-negative, non-complex number."
msgstr ""

#: src/code/lispinit.lisp
msgid ""
"Zero the unused portion of the control stack so that old objects are not\n"
"   kept alive because of uninitialized stack variables."
msgstr ""

#: src/code/lispinit.lisp
msgid ""
"Holds a list of all the values returned by the most recent top-level EVAL."
msgstr ""

#: src/code/lispinit.lisp
msgid "Gets the previous value of / when a new value is computed."
msgstr ""

#: src/code/lispinit.lisp
msgid "Gets the previous value of // when a new value is computed."
msgstr ""

#: src/code/lispinit.lisp
msgid "Holds the value of the most recent top-level EVAL."
msgstr ""

#: src/code/lispinit.lisp
msgid "Gets the previous value of * when a new value is computed."
msgstr ""

#: src/code/lispinit.lisp
msgid "Gets the previous value of ** when a new value is computed."
msgstr ""

#: src/code/lispinit.lisp
msgid "Holds the value of the most recent top-level READ."
msgstr ""

#: src/code/lispinit.lisp
msgid "Gets the previous value of + when a new value is read."
msgstr ""

#: src/code/lispinit.lisp
msgid "Gets the previous value of ++ when a new value is read."
msgstr ""

#: src/code/lispinit.lisp
msgid "Holds the form curently being evaluated."
msgstr ""

#: src/code/lispinit.lisp
msgid ""
"The top-level prompt string.  This also may be a function of no arguments\n"
"   that returns a simple-string."
msgstr ""

#: src/code/lispinit.lisp
msgid ""
"True if we are within the Top-Level-Catcher.  This is used by interrupt\n"
"  handlers to see whether it is o.k. to throw."
msgstr ""

#: src/code/lispinit.lisp
msgid ""
"Evaluate FORM, returning whatever it returns but adjust ***, **, *, +++, ++,"
"\n"
"  +, ///, //, /, and -."
msgstr ""

#: src/code/lispinit.lisp
msgid "Go on with * set to NIL."
msgstr ""

#: src/code/lispinit.lisp
msgid "EVAL returned an unbound marker."
msgstr ""

#: src/code/lispinit.lisp
msgid ""
"How many pages to reserve from the total heap space so we can handle\n"
"heap overflow."
msgstr ""

#: src/code/lispinit.lisp
msgid "Top-level READ-EVAL-PRINT loop.  Do not call this."
msgstr ""

#: src/code/lispinit.lisp
msgid ""
"~&Received EOF on *standard-input*, ~\n"
"					switching to *terminal-io*.~%"
msgstr ""

#: src/code/lispinit.lisp
msgid "~&Received more than ~D EOFs; Aborting.~%"
msgstr ""

#: src/code/lispinit.lisp
msgid "~&Received EOF.~%"
msgstr ""

#: src/code/lispinit.lisp
msgid "Return to Top-Level."
msgstr ""

#: src/pcl/walk.lisp
msgid ""
"~@<The evaluator was called to evaluate a form in a macroexpansion ~\n"
"          environment constructed by the PCL portable code walker.  These ~\n"
"          environments are only useful for macroexpansion, they cannot be ~\n"
"          used for evaluation.  ~\n"
"          This error should never occur when using PCL.  ~\n"
"          This most likely source of this error is a program which tries to "
"~\n"
"          to use the PCL portable code walker to build its own evaluator.~@:"
">"
msgstr ""

#: src/pcl/walk.lisp
msgid "~@<~S is not a recognized variable declaration.~@:>"
msgstr ""

#: src/pcl/walk.lisp
msgid "~@<Can't get template for ~S.~@:>"
msgstr ""

#: src/pcl/walk.lisp
msgid ""
"~@<~S is a special form, not defined in the CommonLisp ~\n"
"		      manual.  This code walker doesn't know how to walk it.  ~\n"
"		      Define a template for this special form and try again.~@:>"
msgstr ""

#: src/pcl/walk.lisp
msgid ""
"~@<While handling repeat: ~\n"
"                     Ran into stop while still in repeat template.~@:>"
msgstr ""

#: src/pcl/walk.lisp
msgid ""
"~@<Encountered declare ~S in a place where a ~\n"
"         declare was not expected.~@:>"
msgstr ""

#: src/pcl/walk.lisp
msgid "~@<Can't understand something in the arglist ~S.~@:>"
msgstr ""

#: src/pcl/walk.lisp
msgid ""
"~@<In the form ~S: ~\n"
"                       IF only accepts three arguments, you are using ~D. ~\n"
"                       It is true that some Common Lisps support this, but "
"~\n"
"                       it is not truly legal Common Lisp.  For now, this "
"code ~\n"
"                       walker is interpreting the extra arguments as extra "
"else clauses. ~\n"
"                       Even if this is what you intended, you should fix "
"your source code.~@:>"
msgstr ""

#: src/code/fwrappers.lisp
msgid ""
"A funcallable instance used to implement fwrappers.\n"
"   The CONSTRUCTOR slot is a function defined with DEFINE-FWRAPPER.\n"
"   This function returns an instance closure closing over an \n"
"   fwrapper object, which is installed as the funcallable-instance\n"
"   function of the fwrapper object."
msgstr ""

#: src/code/fwrappers.lisp
msgid "Print-function for struct FWRAPPER."
msgstr ""

#: src/code/fwrappers.lisp
msgid "Return FUN if it is an fwrapper or nil if it isn't."
msgstr ""

#: src/code/fwrappers.lisp
msgid ""
"Evaluate BODY with VAR bound to consecutive fwrappers of\n"
"   FDEFN.  Return RESULT at the end."
msgstr ""

#: src/code/fwrappers.lisp
msgid "Return tha last encapsulation of FDEFN or NIL if none."
msgstr ""

#: src/code/fwrappers.lisp
msgid ""
"Prepend encapsulation F to the definition of FUNCTION-NAME.\n"
"   Signal an error if FUNCTION-NAME is an undefined function."
msgstr ""

#: src/code/fwrappers.lisp
msgid "Remove fwrapper F from the definition of FUNCTION-NAME."
msgstr ""

#: src/code/fwrappers.lisp
msgid ""
"Return a list of all fwrappers of FUNCTION-NAME, ordered\n"
"   from outermost to innermost."
msgstr ""

#: src/code/fwrappers.lisp
msgid ""
"Set FUNCTION-NAMES's fwrappers to elements of the list\n"
"   FWRAPPERS, which is assumed to be ordered from outermost to\n"
"   innermost.  FWRAPPERS null means remove all fwrappers."
msgstr ""

#: src/code/fwrappers.lisp
msgid ""
"Wrap the function named FUNCTION-NAME in an fwrapper of type TYPE,\n"
"   created by calling CONSTRUCTOR.  CONSTRUCTOR is a function\n"
"   defined with DEFINE-FWRAPPER, or the name of such a function.\n"
"   Return the fwrapper created.  USER-DATA is arbitrary data to be\n"
"   associated with the fwrapper.  It is accessible in wrapper\n"
"   functions defined with DEFINE-FWRAPPER as (FWRAPPER-USER-DATA\n"
"   FWRAPPER)."
msgstr ""

#: src/code/fwrappers.lisp
msgid ""
"Remove fwrappers from the function named FUNCTION-NAME.\n"
"   If TYPE is supplied, remove fwrappers whose type is equal to TYPE.\n"
"   If TEST is supplied, remove fwrappers satisfying TEST.\n"
"   If both are not specified, remove all fwrappers."
msgstr ""

#: src/code/fwrappers.lisp
msgid ""
"Update the funcallable instance function of fwrapper F from its\n"
"   constructor."
msgstr ""

#: src/code/fwrappers.lisp
msgid ""
"Update fwrapper function definitions of FUNCTION-NAME.\n"
"   If TYPE is supplied, update fwrappers whose type is equal to TYPE.\n"
"   If TEST is supplied, update fwrappers satisfying TEST."
msgstr ""

#: src/code/fwrappers.lisp
msgid ""
"Find an fwrapper of FUNCTION-NAME.\n"
"   If TYPE is supplied, find an fwrapper whose type is equal to TYPE.\n"
"   If TEST is supplied, find an fwrapper satisfying TEST."
msgstr ""

#: src/code/fwrappers.lisp
msgid ""
"Like DEFUN, but define a function wrapper.\n"
"   In BODY, the symbol FWRAPPERS:FWRAPPERS refers to the currently\n"
"   executing fwrapper.  FWRAPPERS:CALL-NEXT-FUNCTION can be used\n"
"   in BODY to call the next fwrapper or the primary function.  When\n"
"   called with no arguments, CALL-NEXT-FUNCTION invokes the next\n"
"   function with the original args to the fwrapper, otherwise it\n"
"   invokes the next function with the supplied args."
msgstr ""

#: src/code/fwrappers.lisp
msgid "Return the expansion of a DEFINE-FWRAPPER."
msgstr ""

#: src/code/fwrappers.lisp
msgid ""
"First value is true if BODY refers to any of the variables in\n"
"     OPTIONALS, KEYS or REST, which are what KERNEL:PARSE-LAMBDA-LIST\n"
"     returns.  Second value is true if BODY refers to REST."
msgstr ""

#: src/code/fwrappers.lisp
msgid "&MORE not supported in fwrapper lambda lists"
msgstr ""

#: src/code/fwrappers.lisp
msgid "Fwrapper for old-style encapsulations."
msgstr ""

#: src/code/fwrappers.lisp
msgid "This function is deprecated; use fwrappers instead."
msgstr ""

#: src/code/fdefinition.lisp
msgid ""
"Define (NAME ...) to be a valid function name whose syntax is checked\n"
"  by BODY.  In BODY, VAR is bound to an actual function name of the\n"
"  form (NAME ...) to check.  BODY should return two values.\n"
"  First value true means the function name is valid.  Second value\n"
"  is the name, a symbol, of the function for use in the BLOCK of DEFUNs\n"
"  and in similar situations."
msgstr ""

#: src/code/fdefinition.lisp
msgid ""
"First value is true if NAME has valid function name syntax.\n"
"  Second value is the name, a symbol, to use as a block name in DEFUNs\n"
"  and in similar situations."
msgstr ""

#: src/code/fdefinition.lisp
msgid ""
"Return the fdefn object for NAME.  If it doesn't already exist and CREATE\n"
"   is non-NIL, create a new (unbound) one."
msgstr ""

#: src/code/fdefinition.lisp
msgid "Invalid function name: ~S"
msgstr ""

#: src/code/fdefinition.lisp
msgid ""
"Return the FDEFN of NAME.  Signal an error if there is none\n"
"   or if it's function is null."
msgstr ""

#: src/code/fdefinition.lisp
msgid ""
"Returns the definition for name, including any encapsulations.  Settable\n"
"   with SETF."
msgstr ""

#: src/code/fdefinition.lisp
msgid ""
"Return FUNCTION-NAME's global function definition.\n"
"   If FUNCTION-NAME is fwrapped, return the primary function definition\n"
"   stored in the innermost fwrapper."
msgstr ""

#: src/code/fdefinition.lisp
msgid ""
"This holds functions that (SETF FDEFINITION) invokes before storing the\n"
"   new value.  These functions take the function name and the new value."
msgstr ""

#: src/code/fdefinition.lisp
msgid ""
"Set FUNCTION-NAME's global function definition to NEW-VALUE.\n"
"   If FUNCTION-NAME is fwrapped, set the primary function stored\n"
"   in the innermost fwrapper."
msgstr ""

#: src/code/fdefinition.lisp
msgid "Return true if name has a global function definition."
msgstr ""

#: src/code/fdefinition.lisp
msgid "Make Name have no global function definition."
msgstr ""

#: src/code/error.lisp
msgid "&rest keyword is ~:[missing~;misplaced~]."
msgstr ""

#: src/code/error.lisp
msgid ""
"Return a list of all the currently active restarts ordered from most\n"
"   recently established to less recently established.  If Condition is\n"
"   specified, then only restarts associated with Condition (or with no\n"
"   condition) will be returned."
msgstr ""

#: src/code/error.lisp
msgid "Returns the name of the given restart object."
msgstr ""

#: src/code/error.lisp
msgid ""
"WITH-CONDITION-RESTARTS Condition-Form Restarts-Form Form*\n"
"   Evaluates the Forms in a dynamic environment where the restarts in the "
"list\n"
"   Restarts-Form are associated with the condition returned by Condition-For"
"m.\n"
"   This allows FIND-RESTART, etc., to recognize restarts that are not "
"related\n"
"   to the error currently being debugged.  See also RESTART-CASE."
msgstr ""

#: src/code/error.lisp
msgid ""
"Executes forms in a dynamic context where the given restart bindings are\n"
"   in effect.  Users probably want to use RESTART-CASE.  When clauses "
"contain\n"
"   the same restart name, FIND-RESTART will find the first such clause."
msgstr ""

#: src/code/error.lisp
msgid "Unnamed restart does not have a ~\n"
"					report function -- ~S"
msgstr ""

#: src/code/error.lisp
msgid ""
"Returns the first restart named name.  If name is a restart, it is returned\n"
"   if it is currently active.  If no such restart is found, nil is "
"returned.\n"
"   It is an error to supply nil as a name.  If Condition is specified and "
"not\n"
"   NIL, then only restarts associated with that condition (or with no\n"
"   condition) will be returned."
msgstr ""

#: src/code/error.lisp
msgid ""
"Calls the function associated with the given restart, passing any given\n"
"   arguments.  If the argument restart is not a restart or a currently "
"active\n"
"   non-nil restart name, then a control-error is signalled."
msgstr ""

#: src/code/error.lisp
msgid "Restart ~S is not active."
msgstr ""

#: src/code/error.lisp
msgid ""
"Calls the function associated with the given restart, prompting for any\n"
"   necessary arguments.  If the argument restart is not a restart or a\n"
"   currently active non-nil restart name, then a control-error is "
"signalled."
msgstr ""

#: src/code/error.lisp
msgid ""
"(RESTART-CASE form\n"
"   {(case-name arg-list {keyword value}* body)}*)\n"
"   The form is evaluated in a dynamic context where the clauses have "
"special\n"
"   meanings as points to which control may be transferred (see INVOKE-RESTAR"
"T).\n"
"   When clauses contain the same case-name, FIND-RESTART will find the "
"first\n"
"   such clause.  If Expression is a call to SIGNAL, ERROR, CERROR or WARN "
"(or\n"
"   macroexpands into such) then the signalled condition will be associated "
"with\n"
"   the new restarts."
msgstr ""

#: src/code/error.lisp
msgid ""
"(WITH-SIMPLE-RESTART (restart-name format-string format-arguments)\n"
"   body)\n"
"   If restart-name is not invoked, then all values returned by forms are\n"
"   returned.  If control is transferred to this restart, it immediately\n"
"   returns the values nil and t."
msgstr ""

#: src/code/error.lisp
msgid "Condition ~S was signalled."
msgstr ""

#: src/code/error.lisp
msgid "No REPORT?  Shouldn't happen!"
msgstr ""

#: src/code/error.lisp
msgid "Condition slot is not bound: ~S"
msgstr ""

#: src/code/error.lisp
msgid "Slot ~S of ~S missing."
msgstr ""

#: src/code/error.lisp
msgid "Make an instance of a condition object using the specified initargs."
msgstr ""

#: src/code/error.lisp
msgid "~S is not a condition class."
msgstr ""

#: src/code/error.lisp
msgid "Bad thing for class arg:~%  ~S"
msgstr ""

#: src/code/error.lisp
msgid "Condition already names a declaration: ~S."
msgstr ""

#: src/code/error.lisp
msgid ""
"DEFINE-CONDITION Name (Parent-Type*) (Slot-Spec*) Option*\n"
"   Define NAME as a condition type.  This new type inherits slots and its\n"
"   report function from the specified PARENT-TYPEs.  A slot spec is either\n"
"   a symbol denoting the name of the slot, or a list of the form:\n"
"\n"
"     (slot-name {slot-option value}*)\n"
"\n"
"   where slot-option is one of :READER, :WRITER, :ACCESSOR, :ALLOCATION,\n"
"   :INITARG, :INITFORM, :DOCUMENTATION, and :TYPE.\n"
"\n"
"   Each overall option is of the form\n"
"\n"
"     (option-name {value}*)\n"
"\n"
"   where option-name is one of :DEFAULT-INITARGS, :DOCUMENTATION,\n"
"   and :REPORT.\n"
"\n"
"   The :REPORT option is peculiar to DEFINE-CONDITION.  Its argument is "
"either\n"
"   a string or a two-argument lambda or function name.  If a function, the\n"
"   function is called with the condition and stream to report the "
"condition.\n"
"   If a string, the string is printed.\n"
"\n"
"   Condition types are classes, but (as allowed by ANSI and not as described"
" in\n"
"   CLtL2) are neither STANDARD-OBJECTs nor STRUCTURE-OBJECTs.  WITH-SLOTS "
"and\n"
"   SLOT-VALUE may not be used on condition objects."
msgstr ""

#: src/code/error.lisp
msgid "Keyword slot name indicates probable syntax error:~%  ~S"
msgstr ""

#: src/code/error.lisp
msgid "Malformed condition slot spec:~%  ~S."
msgstr ""

#: src/code/error.lisp
msgid "More than one :INITFORM in:~%  ~S"
msgstr ""

#: src/code/error.lisp
msgid "More than one slot :DOCUMENTATION in~%  ~s"
msgstr ""

#: src/code/error.lisp
msgid "Slot :DOCUMENTATION is not a string in~%  ~s"
msgstr ""

#: src/code/error.lisp
msgid "Unknown slot option:~%  ~S"
msgstr ""

#: src/code/error.lisp
msgid "Bad option:~%  ~S"
msgstr ""

#: src/compiler/new-assem.lisp src/code/error.lisp
msgid "Unknown option: ~S"
msgstr ""

#: src/code/error.lisp
msgid ""
"(HANDLER-BIND ( {(type handler)}* )  body)\n"
"   Executes body in a dynamic context where the given handler bindings are\n"
"   in effect.  Each handler must take the condition being signalled as an\n"
"   argument.  The bindings are searched first to last in the event of a\n"
"   signalled condition."
msgstr ""

#: src/code/error.lisp
msgid "Ill-formed handler bindings."
msgstr ""

#: src/code/error.lisp
msgid "~&~@<Error in function ~S:  ~3i~:_~?~:>"
msgstr ""

#: src/code/error.lisp
msgid "Control stack overflow"
msgstr ""

#: src/code/error.lisp
msgid "Heap (dynamic space) overflow"
msgstr ""

#: src/code/error.lisp
msgid "~@<Type-error in ~S:  ~3i~:_~S is not of type ~S~:>"
msgstr ""

#: src/code/error.lisp
msgid ""
"Layout-invalid error in ~S:~@\n"
"		     Type test of class ~S was passed obsolete instance:~%  ~S"
msgstr ""

#: src/code/error.lisp
msgid "~@<~S fell through ~S expression.  ~:_Wanted one of ~:S.~:>"
msgstr ""

#: src/code/error.lisp
msgid "End-of-File on ~S"
msgstr ""

#: src/code/error.lisp
msgid "~&~@<File-error in function ~S:  ~3i~:_~?~:>"
msgstr ""

#: src/code/error.lisp
msgid "Error in ~S:  the variable ~S is unbound."
msgstr ""

#: src/code/error.lisp
msgid "Error in ~S:  the function ~S is undefined."
msgstr ""

#: src/code/error.lisp
msgid ""
"~@<Destructive function ~S called on ~\n"
"                         constant data.~@:>"
msgstr ""

#: src/code/error.lisp
msgid "Arithmetic error ~S signalled."
msgstr ""

#: src/code/error.lisp
msgid "~%Operation was ~S, operands ~S."
msgstr ""

#: src/code/error.lisp
msgid ""
"(HANDLER-CASE form\n"
"   { (type ([var]) body) }* )\n"
"   Executes form in a context with handlers established for the condition\n"
"   types.  A peculiar property allows type to be :no-error.  If such a "
"clause\n"
"   occurs, and form returns normally, all its values are passed to this "
"clause\n"
"   as if by MULTIPLE-VALUE-CALL.  The :no-error clause accepts more than "
"one\n"
"   var specification."
msgstr ""

#: src/code/error.lisp
msgid ""
"Executes forms after establishing a handler for all error conditions that\n"
"   returns from this form nil and the condition signalled."
msgstr ""

#: src/code/error.lisp
msgid "Found an \"abort\" restart that failed to transfer control dynamically."
msgstr ""

#: src/code/error.lisp
msgid ""
"Transfers control to a restart named abort, signalling a control-error if\n"
"   none exists."
msgstr ""

#: src/code/error.lisp
msgid ""
"Transfers control to a restart named muffle-warning, signalling a\n"
"   control-error if none exists."
msgstr ""

#: src/code/error.lisp
msgid ""
"Transfer control to a restart named continue, returning nil if none exists."
msgstr ""

#: src/code/error.lisp
msgid ""
"Transfer control and value to a restart named store-value, returning nil if\n"
"   none exists."
msgstr ""

#: src/code/error.lisp
msgid ""
"Transfer control and value to a restart named use-value, returning nil if\n"
"   none exists."
msgstr ""

#: src/code/typedefs.lisp
msgid "Forms that must happen before top level forms are run."
msgstr ""

#: src/code/typedefs.lisp
msgid "Can't cold-load-init other forms along with an eval-when."
msgstr ""

#: src/code/typedefs.lisp
msgid "~S is not a defined type class."
msgstr ""

#: src/code/typedefs.lisp
msgid "Missing type method for ~S"
msgstr ""

#: src/code/typedefs.lisp
msgid "~S is not a defined type class method."
msgstr ""

#: src/code/typedefs.lisp
msgid "DEFINE-TYPE-METHOD (Class-Name Method-Name+) Lambda-List Form*"
msgstr ""

#: src/code/typedefs.lisp
msgid "DEFINE-TYPE-CLASS Name [Inherits]"
msgstr ""

#: src/code/class.lisp
msgid "Layout for ~S~@[, Invalid=~S~]"
msgstr ""

#: src/code/class.lisp
msgid "The inclusive upper bound on LAYOUT-HASH values."
msgstr ""

#: src/code/class.lisp
msgid "Layout depth conflict: ~S~%  ~\n"
"		        (~S collides at ~S with ~S)~%"
msgstr ""

#: src/code/class.lisp
msgid "Can't use anonymous or undefined class as constant:~%  ~S"
msgstr ""

#: src/code/class.lisp
msgid "~:[<anonymous>~;~:*~S~]~@[ (~(~A~))~]"
msgstr ""

#: src/code/class.lisp
msgid ""
"Return the class with the specified Name.  If ERRORP is false, then NIL is\n"
"   returned when no such class exists."
msgstr ""

#: src/code/class.lisp
msgid "Class not yet defined:~%  ~S"
msgstr ""

#: src/code/class.lisp
msgid "Illegal to redefine standard type ~S."
msgstr ""

#: src/code/class.lisp
msgid "Changing meta-class of ~S from ~S to ~S."
msgstr ""

#: src/code/class.lisp
msgid "Redefining DEFTYPE type to be a class: ~S."
msgstr ""

#: src/code/class.lisp
msgid ""
"Return the class of the supplied object, which may be any Lisp object, not\n"
"   just a CLOS STANDARD-OBJECT."
msgstr ""

#: src/code/class.lisp
msgid "Modifing ~(~A~) class ~S; making it writable."
msgstr ""

#: src/code/class.lisp
msgid "Subclassing sealed class ~S; unsealing it."
msgstr ""

#: src/code/class.lisp
msgid ""
"Change in the inheritance structure of class ~S~%  ~\n"
"		 between the ~A definition and the ~A definition."
msgstr ""

#: src/code/class.lisp
msgid ""
"Change in instance length of class ~S:~%  ~\n"
"		   ~A length: ~D~%  ~\n"
"		   ~A length: ~D"
msgstr ""

#: src/code/class.lisp
msgid ""
"In class ~S:~%  ~\n"
"		    ~:(~A~) definition of superclass ~S incompatible with~%  ~\n"
"		    ~A definition."
msgstr ""

#: src/code/class.lisp
msgid ""
"Change in superclasses of class ~S:~%  ~\n"
"		  ~A superclasses: ~S~%  ~\n"
"		  ~A superclasses: ~S"
msgstr ""

#: src/code/class.lisp
msgid ""
"Loading a reference to class ~S when the compile~\n"
"		       ~%  time definition was incompatible with the current ~\n"
"		       one."
msgstr ""

#: src/code/class.lisp
msgid "Invalidate current definition."
msgstr ""

#: src/code/class.lisp
msgid "Smash current layout, preserving old code."
msgstr ""

#: src/code/class.lisp
msgid "Ignore the incompatibility, leave class alone."
msgstr ""

#: src/code/class.lisp
msgid "New definition of ~S must be loaded eventually."
msgstr ""

#: src/code/class.lisp
msgid ""
"Any old ~S instances will be in a bad way.~@\n"
"		      I hope you know what you're doing..."
msgstr ""

#: src/code/class.lisp
msgid ""
"Assuming the current definition of ~S is correct, and~@\n"
"		      that the loaded code doesn't care about the ~\n"
"		      incompatibility."
msgstr ""

#: src/code/class.lisp
msgid "Topological sort failed due to constraint on ~S."
msgstr ""

#: src/code/class.lisp
msgid "Something strange with forward layout for ~S:~%  ~S"
msgstr ""

#: src/code/type.lisp
msgid ""
"*Use-Implementation-Types* is a semi-public flag which determines how\n"
"   restrictive we are in determining type membership.  If two types are the\n"
"   same in the implementation, then we will consider them them the same "
"when\n"
"   this switch is on.  When it is off, we try to be as restrictive as the\n"
"   language allows, allowing us to detect more errors.  Currently, this "
"only\n"
"   affects array types."
msgstr ""

#: src/code/type.lisp
msgid "Subtypep is illegal on this type:~%  ~S"
msgstr ""

#: src/code/type.lisp
msgid "&Aux in a FUNCTION or VALUES type: ~S."
msgstr ""

#: src/code/type.lisp
msgid "Keyword type description is not a two-list: ~S."
msgstr ""

#: src/code/type.lisp
msgid "Repeated keyword ~S in lambda list: ~S."
msgstr ""

#: src/code/type.lisp
msgid ""
"The maximum length of a union of integer types before we take a\n"
"  short cut and return a simpler union."
msgstr ""

#: src/code/type.lisp
msgid "Bad thing to be a type specifier: ~S."
msgstr ""

#: src/code/type.lisp
msgid "VALUES type illegal in this context:~%  ~S"
msgstr ""

#: src/code/type.lisp
msgid "Bad N specified for MOD type specifier: ~S."
msgstr ""

#: src/code/type.lisp
msgid "Bad size specified for SIGNED-BYTE type specifier: ~S."
msgstr ""

#: src/code/type.lisp
msgid "Bad size specified for UNSIGNED-BYTE type specifier: ~S."
msgstr ""

#: src/code/type.lisp
msgid "Bad float format: ~S."
msgstr ""

#: src/code/type.lisp
msgid "Arrays can't have a negative number of dimensions: ~D."
msgstr ""

#: src/code/type.lisp
msgid "Array type has too many dimensions: ~S."
msgstr ""

#: src/code/type.lisp
msgid "Bad dimension in array type: ~S."
msgstr ""

#: src/code/type.lisp
msgid "Array dimensions is not a list, integer or *:~%  ~S"
msgstr ""

#: src/code/type.lisp
msgid "Type of characters that aren't base-char's.  None in CMU CL."
msgstr ""

#: src/code/type.lisp
msgid "Type corresponding to the charaters required by the standard."
msgstr ""

#: src/code/type.lisp
msgid "Type for any keyword symbol."
msgstr ""

#: src/code/type.lisp
msgid "&KEY or &ALLOW-OTHER-KEYS in values type: ~s"
msgstr ""

#: src/code/type.lisp
msgid "The SATISFIES predicate name is not a symbol: ~S"
msgstr ""

#: src/code/type.lisp
msgid "Weird CONS type ~S"
msgstr ""

#: src/code/type.lisp
msgid "The component type for COMPLEX is not numeric: ~S"
msgstr ""

#: src/code/type.lisp
msgid "The component type for COMPLEX is not real: ~S"
msgstr ""

#: src/code/type.lisp
msgid ""
"The component type for COMPLEX (EQL X) ~\n"
"                                    is complex: ~S"
msgstr ""

#: src/code/type.lisp
msgid ""
"~@<(known bug #145): The type ~S is too hairy to be \n"
"                         used for a COMPLEX component.~:@>"
msgstr ""

#: src/code/type.lisp
msgid "Bound is not *, a ~A or a list of a ~A: ~S"
msgstr ""

#: src/compiler/generic/vm-type.lisp
msgid "~S isn't an integer type?"
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is an array-header-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is an arrayp and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is an atom and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a base-char-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a bignump and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a bit-vector-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a characterp and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a code-component-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a consp and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a compiled-function-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a complexp and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a complex-double-float-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a complex-float-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a complex-double-double-float-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a complex-rational-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a complex-single-float-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a double-double-float-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a double-float-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a fdefn-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a fixnump and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a floatp and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a functionp and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is an integerp and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a listp and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a long-float-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a lra-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a not and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a null and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a numberp and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a rationalp and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a ratiop and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a realp and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a scavenger-hook-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a short-float-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a simple-array-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a simple-bit-vector-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a simple-string-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a simple-vector-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a single-float-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a stringp and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a %instancep and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a symbolp and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a system-area-pointer-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a weak-pointer-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a vectorp and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is an unsigned-byte-32-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a signed-byte-32-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-unsigned-byte-2-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-unsigned-byte-4-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-unsigned-byte-8-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-unsigned-byte-16-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-unsigned-byte-32-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-signed-byte-8-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-signed-byte-16-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-signed-byte-30-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-signed-byte-32-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a simple-array-single-float-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJECT is a simple-array-double-float-p and NIL otherwise."
msgstr ""

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-double-double-float-p and NIL otherwise"
"."
msgstr ""

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-complex-single-float-p and NIL otherwis"
"e."
msgstr ""

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-complex-double-float-p and NIL otherwis"
"e."
msgstr ""

#: src/code/pred.lisp
msgid ""
"Return T if OBJECT is a simple-array-complex-double-double-float-p and NIL "
"otherwise."
msgstr ""

#: src/code/pred.lisp
msgid "Return the type of OBJECT."
msgstr ""

#: src/code/pred.lisp
msgid ""
"Return the element type that will actually be used to implement an array\n"
"   with the specifier :ELEMENT-TYPE Spec."
msgstr ""

#: src/code/pred.lisp
msgid ""
"Return two values indicating the relationship between type1 and type2:\n"
"  T and T: type1 definitely is a subtype of type2.\n"
"  NIL and T: type1 definitely is not a subtype of type2.\n"
"  NIL and NIL: who knows?"
msgstr ""

#: src/code/pred.lisp
msgid "Return T iff OBJECT is of type TYPE."
msgstr ""

#: src/code/pred.lisp
msgid "~@<unknown element type in array type: ~2I~_~S~:>"
msgstr ""

#: src/code/pred.lisp
msgid "Unknown type specifier: ~S"
msgstr ""

#: src/code/pred.lisp
msgid "Invalid type specifier: ~S"
msgstr ""

#: src/code/pred.lisp
msgid "Function types are not a legal argument to TYPEP:~%  ~S"
msgstr ""

#: src/code/pred.lisp
msgid "Class has not yet been defined: ~S"
msgstr ""

#: src/code/pred.lisp
msgid "TYPEP on obsolete object (was class ~S)."
msgstr ""

#: src/code/pred.lisp
msgid "Class is currently invalid: ~S"
msgstr ""

#: src/code/pred.lisp
msgid "Return T if OBJ1 and OBJ2 are the same object, otherwise NIL."
msgstr ""

#: src/code/pred.lisp
msgid ""
"Returns T if X and Y are EQL or if they are structured components\n"
"  whose elements are EQUAL.  Strings and bit-vectors are EQUAL if they\n"
"  are the same length and have indentical components.  Other arrays must be\n"
"  EQ to be EQUAL."
msgstr ""

#: src/code/pred.lisp
msgid ""
"Just like EQUAL, but more liberal in several respects.\n"
"  Numbers may be of different types, as long as the values are identical\n"
"  after coercion.  Characters may differ in alphabetic case.  Vectors and\n"
"  arrays must have identical dimensions and EQUALP elements, but may differ\n"
"  in their type restriction."
msgstr ""

#: src/code/alieneval.lisp
msgid "No alien type class ~S"
msgstr ""

#: src/code/alieneval.lisp
msgid "No method ~S"
msgstr ""

#: src/code/alieneval.lisp
msgid ""
"Parse the list structure TYPE as an alien type specifier and return\n"
"   the resultant alien-type structure."
msgstr ""

#: src/code/alieneval.lisp
msgid "Unknown alien type: ~S"
msgstr ""

#: src/code/alieneval.lisp
msgid "No translator for primitive alien type ~S?"
msgstr ""

#: src/code/alieneval.lisp
msgid "Definition missing for alien type ~S?"
msgstr ""

#: src/code/alieneval.lisp
msgid "Attempt to multiple define ~A ~S."
msgstr ""

#: src/code/alieneval.lisp
msgid "Attempt to shadow definition of ~A ~S."
msgstr ""

#: src/code/alieneval.lisp
msgid ""
"Convert the alien-type structure TYPE back into a list specification of\n"
"   the type."
msgstr ""

#: src/code/alieneval.lisp
msgid "Method ~S not defined for ~S"
msgstr ""

#: src/code/alieneval.lisp
msgid ""
"Define the alien type NAME to be equivalent to TYPE.  Name may be NIL for\n"
"   STRUCT and UNION types, in which case the name is taken from the type\n"
"   specifier."
msgstr ""

#: src/code/alieneval.lisp
msgid "Redefining ~A ~S to be:~%  ~S,~%was:~%  ~S"
msgstr ""

#: src/code/alieneval.lisp
msgid "~S is a built-in alien type."
msgstr ""

#: src/code/alieneval.lisp
msgid "Redefining ~S to be:~%  ~S,~%was~%  ~S"
msgstr ""

#: src/code/alieneval.lisp
msgid "Return T iff TYPE1 and TYPE2 describe equivalent alien types."
msgstr ""

#: src/code/alieneval.lisp
msgid ""
"Return T iff the alien type TYPE1 is a subtype of TYPE2.  Currently, the\n"
"   only supported subtype relationships are that any pointer type is a\n"
"   subtype of (* t), and any array type's first dimension will match \n"
"   (array <eltype> nil ...).  Otherwise, the two types have to be\n"
"   ALIEN-TYPE-=."
msgstr ""

#: src/code/alieneval.lisp
msgid "Return T iff OBJECT is an alien of type TYPE."
msgstr ""

#: src/code/alieneval.lisp
msgid "Cannot represent ~S typed aliens."
msgstr ""

#: src/code/alieneval.lisp
msgid "Cannot pass aliens of type ~S as arguments to call-out"
msgstr ""

#: src/code/alieneval.lisp
msgid "Cannot return aliens of type ~S from call-out"
msgstr ""

#: src/code/alieneval.lisp
msgid "Cannot extract ~D bit integers."
msgstr ""

#: src/code/alieneval.lisp
msgid "Redefining alien enum ~S"
msgstr ""

#: src/code/alieneval.lisp
msgid "Unknown enum type: ~S"
msgstr ""

#: src/code/alieneval.lisp
msgid "Empty enum type: ~S"
msgstr ""

#: src/code/alieneval.lisp
msgid "An enumeration must contain at least one element."
msgstr ""

#: src/code/alieneval.lisp
msgid "Enumeration element ~S is not a keyword."
msgstr ""

#: src/code/alieneval.lisp
msgid "Element value ~S is not an integer."
msgstr ""

#: src/code/alieneval.lisp
msgid "Element value ~S used more than once."
msgstr ""

#: src/code/alieneval.lisp
msgid "Enumeration element ~S used more than once."
msgstr ""

#: src/code/alieneval.lisp
msgid "Can't represent enums needing more than 32 bits."
msgstr ""

#: src/code/alieneval.lisp
msgid "Cannot deposit aliens of type ~S (unknown size)."
msgstr ""

#: src/code/alieneval.lisp
msgid "First dimension is not a non-negative fixnum or NIL: ~S"
msgstr ""

#: src/code/alieneval.lisp
msgid "Dimension is not a non-negative fixnum: ~S"
msgstr ""

#: src/pcl/env.lisp src/pcl/fixup.lisp src/pcl/methods.lisp src/pcl/cpl.lisp
#: src/pcl/seal.lisp src/pcl/dfun.lisp
#: src/pcl/method-slot-access-optimization.lisp src/pcl/boot.lisp
#: src/pcl/dlisp.lisp src/pcl/cache.lisp src/pcl/defclass.lisp src/pcl/low.lisp
#: src/compiler/disassem.lisp src/code/pathname.lisp src/code/pprint-loop.lisp
#: src/code/pprint.lisp src/code/bignum.lisp src/code/alieneval.lisp
msgid "Required argument missing"
msgstr ""

#: src/compiler/aliencomp.lisp src/code/alieneval.lisp
msgid "Unknown size: ~S"
msgstr ""

#: src/code/alieneval.lisp
msgid "Unknown alignment: ~S"
msgstr ""

#: src/code/alieneval.lisp
msgid "A hash table used to detect cycles while comparing record types."
msgstr ""

#: src/code/alieneval.lisp
msgid ""
"Test if TYPE1 and TYPE2 are in the *MATCH-HISTORY*.\n"
"If so return true; otherwise call ALTERNATIVE."
msgstr ""

#: src/code/alieneval.lisp
msgid "Cannot use values types here."
msgstr ""

#: src/code/alieneval.lisp
msgid "Badly formed alien name."
msgstr ""

#: src/code/alieneval.lisp
msgid ""
"Define NAME as an external alien variable of type TYPE.  NAME should be\n"
"   a list of a string holding the alien name and a symbol to use as the "
"Lisp\n"
"   name.  If NAME is just a symbol or string, then the other name is "
"guessed\n"
"   from the one supplied."
msgstr ""

#: src/code/alieneval.lisp
msgid ""
"Access the alien variable named NAME, assuming it is of type TYPE.  This\n"
"   is SETFable."
msgstr ""

#: src/code/alieneval.lisp
msgid ""
"Establish some local alien variables.  Each BINDING is of the form:\n"
"     VAR TYPE [ ALLOCATION ] [ INITIAL-VALUE | EXTERNAL-NAME ]\n"
"   ALLOCATION should be one of:\n"
"     :LOCAL (the default)\n"
"       The alien is allocated on the stack, and has dynamic extent.\n"
"     :STATIC\n"
"       The alien is allocated on the heap, and has infinate extent.  The "
"alien\n"
"       is allocated at load time, so the same piece of memory is used each "
"time\n"
"       this form executes.\n"
"     :EXTERN\n"
"       No alien is allocated, but VAR is established as a local name for\n"
"       the external alien given by EXTERNAL-NAME."
msgstr ""

#: src/code/alieneval.lisp
msgid ""
"Return true if X (which must be an Alien pointer) is null, false otherwise."
msgstr ""

#: src/code/alieneval.lisp
msgid ""
"Convert the System-Area-Pointer SAP to an Alien of the specified Type (not\n"
"   evaluated.)  Type must be pointer-like."
msgstr ""

#: src/code/alieneval.lisp
msgid "Cannot make aliens of type ~S out of SAPs"
msgstr ""

#: src/code/alieneval.lisp
msgid "Return a System-Area-Pointer pointing to Alien's data."
msgstr ""

#: src/code/alieneval.lisp
msgid ""
"Allocate an alien of type TYPE and return an alien pointer to it.  If SIZE\n"
"   is supplied, how it is interpreted depends on TYPE.  If TYPE is an array\n"
"   type, SIZE is used as the first dimension for the allocated array.  If "
"TYPE\n"
"   is not an array, then SIZE is the number of elements to allocate.  The\n"
"   memory is allocated using ``malloc'', so it can be passed to foreign\n"
"   functions which use ``free''."
msgstr ""

#: src/code/alieneval.lisp
msgid "Size of ~S unknown."
msgstr ""

#: src/code/alieneval.lisp
msgid "Alignment of ~S unknown."
msgstr ""

#: src/code/alieneval.lisp
msgid "Cannot override the size of zero-dimensional arrays."
msgstr ""

#: src/code/alieneval.lisp
msgid ""
"Dispose of the storage pointed to by ALIEN.  ALIEN must have been allocated\n"
"   by MAKE-ALIEN or ``malloc''."
msgstr ""

#: src/code/alieneval.lisp
msgid "No slot named ~S in ~S"
msgstr ""

#: src/code/alieneval.lisp
msgid ""
"Extract SLOT from the Alien STRUCT or UNION ALIEN.  May be set with SETF."
msgstr ""

#: src/code/alieneval.lisp
msgid "Too many indices when derefing ~S: ~D"
msgstr ""

#: src/code/alieneval.lisp
msgid "Incorrect number of indices when derefing ~S: ~D"
msgstr ""

#: src/code/alieneval.lisp
msgid ""
"De-reference an Alien pointer or array.  If an array, the indices are used\n"
"   as the indices of the array element to access.  If a pointer, one index "
"can\n"
"   optionally be specified, giving the equivalent of C pointer arithmetic."
msgstr ""

#: src/code/alieneval.lisp
msgid "Something is wrong; local-alien-info not found: ~S"
msgstr ""

#: src/code/alieneval.lisp
msgid "~S isn't forced to memory.  Something went wrong."
msgstr ""

#: src/code/alieneval.lisp
msgid ""
"Return an Alien pointer to the data addressed by Expr, which must be a call\n"
"   to SLOT or DEREF, or a reference to an Alien variable."
msgstr ""

#: src/code/alieneval.lisp
msgid "~S is not a valid L-value"
msgstr ""

#: src/code/alieneval.lisp
msgid "Something is wrong, local-alien-info not found: ~S"
msgstr ""

#: src/code/alieneval.lisp
msgid ""
"Convert ALIEN to an Alien of the specified TYPE (not evaluated).  Both "
"types\n"
"   must be Alien array, pointer or function types."
msgstr ""

#: src/code/alieneval.lisp
msgid "~S cannot be cast."
msgstr ""

#: src/compiler/aliencomp.lisp src/code/alieneval.lisp
msgid "Cannot cast to alien type ~S"
msgstr ""

#: src/code/alieneval.lisp
msgid ""
"Return the size of the alien type TYPE.  UNITS specifies the units to\n"
"   use and can be either :BITS, :BYTES, or :WORDS."
msgstr ""

#: src/code/alieneval.lisp
msgid "Unknown size for alien type ~S."
msgstr ""

#: src/code/alieneval.lisp
msgid ""
"Call the foreign function ALIEN with the specified arguments.  ALIEN's\n"
"   type specifies the argument and result types."
msgstr ""

#: src/code/alieneval.lisp
msgid "Wrong number of arguments for ~S~%Expected ~D, got ~D."
msgstr ""

#: src/code/alieneval.lisp
msgid "~S is not an alien function."
msgstr ""

#: src/code/alieneval.lisp
msgid ""
"Def-Alien-Routine Name Result-Type\n"
"                    {(Arg-Name Arg-Type [Style])}*\n"
"\n"
"  Define a foreign interface function for the routine with the specified "
"Name,\n"
"  which may be either a string, symbol or list of the form (string symbol).\n"
"  Return-Type is the Alien type for the function return value.  VOID may be\n"
"  used to specify a function with no result.\n"
"\n"
"  The remaining forms specify individual arguments that are passed to the\n"
"  routine.  Arg-Name is a symbol that names the argument, primarily for\n"
"  documentation.  Arg-Type is the C-Type of the argument.  Style specifies "
"the\n"
"  way that the argument is passed.\n"
"\n"
"  :IN\n"
"        An :In argument is simply passed by value.  The value to be passed "
"is\n"
"        obtained from argument(s) to the interface function.  No values are\n"
"        returned for :In arguments.  This is the default mode.\n"
"\n"
"  :OUT\n"
"        The specified argument type must be a pointer to a fixed sized "
"object.\n"
"        A pointer to a preallocated object is passed to the routine, and "
"the\n"
"        the object is accessed on return, with the value being returned "
"from\n"
"        the interface function.  :OUT and :IN-OUT cannot be used with "
"pointers\n"
"        to arrays, records or functions.\n"
"\n"
"  :COPY\n"
"        Similar to :IN, except that the argument values are stored in on\n"
"        the stack, and a pointer to the object is passed instead of\n"
"        the values themselves.\n"
"\n"
"  :IN-OUT\n"
"        A combination of :OUT and :COPY.  A pointer to the argument is "
"passed,\n"
"        with the object being initialized from the supplied argument and\n"
"        the return value being determined by accessing the object on "
"return."
msgstr ""

#: src/code/alieneval.lisp
msgid "Bogus argument style ~S in ~S."
msgstr ""

#: src/code/alieneval.lisp
msgid "Can't use :out or :in-out on pointer-like type:~%  ~S"
msgstr ""

#: src/code/alien-callback.lisp
msgid "Vector of all callbacks."
msgstr ""

#: src/compiler/tn.lisp src/compiler/main.lisp src/code/describe.lisp
#: src/code/debug-int.lisp src/code/debug-info.lisp
#: src/code/foreign-linkage.lisp src/code/reader.lisp src/code/stream.lisp
#: src/code/hash-new.lisp src/code/array.lisp src/code/alien-callback.lisp
msgid "~S is not an array with a fill-pointer."
msgstr ""

#: src/code/alien-callback.lisp
msgid "Unable to mprotect ~S bytes (~S) at ~S (~S).  Callbacks may not work."
msgstr ""

#: src/code/alien-callback.lisp
msgid "Return the trampoline pointer for the callback NAME."
msgstr ""

#: src/code/alien-callback.lisp
msgid ""
"~\n"
"Attempt to redefine callback with incompatible return type.\n"
"   Old type was: ~A \n"
"    New type is: ~A"
msgstr ""

#: src/code/alien-callback.lisp
msgid "~\n"
"Create new trampoline (old trampoline calls old lisp function)."
msgstr ""

#: src/code/alien-callback.lisp
msgid "Unsupported argument type: ~A"
msgstr ""

#: src/code/alien-callback.lisp
msgid "Unsupported return type: ~A"
msgstr ""

#: src/code/alien-callback.lisp
msgid ""
"(defcallback NAME (RETURN-TYPE {(ARG-NAME ARG-TYPE)}*)\n"
"     {doc-string} {decls}* {FORM}*)\n"
"\n"
"Define a function which can be called by foreign code.  The pointer\n"
"returned by (callback NAME), when called by foreign code, invokes the\n"
"lisp function.  The lisp function expects alien arguments of the\n"
"specified ARG-TYPEs and returns an alien of type RETURN-TYPE.\n"
"\n"
"If (callback NAME) is already a callback function pointer, its value\n"
"is not changed (though it's arranged that an updated version of the\n"
"lisp callback function will be called).  This feature allows for\n"
"incremental redefinition of callback functions."
msgstr ""

#: src/code/sap.lisp
msgid "Return T iff the SAP X points to a smaller address then the SAP Y."
msgstr ""

#: src/code/sap.lisp
msgid ""
"Return T iff the SAP X points to a smaller or the same address as\n"
"   the SAP Y."
msgstr ""

#: src/code/sap.lisp
msgid "Return T iff the SAP X points to the same address as the SAP Y."
msgstr ""

#: src/code/sap.lisp
msgid ""
"Return T iff the SAP X points to a larger or the same address as\n"
"   the SAP Y."
msgstr ""

#: src/code/sap.lisp
msgid "Return T iff the SAP X points to a larger address then the SAP Y."
msgstr ""

#: src/code/sap.lisp
msgid "Return a new sap OFFSET bytes from SAP."
msgstr ""

#: src/code/sap.lisp
msgid "Return the byte offset between SAP1 and SAP2."
msgstr ""

#: src/code/sap.lisp
msgid "Converts a System Area Pointer into an integer."
msgstr ""

#: src/code/sap.lisp
msgid "Converts an integer into a System Area Pointer."
msgstr ""

#: src/code/sap.lisp
msgid "Returns the 8-bit byte at OFFSET bytes from SAP."
msgstr ""

#: src/code/sap.lisp
msgid "Returns the 16-bit word at OFFSET bytes from SAP."
msgstr ""

#: src/code/sap.lisp
msgid "Returns the 32-bit dualword at OFFSET bytes from SAP."
msgstr ""

#: src/code/sap.lisp
msgid "Returns the 64-bit quadword at OFFSET bytes from SAP."
msgstr ""

#: src/code/sap.lisp
msgid "Returns the 32-bit system-area-pointer at OFFSET bytes from SAP."
msgstr ""

#: src/code/sap.lisp
msgid "Returns the 32-bit single-float at OFFSET bytes from SAP."
msgstr ""

#: src/code/sap.lisp
msgid "Returns the 64-bit double-float at OFFSET bytes from SAP."
msgstr ""

#: src/code/sap.lisp
msgid "Returns the long-float at OFFSET bytes from SAP."
msgstr ""

#: src/code/sap.lisp
msgid "Returns the signed 8-bit byte at OFFSET bytes from SAP."
msgstr ""

#: src/code/sap.lisp
msgid "Returns the signed 16-bit word at OFFSET bytes from SAP."
msgstr ""

#: src/code/sap.lisp
msgid "Returns the signed 32-bit dualword at OFFSET bytes from SAP."
msgstr ""

#: src/code/sap.lisp
msgid "Returns the signed 64-bit quadword at OFFSET bytes from SAP."
msgstr ""

#: src/code/bit-bash.lisp
msgid "The number of bits to process at a time."
msgstr ""

#: src/code/bit-bash.lisp
msgid "The number of bytes to process at a time."
msgstr ""

#: src/code/bit-bash.lisp
msgid ""
"The maximum number of bits that can be dealt with during a single call."
msgstr ""

#: src/code/bit-bash.lisp
msgid ""
"Shift NUMBER by COUNT bits, adding zero bits at the ``end'' and removing\n"
"  bits from the ``start.''  On big-endian machines this is a left-shift and\n"
"  on little-endian machines this is a right-shift.  Note: only the low 5/6 "
"bits\n"
"  of count are significant."
msgstr ""

#: src/code/bit-bash.lisp
msgid ""
"Shift NUMBER by COUNT bits, adding zero bits at the ``start'' and removing\n"
"  bits from the ``end.''  On big-endian machines this is a right-shift and\n"
"  on little-endian machines this is a left-shift."
msgstr ""

#: src/code/bit-bash.lisp
msgid ""
"Produce a mask that contains 1's for the COUNT ``start'' bits and 0's for\n"
"  the remaining ``end'' bits.  Only the lower 5 bits of COUNT are significan"
"t."
msgstr ""

#: src/code/bit-bash.lisp
msgid ""
"Produce a mask that contains 1's for the COUNT ``end'' bits and 0's for\n"
"  the remaining ``start'' bits.  Only the lower 5 bits of COUNT are\n"
"  significant."
msgstr ""

#: src/code/bit-bash.lisp
msgid "Align the SAP to a word boundry, and update the offset accordingly."
msgstr ""

#: src/code/bit-bash.lisp
msgid ""
"Fill DST with VALUE starting at DST-OFFSET and continuing for LENGTH bits."
msgstr ""

#: src/code/byte-interp.lisp
msgid "This is the interpreter's evaluation stack."
msgstr ""

#: src/code/byte-interp.lisp
msgid "This is the next free element of the interpreter's evaluation stack."
msgstr ""

#: src/code/byte-interp.lisp
msgid "Undefined XOP."
msgstr ""

#: src/code/byte-interp.lisp
msgid "Unbound variable: ~S"
msgstr ""

#: src/code/byte-interp.lisp
msgid "Non-list argument to CAR: ~S"
msgstr ""

#: src/code/byte-interp.lisp
msgid "Non-list argument to CDR: ~S"
msgstr ""

#: src/code/byte-interp.lisp
msgid "Unknown inline function, id=~D"
msgstr ""

#: src/code/byte-interp.lisp
msgid "Wrong number of arguments."
msgstr ""

#: src/code/byte-interp.lisp
msgid "Not enough arguments."
msgstr ""

#: src/pcl/boot.lisp src/code/byte-interp.lisp
msgid "Too many arguments."
msgstr ""

#: src/pcl/combin.lisp src/code/interr.lisp src/code/byte-interp.lisp
msgid "Odd number of keyword arguments."
msgstr ""

#: src/code/interr.lisp src/code/byte-interp.lisp
msgid "Unknown keyword: ~S"
msgstr ""

#: src/code/byte-interp.lisp
msgid "function-end breakpoints not supported."
msgstr ""

#: src/code/array.lisp
msgid "The exclusive upper bound on the rank of an array."
msgstr ""

#: src/code/array.lisp
msgid "The exclusive upper bound any given dimension of an array."
msgstr ""

#: src/code/array.lisp
msgid "The exclusive upper bound on the total number of elements in an array."
msgstr ""

#: src/code/array.lisp
msgid "Start ~D is greater than end ~D."
msgstr ""

#: src/code/array.lisp
msgid "End ~D is greater than total size ~D."
msgstr ""

#: src/code/array.lisp
msgid ""
"List of weak-pointers to static vectors.  Needed for GCing static vectors"
msgstr ""

#: src/code/array.lisp
msgid "Cannot make a static array of element type ~S"
msgstr ""

#: src/code/array.lisp
msgid "Failed to allocate space for static array of length ~S of type ~S"
msgstr ""

#: src/code/array.lisp
msgid ""
"Creates an array of the specified Dimensions and properties.  See the\n"
"  manual for details.\n"
"\n"
"  :Element-type\n"
"      The type of objects that the array can hold \n"
"  :Initial-element\n"
"      Each element of the array is initialized to this value, if supplied.\n"
"      If not supplied, 0 of the appropriate type is used.\n"
"  :Initial-contents\n"
"      The contents of the array are initialized to this.\n"
"  :Adjustable\n"
"      If non-Nil, make an expressly adjustable array.\n"
"  :Fill-pointer\n"
"      For one-dimensional array, set the fill-pointer to the given value.\n"
"      If T, use the actual length of the array.\n"
"  :Displaced-to\n"
"      Create an array that is displaced to the target array specified\n"
"      by :displaced-to.\n"
"  :Displaced-index-offset\n"
"      Index offset to the displaced array.  That is, index 0 of this array "
"is\n"
"      actually index displaced-index-offset of the target displaced array. \n"
"  :Allocation\n"
"      How to allocate the array.  If :MALLOC, a static, nonmovable array is\n"
"      created.  This array is created by calling malloc."
msgstr ""

#: src/code/array.lisp
msgid "Can't specify :displaced-index-offset without :displaced-to"
msgstr ""

#: src/code/array.lisp
msgid "Cannot make an adjustable static array"
msgstr ""

#: src/code/array.lisp
msgid "Cannot make a displaced array static"
msgstr ""

#: src/code/array.lisp
msgid "Cannot specify both :initial-element and ~\n"
"		:initial-contents"
msgstr ""

#: src/code/array.lisp
msgid "~D elements in the initial-contents, but the ~\n"
"		vector length is ~D."
msgstr ""

#: src/code/array.lisp
msgid "Only vectors can have fill pointers."
msgstr ""

#: src/code/array.lisp
msgid "Invalid fill-pointer ~D"
msgstr ""

#: src/code/array.lisp
msgid ""
"Neither :initial-element nor :initial-contents ~\n"
"		   can be specified along with :displaced-to"
msgstr ""

#: src/code/array.lisp
msgid ""
"One can't displace an array of type ~S into ~\n"
"                           another of type ~S."
msgstr ""

#: src/code/array.lisp
msgid "~S doesn't have enough elements."
msgstr ""

#: src/code/array.lisp
msgid "If non-NIL, print some debugging information when GC'ing static arrays"
msgstr ""

#: src/code/array.lisp
msgid "~&Freeing foreign vector at #x~X~%"
msgstr ""

#: src/code/array.lisp
msgid "Finalizing static vectors ~S~%"
msgstr ""

#: src/code/array.lisp
msgid "static vector ~A.  header = ~X~%"
msgstr ""

#: src/code/array.lisp
msgid "  static vector ~A in use~%"
msgstr ""

#: src/code/array.lisp
msgid "  Free static vector ~A~%"
msgstr ""

#: src/code/array.lisp
msgid ""
"Cannot supply both :initial-contents and :initial-element to\n"
"            either make-array or adjust-array."
msgstr ""

#: src/code/array.lisp
msgid "~S cannot be used to initialize an array of type ~S."
msgstr ""

#: src/code/array.lisp
msgid ""
"Malformed :initial-contents.  ~S is not a ~\n"
"			                       sequence, but ~D more layer needed."
msgid_plural ""
"Malformed :initial-contents.  ~S is not a ~\n"
"			                       sequence, but ~D more layers needed."
msgstr[0] ""

#: src/code/array.lisp
msgid ""
"Malformed :initial-contents.  Dimension of ~\n"
"			        axis ~D is ~D, but ~S is ~D long."
msgstr ""

#: src/code/array.lisp
msgid "Constructs a simple-vector from the given objects."
msgstr ""

#: src/code/array.lisp
msgid "Wrong number of subscripts, ~D, for array of rank ~D"
msgstr ""

#: src/code/array.lisp
msgid "Invalid index ~D~[~;~:; on axis ~:*~D~] in ~S"
msgstr ""

#: src/code/array.lisp
msgid "Invalid index ~D in ~S"
msgstr ""

#: src/code/array.lisp
msgid "Returns T if the Subscipts are in bounds for the Array, Nil otherwise."
msgstr ""

#: src/code/array.lisp
msgid "Returns the element of the Array specified by the Subscripts."
msgstr ""

#: src/code/array.lisp
msgid ""
"Returns the element of array corressponding to the row-major index.  This "
"is\n"
"   SETF'able."
msgstr ""

#: src/code/array.lisp
msgid "Returns the Index'th element of the given Simple-Vector."
msgstr ""

#: src/code/array.lisp
msgid "Returns the bit from the Bit-Array at the specified Subscripts."
msgstr ""

#: src/code/array.lisp
msgid "Returns the bit from the Simple-Bit-Array at the specified Subscripts."
msgstr ""

#: src/code/array.lisp
msgid "Returns the type of the elements of the array"
msgstr ""

#: src/code/array.lisp
msgid "Returns the number of dimensions of the Array."
msgstr ""

#: src/code/array.lisp
msgid "Returns length of dimension Axis-Number of the Array."
msgstr ""

#: src/code/array.lisp
msgid "Vector axis is not zero: ~S"
msgstr ""

#: src/code/array.lisp
msgid "~D is too big; ~S only has ~D dimension"
msgid_plural "~D is too big; ~S only has ~D dimensions"
msgstr[0] ""

#: src/code/array.lisp
msgid "Returns a list whose elements are the dimensions of the array"
msgstr ""

#: src/code/array.lisp
msgid "Returns the total number of elements in the Array."
msgstr ""

#: src/code/array.lisp
msgid ""
"Returns values of :displaced-to and :displaced-index-offset options to\n"
"   make-array, or the defaults nil and 0 if not a displaced array."
msgstr ""

#: src/code/array.lisp
msgid ""
"Returns T if (adjust-array array...) would return an array identical\n"
"   to the argument, this happens for complex arrays."
msgstr ""

#: src/code/array.lisp
msgid "Returns T if the given Array has a fill pointer, or Nil otherwise."
msgstr ""

#: src/code/array.lisp
msgid "Returns the Fill-Pointer of the given Vector."
msgstr ""

#: src/code/array.lisp
msgid "New fill pointer, ~S, is larger than the length of the vector."
msgstr ""

#: src/code/array.lisp
msgid ""
"Attempts to set the element of Array designated by the fill pointer\n"
"   to New-El and increment fill pointer by one.  If the fill pointer is\n"
"   too large, Nil is returned, otherwise the index of the pushed element is "
"\n"
"   returned."
msgstr ""

#: src/code/array.lisp
msgid ""
"Like Vector-Push except that if the fill pointer gets too large, the\n"
"   Array is extended rather than Nil being returned."
msgstr ""

#: src/code/array.lisp
msgid ""
"Attempts to decrease the fill-pointer by 1 and return the element\n"
"   pointer to by the new fill pointer.  If the original value of the fill\n"
"   pointer is 0, an error occurs."
msgstr ""

#: src/code/array.lisp
msgid "Nothing left to pop."
msgstr ""

#: src/code/array.lisp
msgid "Adjusts the Array's dimensions to the given Dimensions and stuff."
msgstr ""

#: src/code/array.lisp
msgid "Number of dimensions not equal to rank of array."
msgstr ""

#: src/code/array.lisp
msgid "New element type, ~S, is incompatible with old."
msgstr ""

#: src/code/array.lisp
msgid "Static arrays are not adjustable."
msgstr ""

#: src/code/array.lisp
msgid "Multidimensional arrays can't have fill pointers."
msgstr ""

#: src/code/array.lisp
msgid ""
"Initial contents may not be specified with ~\n"
"		 the :initial-element or :displaced-to option."
msgstr ""

#: src/code/array.lisp
msgid ""
"The :initial-element option may not be specified ~\n"
"	       with :displaced-to."
msgstr ""

#: src/code/array.lisp
msgid ""
"One can't displace an array of type ~S into another of ~\n"
"	               type ~S."
msgstr ""

#: src/code/array.lisp
msgid "The :displaced-to array is too small."
msgstr ""

#: src/code/array.lisp
msgid ""
"Cannot adjust-array an array (~S) to a size (~S) that is ~\n"
"	            smaller than it's fill pointer (~S)."
msgstr ""

#: src/code/array.lisp
msgid ""
"Cannot supply a non-NIL value (~S) for :fill-pointer ~\n"
"	   in adjust-array unless the array (~S) was originally ~\n"
" 	   created with a fill pointer."
msgstr ""

#: src/code/array.lisp
msgid ""
"Cannot supply a value for :fill-pointer (~S) that is larger ~\n"
"	     than the new length of the vector (~S)."
msgstr ""

#: src/code/array.lisp
msgid "Bogus value for :fill-pointer in adjust-array: ~S"
msgstr ""

#: src/code/array.lisp
msgid ""
"Destructively alters the Vector, changing its length to New-Size, which\n"
"   must be less than or equal to its current size."
msgstr ""

#: src/code/array.lisp
msgid "Fills in array header with provided information.  Returns array."
msgstr ""

#: src/code/array.lisp
msgid "~S and ~S do not have the same dimensions."
msgstr ""

#: src/code/array.lisp
msgid ""
"Perform a bit-wise LOGAND on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY-1 is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array "
"is\n"
"  created.  All the arrays must have the same rank and dimensions."
msgstr ""

#: src/code/array.lisp
msgid ""
"Perform a bit-wise LOGIOR on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY-1 is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array "
"is\n"
"  created.  All the arrays must have the same rank and dimensions."
msgstr ""

#: src/code/array.lisp
msgid ""
"Perform a bit-wise LOGXOR on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY-1 is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array "
"is\n"
"  created.  All the arrays must have the same rank and dimensions."
msgstr ""

#: src/code/array.lisp
msgid ""
"Perform a bit-wise LOGEQV on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY-1 is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array "
"is\n"
"  created.  All the arrays must have the same rank and dimensions."
msgstr ""

#: src/code/array.lisp
msgid ""
"Perform a bit-wise LOGNAND on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY-1 is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array "
"is\n"
"  created.  All the arrays must have the same rank and dimensions."
msgstr ""

#: src/code/array.lisp
msgid ""
"Perform a bit-wise LOGNOR on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY-1 is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array "
"is\n"
"  created.  All the arrays must have the same rank and dimensions."
msgstr ""

#: src/code/array.lisp
msgid ""
"Perform a bit-wise LOGANDC1 on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY-1 is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array "
"is\n"
"  created.  All the arrays must have the same rank and dimensions."
msgstr ""

#: src/code/array.lisp
msgid ""
"Perform a bit-wise LOGANDC2 on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY-1 is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array "
"is\n"
"  created.  All the arrays must have the same rank and dimensions."
msgstr ""

#: src/code/array.lisp
msgid ""
"Perform a bit-wise LOGORC1 on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY-1 is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array "
"is\n"
"  created.  All the arrays must have the same rank and dimensions."
msgstr ""

#: src/code/array.lisp
msgid ""
"Perform a bit-wise LOGORC2 on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY-1 is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array "
"is\n"
"  created.  All the arrays must have the same rank and dimensions."
msgstr ""

#: src/code/array.lisp
msgid ""
"Performs a bit-wise logical NOT on the elements of BIT-ARRAY,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array is\n"
"  created.  Both arrays must have the same rank and dimensions."
msgstr ""

#: src/code/hash-new.lisp
msgid "Structure used to implement hash tables."
msgstr ""

#: src/code/hash-new.lisp
msgid ""
"Almost-Primify returns an almost prime number greater than or equal\n"
"   to NUM."
msgstr ""

#: src/code/hash-new.lisp
msgid "Define a new kind of hash table test."
msgstr ""

#: src/code/hash-new.lisp
msgid ""
"Creates and returns a new hash table.  The keywords are as follows:\n"
"     :TEST -- Indicates what kind of test to use.  Only EQ, EQL, EQUAL,\n"
"       and EQUALP are currently supported.\n"
"     :SIZE -- A hint as to how many elements will be put in this hash\n"
"       table.\n"
"     :REHASH-SIZE -- Indicates how to expand the table when it fills up.\n"
"       If an integer, add space for that many elements.  If a floating\n"
"       point number (which must be greater than 1.0), multiple the size\n"
"       by that amount.\n"
"     :REHASH-THRESHOLD -- Indicates how dense the table can become before\n"
"       forcing a rehash.  Can be any positive number <= to 1, with density\n"
"       approaching zero as the threshold approaches 0.  Density 1 means an\n"
"       average of one entry per bucket.\n"
"   CMUCL Extension:\n"
"     :WEAK-P -- Weak hash table.  Can only be used when the key is 'eq or "
"'eql.\n"
"                An entry in the table is remains if the condition holds:\n"
"\n"
"                :KEY            -- key is referenced elsewhere\n"
"                :VALUE          -- value is referenced elsewhere\n"
"                :KEY-AND-VALUE  -- key and value are referenced elsewhere\n"
"                :KEY-OR-VALUE   -- key or value is referenced elsewhere\n"
"\n"
"                If the condition does not hold, the entry is removed.  For\n"
"                backward compatibility, a value of T is the same as :KEY."
msgstr ""

#: src/code/hash-new.lisp
msgid "Cannot make a weak ~A hashtable with test: ~S"
msgstr ""

#: src/code/hash-new.lisp
msgid "Unknown :TEST for MAKE-HASH-TABLE: ~S"
msgstr ""

#: src/code/hash-new.lisp
msgid "Returns the number of entries in the given HASH-TABLE."
msgstr ""

#: src/code/hash-new.lisp
msgid "Return the rehash-size HASH-TABLE was created with."
msgstr ""

#: src/code/hash-new.lisp
msgid "Return the rehash-threshold HASH-TABLE was created with."
msgstr ""

#: src/code/hash-new.lisp
msgid ""
"Return a size that can be used with MAKE-HASH-TABLE to create a hash\n"
"   table that can hold however many entries HASH-TABLE can hold without\n"
"   having to be grown."
msgstr ""

#: src/code/hash-new.lisp
msgid "Return the test HASH-TABLE was created with."
msgstr ""

#: src/code/hash-new.lisp
msgid ""
"Return T if HASH-TABLE will not keep entries for keys that would\n"
"   otherwise be garbage, and NIL if it will."
msgstr ""

#: src/code/hash-new.lisp
msgid ""
"Finds the entry in HASH-TABLE whose key is KEY and returns the associated\n"
"   value and T as multiple values, or returns DEFAULT and NIL if there is "
"no\n"
"   such entry.  Entries can be added using SETF."
msgstr ""

#: src/code/hash-new.lisp
msgid ""
"Remove the entry in HASH-TABLE associated with KEY.  Returns T if there\n"
"   was such an entry, and NIL if not."
msgstr ""

#: src/code/hash-new.lisp
msgid ""
"This removes all the entries from HASH-TABLE and returns the hash table\n"
"   itself."
msgstr ""

#: src/code/hash-new.lisp
msgid ""
"This removes all the entries from HASH-TABLE and returns the hash table\n"
"   itself, shrinking the size to free memory."
msgstr ""

#: src/code/hash-new.lisp
msgid ""
"For each entry in HASH-TABLE, calls MAP-FUNCTION on the key and value\n"
"   of the entry; returns NIL."
msgstr ""

#: src/code/hash-new.lisp
msgid ""
"WITH-HASH-TABLE-ITERATOR ((function hash-table) &body body)\n"
"   provides a method of manually looping over the elements of a hash-table.\n"
"   FUNCTION is bound to a generator-macro that, within the scope of the\n"
"   invocation, returns one or three values. The first value tells whether\n"
"   any objects remain in the hash table. When the first value is non-NIL, \n"
"   the second and third values are the key and the value of the next "
"object."
msgstr ""

#: src/pcl/slots.lisp src/code/hash-new.lisp
msgid "What kind of instance is this?"
msgstr ""

#: src/code/hash-new.lisp
msgid "Computes a hash code for S-EXPR and returns it as an integer."
msgstr ""

#: src/code/list.lisp
msgid "Returns the 1st object in a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns all but the first object."
msgstr ""

#: src/code/list.lisp
msgid "Returns the 2nd object in a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the cdr of the 1st sublist."
msgstr ""

#: src/code/list.lisp
msgid "Returns the car of the 1st sublist."
msgstr ""

#: src/code/list.lisp
msgid "Returns all but the 1st two objects of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the 1st object in the cddr of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the 1st object in the cadr of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the 1st object in the caar of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the cdr of the caar of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the cdr of the cdar of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the cdr of the cddr of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the car of the cdar of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the cdr of the cadr of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the car of the caaar of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the car of the caadr of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the car of the caddr of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the car of the cdddr of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the cdr of the cdddr of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the cdr of the caaar of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the cdr of the cdaar of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the cdr of the cddar of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the car of the cadar of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the car of the cdaar of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the car of the cdadr of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the car of the cddar of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the cdr of the caadr of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the cdr of the cadar of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the cdr of the caddr of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the cdr of the cdadr of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns a list with se1 as the car and se2 as the cdr."
msgstr ""

#: src/code/list.lisp
msgid "Returns T if X and Y are isomorphic trees with identical leaves."
msgstr ""

#: src/code/list.lisp
msgid ""
"The recommended way to test for the end of a list.  True if Object is nil,\n"
"   false if Object is a cons, and an error for any other types of "
"arguments."
msgstr ""

#: src/code/list.lisp
msgid "Returns the length of the given List, or Nil if the List is circular."
msgstr ""

#: src/code/list.lisp
msgid "Returns the nth object in a list where the car is the zero-th element."
msgstr ""

#: src/code/list.lisp
msgid "Returns the 1st object in a list or NIL if the list is empty."
msgstr ""

#: src/code/list.lisp
msgid "Returns the 2nd object in a list or NIL if there is no 2nd object."
msgstr ""

#: src/code/list.lisp
msgid "Returns the 3rd object in a list or NIL if there is no 3rd object."
msgstr ""

#: src/code/list.lisp
msgid "Returns the 4th object in a list or NIL if there is no 4th object."
msgstr ""

#: src/code/list.lisp
msgid "Returns the 5th object in a list or NIL if there is no 5th object."
msgstr ""

#: src/code/list.lisp
msgid "Returns the 6th object in a list or NIL if there is no 6th object."
msgstr ""

#: src/code/list.lisp
msgid "Returns the 7th object in a list or NIL if there is no 7th object."
msgstr ""

#: src/code/list.lisp
msgid "Returns the 8th object in a list or NIL if there is no 8th object."
msgstr ""

#: src/code/list.lisp
msgid "Returns the 9th object in a list or NIL if there is no 9th object."
msgstr ""

#: src/code/list.lisp
msgid "Returns the 10th object in a list or NIL if there is no 10th object."
msgstr ""

#: src/code/list.lisp
msgid "Means the same as the cdr of a list."
msgstr ""

#: src/code/list.lisp
msgid "Performs the cdr function n times on a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns the last N conses (not the last element!) of a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns constructs and returns a list of its arguments."
msgstr ""

#: src/code/list.lisp
msgid "Returns a list of the arguments with last cons a dotted pair"
msgstr ""

#: src/code/list.lisp
msgid "Constructs a list with size elements each set to value"
msgstr ""

#: src/code/list.lisp
msgid "~S is not a proper list"
msgstr ""

#: src/code/list.lisp
msgid ""
"Typically, returns a new list that is the concatenation of Args.\n"
"\n"
"  Each Arg in Args must be a proper list except the last one, which\n"
"  may be any object.  The function is not destructive: for all but the\n"
"  last Arg, its list structure is copied.  The last argument is not\n"
"  copied; it becomes the cdr of the final dotted pair of the\n"
"  concatenation of the preceding lists, or is returned directly if\n"
"  there are no preceding non-empty lists.  In the latter case, if the\n"
"  last Arg is not a list, the returned value is not a list either."
msgstr ""

#: src/code/list.lisp
msgid "~S is not a list."
msgstr ""

#: src/code/list.lisp
msgid "Returns a new list EQUAL but not EQ to list"
msgstr ""

#: src/code/list.lisp
msgid "Returns a new association list equal to alist, constructed in space"
msgstr ""

#: src/code/list.lisp
msgid "Copy-Tree recursively copys trees of conses."
msgstr ""

#: src/code/list.lisp
msgid "Returns (append (reverse x) y)"
msgstr ""

#: src/code/list.lisp
msgid "Concatenates the lists given as arguments (by changing them)"
msgstr ""

#: src/code/list.lisp
msgid "Argument is not a list -- ~S."
msgstr ""

#: src/code/list.lisp
msgid "Returns (nconc (nreverse x) y)"
msgstr ""

#: src/code/list.lisp
msgid "First argument is not a proper list."
msgstr ""

#: src/code/list.lisp
msgid ""
"Returns a new list the same as List without the last N conses.\n"
"   List must not be circular."
msgstr ""

#: src/code/list.lisp
msgid "Modifies List to remove the last N conses. List must not be circular."
msgstr ""

#: src/code/list.lisp
msgid ""
"Returns a new list, whose elements are those of List that appear before\n"
"   Object.  If Object is not a tail of List, a copy of List is returned.\n"
"   List must be a proper list or a dotted list."
msgstr ""

#: src/code/list.lisp
msgid "Changes the car of x to y and returns the new x."
msgstr ""

#: src/code/list.lisp
msgid "Changes the cdr of x to y and returns the new x."
msgstr ""

#: src/code/list.lisp
msgid "Sets the Nth element of List (zero based) to Newval."
msgstr ""

#: src/code/list.lisp
msgid "~S is too large an index for SETF of NTH."
msgstr ""

#: src/code/list.lisp
msgid "Returns what was passed to it."
msgstr ""

#: src/code/list.lisp
msgid ""
"Builds a new function that returns T whenever FUNCTION returns NIL and\n"
"   NIL whenever FUNCTION returns T."
msgstr ""

#: src/code/list.lisp
msgid "Builds a function that always returns VALUE, and posisbly MORE-VALUES."
msgstr ""

#: src/code/list.lisp
msgid "Substitutes new for subtrees matching old."
msgstr ""

#: src/code/list.lisp
msgid "Substitutes new for subtrees for which test is true."
msgstr ""

#: src/code/list.lisp
msgid "Substitutes new for subtrees for which test is false."
msgstr ""

#: src/code/list.lisp
msgid "Substitutes new for subtrees of tree for which test is true."
msgstr ""

#: src/code/list.lisp
msgid "Substitutes new for subtrees of tree for which test is false."
msgstr ""

#: src/code/list.lisp
msgid "Substitutes from alist into tree nondestructively."
msgstr ""

#: src/code/list.lisp
msgid ""
"Returns tail of list beginning with first element satisfying EQLity,\n"
"   :test, or :test-not with a given item."
msgstr ""

#: src/code/list.lisp
msgid ""
"Returns tail of list beginning with first element satisfying test(element)"
msgstr ""

#: src/code/list.lisp
msgid ""
"Returns tail of list beginning with first element not satisfying test(el)"
msgstr ""

#: src/code/list.lisp
msgid ""
"Returns true if Object is the same as some tail of List, otherwise\n"
"   returns false. List must be a proper list or a dotted list."
msgstr ""

#: src/code/list.lisp
msgid "Add item to list unless it is already a member"
msgstr ""

#: src/code/list.lisp
msgid "Returns the union of list1 and list2."
msgstr ""

#: src/code/list.lisp
msgid "Test and test-not both supplied."
msgstr ""

#: src/code/list.lisp
msgid "Destructively returns the union list1 and list2."
msgstr ""

#: src/code/list.lisp
msgid "Returns the intersection of list1 and list2."
msgstr ""

#: src/code/list.lisp
msgid "Destructively returns the intersection of list1 and list2."
msgstr ""

#: src/code/list.lisp
msgid "Returns the elements of list1 which are not in list2."
msgstr ""

#: src/code/list.lisp
msgid "Destructively returns the elements of list1 which are not in list2."
msgstr ""

#: src/code/list.lisp
msgid "Return new list of elements appearing exactly once in LIST1 and LIST2."
msgstr ""

#: src/code/list.lisp
msgid ""
"Destructively return a list with elements which appear but once in LIST1\n"
"   and LIST2."
msgstr ""

#: src/code/list.lisp
msgid "Returns T if every element in list1 is also in list2."
msgstr ""

#: src/code/list.lisp
msgid "Construct a new alist by adding the pair (key . datum) to alist"
msgstr ""

#: src/code/list.lisp
msgid "Construct an association list from keys and data (adding to alist)"
msgstr ""

#: src/code/list.lisp
msgid "The lists of keys and data are of unequal length."
msgstr ""

#: src/code/list.lisp
msgid ""
"Returns the cons in alist whose car is equal (by a given test or EQL) to\n"
"   the Item."
msgstr ""

#: src/code/list.lisp
msgid ""
"Returns the first cons in alist whose car satisfies the Predicate.  If\n"
"   key is supplied, apply it to the car of each cons before testing."
msgstr ""

#: src/code/list.lisp
msgid ""
"Returns the first cons in alist whose car does not satisfiy the Predicate.\n"
"  If key is supplied, apply it to the car of each cons before testing."
msgstr ""

#: src/code/list.lisp
msgid ""
"Returns the cons in alist whose cdr is equal (by a given test or EQL) to\n"
"   the Item."
msgstr ""

#: src/code/list.lisp
msgid ""
"Returns the first cons in alist whose cdr satisfies the Predicate.  If key\n"
"  is supplied, apply it to the cdr of each cons before testing."
msgstr ""

#: src/code/list.lisp
msgid ""
"Returns the first cons in alist whose cdr does not satisfy the Predicate.\n"
"  If key is supplied, apply it to the cdr of each cons before testing."
msgstr ""

#: src/code/list.lisp
msgid ""
"This function is called by mapc, mapcar, mapcan, mapl, maplist, and mapcon.\n"
"  It Maps function over the arglists in the appropriate way. It is done "
"when any\n"
"  of the arglists runs out.  Until then, it CDRs down the arglists calling "
"the\n"
"  function and accumulating results as desired."
msgstr ""

#: src/code/list.lisp
msgid ""
"Applies Function to successive elements of each List, and returns\n"
"  its second argument."
msgstr ""

#: src/code/list.lisp
msgid ""
"Applies Function to successive elements of each List, and returns a\n"
"  list of results."
msgstr ""

#: src/code/list.lisp
msgid ""
"Applies Function to successive elements of each List, and returns\n"
"  NCONC of results."
msgstr ""

#: src/code/list.lisp
msgid "Applies Function to successive CDRs of each List, and returns ()."
msgstr ""

#: src/code/list.lisp
msgid ""
"Applies Function to successive CDRs of each List, and returns list\n"
"  of results."
msgstr ""

#: src/code/list.lisp
msgid ""
"Applies Function to successive CDRs of each List, and returns NCONC\n"
"  of results."
msgstr ""

#: src/code/list.lisp
msgid "Returns tail of list beginning with first element eq to item"
msgstr ""

#: src/code/list.lisp
msgid "Return the first pair of alist where item EQ the key of pair"
msgstr ""

#: src/code/list.lisp
msgid "Returns list with all elements with all elements EQ to ITEM deleted."
msgstr ""

#: src/code/seq.lisp
msgid ""
"Returns a list of the Nth element of each of the sequences.  Used by MAP\n"
"   and friends."
msgstr ""

#: src/code/seq.lisp
msgid "Returns a sequence of the same type as SEQUENCE and the given LENGTH."
msgstr ""

#: src/code/seq.lisp
msgid "Returns the broad class of which TYPE is a specific subclass."
msgstr ""

#: src/code/seq.lisp
msgid "NIL output type invalid for this sequence function."
msgstr ""

#: src/code/seq.lisp
msgid "~S is too hairy for sequence functions."
msgstr ""

#: src/code/seq.lisp
msgid "~S is a bad type specifier for sequence functions."
msgstr ""

#: src/code/seq.lisp
msgid "Error in ~S: ~S: Index too large."
msgstr ""

#: src/code/seq.lisp
msgid "Returns a sequence of the given TYPE and LENGTH."
msgstr ""

#: src/code/seq.lisp
msgid "Returns the element of SEQUENCE specified by INDEX."
msgstr ""

#: src/code/seq.lisp
msgid "Store NEWVAL as the component of SEQUENCE specified by INDEX."
msgstr ""

#: src/code/seq.lisp
msgid "Returns an integer that is the length of SEQUENCE."
msgstr ""

#: src/code/seq.lisp
msgid "~S is a bad type specifier for sequences"
msgstr ""

#: src/code/seq.lisp
msgid "Shouldn't happen!  Weird type"
msgstr ""

#: src/code/seq.lisp
msgid ""
"The length of ~S does not match the specified ~\n"
"                          length of ~S."
msgstr ""

#: src/code/seq.lisp
msgid ""
"Returns a sequence of the given Type and Length, with elements initialized\n"
"  to :Initial-Element."
msgstr ""

#: src/code/seq.lisp
msgid ""
"The length of ~S does not match the specified ~\n"
"                           length  of ~S."
msgstr ""

#: src/code/seq.lisp
msgid "~S is a bad type specifier for sequences."
msgstr ""

#: src/code/seq.lisp
msgid ""
"Returns a copy of a subsequence of SEQUENCE starting with element number \n"
"   START and continuing to the end of SEQUENCE or the optional END."
msgstr ""

#: src/code/seq.lisp
msgid "Returns a copy of SEQUENCE which is EQUAL to SEQUENCE but not EQ."
msgstr ""

#: src/code/seq.lisp
msgid "Replace the specified elements of SEQUENCE with ITEM."
msgstr ""

#: src/code/seq.lisp
msgid ""
"The target sequence is destructively modified by copying successive\n"
"   elements into it from the source sequence."
msgstr ""

#: src/code/seq.lisp
msgid ""
"Returns a new sequence containing the same elements but in reverse order."
msgstr ""

#: src/code/seq.lisp
msgid ""
"Returns a sequence of the same elements in reverse order; the argument\n"
"   is destroyed."
msgstr ""

#: src/code/seq.lisp
msgid ""
"Returns a new sequence of all the argument sequences concatenated together\n"
"  which shares no structure with the original argument sequences of the\n"
"  specified OUTPUT-TYPE-SPEC."
msgstr ""

#: src/code/seq.lisp
msgid ""
"FUNCTION must take as many arguments as there are sequences provided.  The \n"
"   result is a sequence such that element i is the result of applying "
"FUNCTION\n"
"   to element i of each of the argument sequences."
msgstr ""

#: src/code/seq.lisp
msgid ""
"PREDICATE is applied to the elements with index 0 of the sequences, then \n"
"   possibly to those with index 1, and so on.  SOME returns the first \n"
"   non-() value encountered, or () if the end of a sequence is reached."
msgstr ""

#: src/code/seq.lisp
msgid ""
"PREDICATE is applied to the elements with index 0 of the sequences, then\n"
"   possibly to those with index 1, and so on.  EVERY returns () as soon\n"
"   as any invocation of PREDICATE returns (), or T if every invocation\n"
"   is non-()."
msgstr ""

#: src/code/seq.lisp
msgid ""
"PREDICATE is applied to the elements with index 0 of the sequences, then \n"
"   possibly to those with index 1, and so on.  NOTANY returns () as soon\n"
"   as any invocation of PREDICATE returns a non-() value, or T if the end\n"
"   of a sequence is reached."
msgstr ""

#: src/code/seq.lisp
msgid ""
"PREDICATE is applied to the elements with index 0 of the sequences, then\n"
"   possibly to those with index 1, and so on.  NOTEVERY returns T as soon\n"
"   as any invocation of PREDICATE returns (), or () if every invocation\n"
"   is non-()."
msgstr ""

#: src/code/seq.lisp
msgid ""
"The specified Sequence is ``reduced'' using the given Function.\n"
"  See manual for details."
msgstr ""

#: src/code/seq.lisp
msgid "Coerces the Object to an object of type Output-Type-Spec."
msgstr ""

#: src/code/seq.lisp
msgid "~S can't be converted to type ~S."
msgstr ""

#: src/code/seq.lisp
msgid ""
"Returns a sequence formed by destructively removing the specified Item from\n"
"  the given Sequence."
msgstr ""

#: src/code/seq.lisp
msgid ""
"Returns a sequence formed by destructively removing the elements satisfying\n"
"  the specified Predicate from the given Sequence."
msgstr ""

#: src/code/seq.lisp
msgid ""
"Returns a sequence formed by destructively removing the elements not\n"
"  satisfying the specified Predicate from the given Sequence."
msgstr ""

#: src/code/seq.lisp
msgid ""
"Returns a copy of SEQUENCE with elements satisfying the test (default is\n"
"   EQL) with ITEM removed."
msgstr ""

#: src/code/seq.lisp
msgid ""
"Returns a copy of sequence with elements such that predicate(element)\n"
"   is non-null are removed"
msgstr ""

#: src/code/seq.lisp
msgid ""
"Returns a copy of sequence with elements such that predicate(element)\n"
"   is null are removed"
msgstr ""

#: src/code/seq.lisp
msgid ""
"The elements of Sequence are compared pairwise, and if any two match,\n"
"   the one occuring earlier is discarded, unless FROM-END is true, in\n"
"   which case the one later in the sequence is discarded.  The resulting\n"
"   sequence is returned.\n"
"\n"
"   The :TEST-NOT argument is deprecated."
msgstr ""

#: src/code/seq.lisp
msgid ""
"The elements of Sequence are examined, and if any two match, one is\n"
"   discarded.  The resulting sequence, which may be formed by destroying "
"the\n"
"   given sequence, is returned.\n"
"\n"
"   The :TEST-NOT argument is deprecated."
msgstr ""

#: src/code/seq.lisp
msgid ""
"Returns a sequence of the same kind as Sequence with the same elements\n"
"  except that all elements equal to Old are replaced with New.  See manual\n"
"  for details."
msgstr ""

#: src/code/seq.lisp
msgid ""
"Returns a sequence of the same kind as Sequence with the same elements\n"
"  except that all elements satisfying the Test are replaced with New.  See\n"
"  manual for details."
msgstr ""

#: src/code/seq.lisp
msgid ""
"Returns a sequence of the same kind as Sequence with the same elements\n"
"  except that all elements not satisfying the Test are replaced with New.\n"
"  See manual for details."
msgstr ""

#: src/code/seq.lisp
msgid ""
"Returns a sequence of the same kind as Sequence with the same elements\n"
"  except that all elements equal to Old are replaced with New.  The Sequence"
"\n"
"  may be destroyed.  See manual for details."
msgstr ""

#: src/code/seq.lisp
msgid ""
"Returns a sequence of the same kind as Sequence with the same elements\n"
"   except that all elements satisfying the Test are replaced with New.  The\n"
"   Sequence may be destroyed.  See manual for details."
msgstr ""

#: src/code/seq.lisp
msgid ""
"Returns a sequence of the same kind as Sequence with the same elements\n"
"   except that all elements not satisfying the Test are replaced with New.\n"
"   The Sequence may be destroyed.  See manual for details."
msgstr ""

#: src/code/seq.lisp
msgid ""
"Returns the zero-origin index of the first element in SEQUENCE\n"
"   satisfying the test (default is EQL) with the given ITEM"
msgstr ""

#: src/code/seq.lisp
msgid "Returns the zero-origin index of the first element satisfying test(el)"
msgstr ""

#: src/code/seq.lisp
msgid ""
"Returns the zero-origin index of the first element not satisfying test(el)"
msgstr ""

#: src/code/seq.lisp
msgid ""
"Returns the first element in SEQUENCE satisfying the test (default\n"
"   is EQL) with the given ITEM"
msgstr ""

#: src/code/seq.lisp
msgid "Returns the first element in SEQUENCE satisfying the test."
msgstr ""

#: src/code/seq.lisp
msgid "Returns the first element in SEQUENCE not satisfying the test."
msgstr ""

#: src/code/seq.lisp
msgid ""
"Returns the number of elements in SEQUENCE satisfying a test with ITEM,\n"
"   which defaults to EQL."
msgstr ""

#: src/code/seq.lisp
msgid ":TEST and :TEST-NOT are both present."
msgstr ""

#: src/code/seq.lisp
msgid "Returns the number of elements in SEQUENCE satisfying TEST(el)."
msgstr ""

#: src/code/seq.lisp
msgid ""
"The specified subsequences of Sequence1 and Sequence2 are compared\n"
"   element-wise.  If they are of equal length and match in every element, "
"the\n"
"   result is NIL.  Otherwise, the result is a non-negative integer, the "
"index\n"
"   within Sequence1 of the leftmost position at which they fail to match; "
"or,\n"
"   if one is shorter than and a matching prefix of the other, the index "
"within\n"
"   Sequence1 beyond the last position tested is returned.  If a non-Nil\n"
"   :From-End keyword argument is given, then one plus the index of the\n"
"   rightmost position in which the sequences differ is returned."
msgstr ""

#: src/code/seq.lisp
msgid ""
"A search is conducted using EQL for the first subsequence of sequence2 \n"
"   which element-wise matches sequence1.  If there is such a subsequence in "
"\n"
"   sequence2, the index of the its leftmost element is returned; \n"
"   otherwise () is returned."
msgstr ""

#: src/code/string.lisp
msgid ""
"Test if C is a surrogate.  C may be either an integer or a\n"
"  character. Surrogate-type indicates what kind of surrogate to test\n"
"  for.  :High means to test for the high (leading) surrogate; :Low\n"
"  tests for the low (trailing surrogate).  A value of :Any or Nil\n"
"  tests for any surrogate value (high or low)."
msgstr ""

#: src/code/string.lisp
msgid ""
"Convert the given Hi and Lo surrogate characters to the\n"
"  corresponding codepoint value"
msgstr ""

#: src/code/string.lisp
msgid ""
"Return the codepoint value from String at position I.  If that\n"
"  position is a surrogate, it is combined with either the previous or\n"
"  following character (when possible) to compute the codepoint.  The\n"
"  second return value is NIL if the position is not a surrogate pair.\n"
"  Otherwise +1 or -1 is returned if the position is the high or low\n"
"  surrogate value, respectively."
msgstr ""

#: src/code/string.lisp
msgid ""
"WITH-STRING-CODEPOINT-ITERATOR ((next string) &body body)\n"
"  provides a method of looping through a string from the beginning to\n"
"  the end of the string prodcucing successive codepoints from the\n"
"  string.  NEXT is bound to a generator macro that, within the scope\n"
"  of the invocation, returns one or two values. The first value tells\n"
"  whether any objects remain in the string. When the first value is\n"
"  non-NIL, the second value is the codepoint of the next object."
msgstr ""

#: src/code/string.lisp
msgid ""
"Return the high and low surrogate characters for Codepoint.  If\n"
"  Codepoint is in the BMP, the first return value is the corresponding\n"
"  character and the second is NIL."
msgstr ""

#: src/code/string.lisp
msgid ""
"Set the codepoint at string position I to the Codepoint.  If the\n"
"  codepoint requires a surrogate pair, the high (leading surrogate) is\n"
"  stored at position I and the low (trailing) surrogate is stored at\n"
"  I+1"
msgstr ""

#: src/code/string.lisp
msgid ""
"Check if String is a valid UTF-16 string.  If the string is valid,\n"
"  T is returned.  If the string is not valid, NIL is returned, and the\n"
"  second value is the index into the string of the invalid character.\n"
"  A string is also invalid if it contains any unassigned codepoints."
msgstr ""

#: src/code/string.lisp
msgid ""
"Coerces X into a string.  If X is a string, X is returned.  If X is a\n"
"  symbol, X's pname is returned.  If X is a character then a one element\n"
"  string containing that character is returned.  If X cannot be coerced\n"
"  into a string, an error occurs."
msgstr ""

#: src/code/string.lisp
msgid "~S cannot be coerced to a string."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given a string and a non-negative integer index less than the length of\n"
"  the string, returns the character object representing the character at\n"
"  that position in the string."
msgstr ""

#: src/code/string.lisp
msgid ""
"SCHAR returns the character object at an indexed position in a string\n"
"  just as CHAR does, except the string must be a simple-string."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given two strings, if the first string is lexicographically less than\n"
"  the second string, returns the longest common prefix (using char=)\n"
"  of the two strings. Otherwise, returns ()."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given two strings, if the first string is lexicographically greater than\n"
"  the second string, returns the longest common prefix (using char=)\n"
"  of the two strings. Otherwise, returns ()."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given two strings, if the first string is lexicographically less than\n"
"  or equal to the second string, returns the longest common prefix\n"
"  (using char=) of the two strings. Otherwise, returns ()."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given two strings, if the first string is lexicographically greater\n"
"  than or equal to the second string, returns the longest common prefix\n"
"  (using char=) of the two strings. Otherwise, returns ()."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given two strings (string1 and string2), and optional integers start1,\n"
"  start2, end1 and end2, compares characters in string1 to characters in\n"
"  string2 (using char=)."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given two strings, if the first string is not lexicographically equal\n"
"  to the second string, returns the longest common prefix (using char=)\n"
"  of the two strings. Otherwise, returns ()."
msgstr ""

#: src/code/string.lisp
msgid ""
"Return a new string with the case folded according to Casing as follows:\n"
"\n"
"  :SIMPLE  Unicode simple case folding (preserving length)\n"
"  :FULL    Unicode full case folding (possibly changing length)\n"
"\n"
"  Default Casing is :SIMPLE."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given two strings (string1 and string2), and optional integers start1,\n"
"  start2, end1 and end2, compares characters in string1 to characters in\n"
"  string2 (using char-equal)."
msgstr ""

#: src/code/string.lisp
msgid "Improper bounds for string comparison."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given two strings, if the first string is not lexicographically equal\n"
"  to the second string, returns the longest common prefix (using char-equal)"
"\n"
"  of the two strings. Otherwise, returns ()."
msgstr ""

#: src/code/string.lisp
msgid "Improper substring for comparison."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given two strings, if the first string is lexicographically less than\n"
"  the second string, returns the longest common prefix (using char-equal)\n"
"  of the two strings. Otherwise, returns ()."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given two strings, if the first string is lexicographically greater than\n"
"  the second string, returns the longest common prefix (using char-equal)\n"
"  of the two strings. Otherwise, returns ()."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given two strings, if the first string is lexicographically greater\n"
"  than or equal to the second string, returns the longest common prefix\n"
"  (using char-equal) of the two strings. Otherwise, returns ()."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given two strings, if the first string is lexicographically less than\n"
"  or equal to the second string, returns the longest common prefix\n"
"  (using char-equal) of the two strings. Otherwise, returns ()."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given a character count and an optional fill character, makes and returns\n"
"  a new string Count long filled with the fill character."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given a string, returns a new string that is a copy of it with all\n"
"  lower case alphabetic characters converted to uppercase."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given a string, returns a new string that is a copy of it with all\n"
"  upper case alphabetic characters converted to lowercase."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given a string, returns a copy of the string with the first\n"
"  character of each ``word'' converted to upper-case, and remaining\n"
"  chars in the word converted to lower case. A ``word'' is defined\n"
"  to be a string of case-modifiable characters delimited by\n"
"  non-case-modifiable chars."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given a string, returns that string with all lower case alphabetic\n"
"  characters converted to uppercase."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given a string, returns that string with all upper case alphabetic\n"
"  characters converted to lowercase."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given a string, returns that string with the first\n"
"  character of each ``word'' converted to upper-case, and remaining\n"
"  chars in the word converted to lower case. A ``word'' is defined\n"
"  to be a string of case-modifiable characters delimited by\n"
"  non-case-modifiable chars."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given a set of characters (a list or string) and a string, returns\n"
"  a copy of the string with the characters in the set removed from the\n"
"  left end.  If the set of characters is a string, surrogates will be\n"
"  properly handled."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given a set of characters (a list or string) and a string, returns\n"
"  a copy of the string with the characters in the set removed from the\n"
"  right end.  If the set of characters is a string, surrogates will be\n"
"  properly handled."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given a set of characters (a list or string) and a string, returns a\n"
"  copy of the string with the characters in the set removed from both\n"
"  ends.  If the set of characters is a string, surrogates will be\n"
"  properly handled."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given a set of characters (a list or string) and a string, returns\n"
"  a copy of the string with the characters in the set removed from the\n"
"  left end."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given a set of characters (a list or string) and a string, returns\n"
"  a copy of the string with the characters in the set removed from the\n"
"  right end."
msgstr ""

#: src/code/string.lisp
msgid ""
"Given a set of characters (a list or string) and a string, returns a\n"
"  copy of the string with the characters in the set removed from both\n"
"  ends."
msgstr ""

#: src/code/string.lisp
msgid ""
"GLYPH returns the glyph at the indexed position in a string, and the\n"
"  position of the next glyph (or NIL) as a second value.  A glyph is\n"
"  a substring consisting of the character at INDEX followed by all\n"
"  subsequent combining characters."
msgstr ""

#: src/code/string.lisp
msgid ""
"SGLYPH returns the glyph at the indexed position, the same as GLYPH,\n"
"  except that the string must be a simple-string"
msgstr ""

#: src/code/string.lisp
msgid ""
"WITH-STRING-GLYPH-ITERATOR ((next string) &body body)\n"
"  provides a method of looping through a string from the beginning to\n"
"  the end of the string prodcucing successive glyphs from the string.\n"
"  NEXT is bound to a generator macro that, within the scope of the\n"
"  invocation, returns one or three values. The first value tells\n"
"  whether any objects remain in the string. When the first value is\n"
"  non-NIL, the second value is the index into the string of the glyph\n"
"  and the third value is index of the next glyph."
msgstr ""

#: src/code/string.lisp
msgid ""
"Convert String to Unicode Normalization Form D (NFD) using the\n"
"  canonical decomposition.  The NFD string is returned"
msgstr ""

#: src/code/string.lisp
msgid ""
"Convert String to Unicode Normalization Form KD (NFKD) uisng the\n"
"  compatible decomposition form.  The NFKD string is returned."
msgstr ""

#: src/code/string.lisp
msgid ""
"Convert String to Unicode Normalization Form C (NFC).  If the\n"
"  string a simple string and is already normalized, the original\n"
"  string is returned."
msgstr ""

#: src/code/string.lisp
msgid ""
"Convert String to Unicode Normalization Form KC (NFKC).  If the\n"
"  string is a simple string and is already normalized, the original\n"
"  string is returned."
msgstr ""

#: src/code/string.lisp
msgid ""
"Convert a sequence of codepoints to a string.  Codepoints outside\n"
"  the basic multilingual plane (BMP) are converted into the\n"
"  corresponding surrogate pairs."
msgstr ""

#: src/code/string.lisp
msgid ""
"Convert a string to a list of corresponding code points.  Surrogate\n"
"  pairs in the string are converted into the correspoinding\n"
"  codepoint."
msgstr ""

#: src/code/mipsstrops.lisp
msgid ""
"Compares the substrings specified by String1 and String2 and returns\n"
"NIL if the strings are String=, or the lowest index of String1 in\n"
"which the two differ. If one string is longer than the other and the\n"
"shorter is a prefix of the longer, the length of the shorter + start1 is\n"
"returned. This would be done on the Vax with CMPC3. The arguments must\n"
"be simple strings."
msgstr ""

#: src/code/mipsstrops.lisp
msgid "Like %sp-string-compare, only backwards."
msgstr ""

#: src/code/mipsstrops.lisp
msgid ""
"%SP-Find-Character-With-Attribute  String, Start, End, Table, Mask\n"
"  The codes of the characters of String from Start to End are used as "
"indices\n"
"  into the Table, which is a U-Vector of 8-bit bytes. When the number "
"picked\n"
"  up from the table bitwise ANDed with Mask is non-zero, the current\n"
"  index into the String is returned. The corresponds to SCANC on the Vax."
msgstr ""

#: src/code/mipsstrops.lisp
msgid "Like %SP-Find-Character-With-Attribute, only sdrawkcaB."
msgstr ""

#: src/code/mipsstrops.lisp
msgid ""
"%SP-Find-Character  String, Start, End, Character\n"
"  Searches String for the Character from Start to End.  If the character is\n"
"  found, the corresponding index into String is returned, otherwise NIL is\n"
"  returned."
msgstr ""

#: src/code/mipsstrops.lisp
msgid ""
"%SP-Reverse-Find-Character  String, Start, End, Character\n"
"  Searches String for Character from End to Start.  If the character is\n"
"  found, the corresponding index into String is returned, otherwise NIL is\n"
"  returned."
msgstr ""

#: src/code/mipsstrops.lisp
msgid ""
"%SP-Skip-Character  String, Start, End, Character\n"
"  Returns the index of the first character between Start and End which\n"
"  is not Char=  to Character, or NIL if there is no such character."
msgstr ""

#: src/code/mipsstrops.lisp
msgid ""
"%SP-Skip-Character  String, Start, End, Character\n"
"  Returns the index of the last character between Start and End which\n"
"  is not Char=  to Character, or NIL if there is no such character."
msgstr ""

#: src/code/mipsstrops.lisp
msgid ""
"%SP-String-Search  String1, Start1, End1, String2, Start2, End2\n"
"   Searches for the substring of String1 specified in String2.\n"
"   Returns an index into String2 or NIL if the substring wasn't\n"
"   found."
msgstr ""

#: src/code/symbol.lisp
msgid ""
"VARIABLE must evaluate to a symbol.  This symbol's current special\n"
"  value is returned."
msgstr ""

#: src/code/symbol.lisp
msgid ""
"VARIABLE must evaluate to a symbol.  Return NIL if this symbol is\n"
"  unbound, T if it has a value."
msgstr ""

#: src/code/symbol.lisp
msgid ""
"VARIABLE must evaluate to a symbol.  This symbol's special value cell is\n"
"  set to the specified new value."
msgstr ""

#: src/code/symbol.lisp
msgid "Nihil ex nihil, can't set NIL."
msgstr ""

#: src/code/symbol.lisp
msgid "Veritas aeterna, can't set T."
msgstr ""

#: src/code/symbol.lisp
msgid "Can't set keywords."
msgstr ""

#: src/code/symbol.lisp
msgid ""
"VARIABLE must evaluate to a symbol.  This symbol is made unbound,\n"
"  removing any value it may currently have."
msgstr ""

#: src/code/symbol.lisp
msgid ""
"VARIABLE must evaluate to a symbol.  This symbol's current definition\n"
"   is returned.  Settable with SETF."
msgstr ""

#: src/code/symbol.lisp
msgid "VARIABLE must evaluate to a symbol.  Return its property list."
msgstr ""

#: src/code/symbol.lisp
msgid "VARIABLE must evaluate to a symbol.  Return its print name."
msgstr ""

#: src/code/symbol.lisp
msgid "VARIABLE must evaluate to a symbol.  Return its package."
msgstr ""

#: src/code/symbol.lisp
msgid "Make and return a new symbol with the STRING as its print name."
msgstr ""

#: src/code/symbol.lisp
msgid "Return the hash value for symbol."
msgstr ""

#: src/code/symbol.lisp
msgid ""
"Look on the property list of SYMBOL for the specified INDICATOR.  If this\n"
"  is found, return the associated value, else return DEFAULT."
msgstr ""

#: src/code/symbol.lisp
msgid "~S has an odd number of items in its property list."
msgstr ""

#: src/code/symbol.lisp
msgid ""
"The VALUE is added as a property of SYMBOL under the specified INDICATOR.\n"
"  Returns VALUE."
msgstr ""

#: src/code/symbol.lisp
msgid ""
"Look on property list of SYMBOL for property with specified\n"
"  INDICATOR.  If found, splice this indicator and its value out of\n"
"  the plist, and return the tail of the original list starting with\n"
"  INDICATOR.  If not found, return () with no side effects.\n"
"\n"
"  NOTE: The ANSI specification requires REMPROP to return true (not false)\n"
"  or false (the symbol NIL). Portable code should not rely on any other "
"value."
msgstr ""

#: src/code/symbol.lisp
msgid ""
"Searches the property list stored in Place for an indicator EQ to "
"Indicator.\n"
"  If one is found, the corresponding value is returned, else the Default is\n"
"  returned."
msgstr ""

#: src/code/symbol.lisp
msgid "Malformed property list: ~S"
msgstr ""

#: src/code/symbol.lisp
msgid ""
"Like GETF, except that Indicator-List is a list of indicators which will\n"
"  be looked for in the property list stored in Place.  Three values are\n"
"  returned, see manual for details."
msgstr ""

#: src/code/symbol.lisp
msgid ""
"Make and return a new uninterned symbol with the same print name\n"
"  as SYMBOL.  If COPY-PROPS is false, the new symbol is neither bound\n"
"  nor fbound and has no properties, else it has a copy of SYMBOL's\n"
"  function, value and property list."
msgstr ""

#: src/code/symbol.lisp
msgid "Returns true if Object is a symbol in the keyword package."
msgstr ""

#: src/code/symbol.lisp
msgid "Counter for generating unique GENSYM symbols."
msgstr ""

#: src/code/symbol.lisp
msgid ""
"Creates a new uninterned symbol whose name is a prefix string (defaults\n"
"   to \"G\"), followed by a decimal number.  Thing, when supplied, will\n"
"   alter the prefix if it is a string, or be used for the decimal number\n"
"   if it is a number, of this symbol. The default value of the number is\n"
"   the current value of *gensym-counter* which is incremented each time\n"
"   it is used."
msgstr ""

#: src/code/symbol.lisp
msgid ""
"Creates a new symbol interned in package Package with the given Prefix."
msgstr ""

#: src/code/bignum.lisp
msgid ""
"When the bignum pieces are smaller than this many words, we use the\n"
"classical multiplication algorithm instead of recursing all the way\n"
"down to individual words."
msgstr ""

#: src/code/bignum.lisp
msgid "Use Karatsuba if the bignums have at least this many bits"
msgstr ""

#: src/code/bignum.lisp
msgid "WITH-BIGNUM-BUFFERS ({(var size [init])}*) Form*"
msgstr ""

#: src/code/bignum.lisp
msgid "Unexpected zero bignums?"
msgstr ""

#: src/code/bignum.lisp
msgid "Can't represent result of left shift."
msgstr ""

#: src/code/bignum.lisp
msgid "Too large to be represented as a ~S:~%  ~S"
msgstr ""

#: src/code/numbers.lisp
msgid "More types than vars."
msgstr ""

#: src/code/numbers.lisp
msgid "Duplicate case: ~S."
msgstr ""

#: src/code/numbers.lisp
msgid "More vars than types."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"NUMBER-DISPATCH ({(Var Type)}*) {((Type*) Form*) | (Symbol Arg*)}*\n"
"  A vaguely case-like macro that does number cross-product dispatches.  The\n"
"  Vars are the variables we are dispatching off of.  The Type paired with "
"each\n"
"  Var is used in the error message when no case matches.  Each case specifie"
"s a\n"
"  Type for each var, and is executed when that signature holds.  A type may "
"be\n"
"  a list (FOREACH Each-Type*), causing that case to be repeatedly instantiat"
"ed\n"
"  for every Each-Type.  In the body of each case, any list of the form\n"
"  (DISPATCH-TYPE Var-Name) is substituted with the type of that var in that\n"
"  instance of the case.\n"
"\n"
"  As an alternate to a case spec, there may be a form whose CAR is a "
"symbol.\n"
"  In this case, we apply the CAR of the form to the CDR and treat the "
"result of\n"
"  the call as a list of cases.  This process is not applied recursively."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Returns the element type of the most specialized COMPLEX number type that\n"
"   can hold parts of type Spec."
msgstr ""

#: src/code/numbers.lisp
msgid "Assume this is a subtype of REAL anyway."
msgstr ""

#: src/code/numbers.lisp
msgid "Cannot determine if ~S is a subtype of REAL."
msgstr ""

#: src/code/numbers.lisp
msgid "Complex numbers cannot have components of type ~S."
msgstr ""

#: src/code/numbers.lisp
msgid "Builds a complex number from the specified components."
msgstr ""

#: src/code/numbers.lisp
msgid "Extracts the real part of a number."
msgstr ""

#: src/code/numbers.lisp
msgid "Extracts the imaginary part of a number."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Returns the complex conjugate of NUMBER.  For non-complex numbers, this is\n"
"  an identity."
msgstr ""

#: src/code/numbers.lisp
msgid "If NUMBER is zero, return NUMBER, else return (/ NUMBER (ABS NUMBER))."
msgstr ""

#: src/code/numbers.lisp
msgid "Return the numerator of NUMBER, which must be rational."
msgstr ""

#: src/code/numbers.lisp
msgid "Return the denominator of NUMBER, which must be rational."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns the sum of its arguments.  With no args, returns 0."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns the product of its arguments.  With no args, returns 1."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Subtracts the second and all subsequent arguments from the first.\n"
"  With one arg, negates it."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Divides the first arg by each of the following arguments, in turn.\n"
"  With one arg, returns reciprocal."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns NUMBER + 1."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns NUMBER - 1."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Returns number (or number/divisor) as an integer, rounded toward 0.\n"
"  The second returned value is the remainder."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Returns the greatest integer not greater than number, or number/divisor.\n"
"  The second returned value is (mod number divisor)."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Returns the smallest integer not less than number, or number/divisor.\n"
"  The second returned value is the remainder."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Rounds number (or number/divisor) to nearest integer.\n"
"  The second returned value is the remainder."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns second result of TRUNCATE."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns second result of FLOOR."
msgstr ""

#: src/code/numbers.lisp
msgid "Same as TRUNCATE, but returns first value as a float."
msgstr ""

#: src/code/numbers.lisp
msgid "Same as FLOOR, but returns first value as a float."
msgstr ""

#: src/code/numbers.lisp
msgid "Same as CEILING, but returns first value as a float."
msgstr ""

#: src/code/numbers.lisp
msgid "Same as ROUND, but returns first value as a float."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Returns T if all of its arguments are numerically equal, NIL otherwise."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Returns T if no two of its arguments are numerically equal, NIL otherwise."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Returns T if its arguments are in strictly increasing order, NIL otherwise."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Returns T if its arguments are in strictly decreasing order, NIL otherwise."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Returns T if arguments are in strictly non-decreasing order, NIL otherwise."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Returns T if arguments are in strictly non-increasing order, NIL otherwise."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns the greatest of its arguments."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns the least of its arguments."
msgstr ""

#: src/code/numbers.lisp
msgid "Return T if OBJ1 and OBJ2 represent the same object, otherwise NIL."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns the bit-wise or of its arguments.  Args must be integers."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Returns the bit-wise exclusive or of its arguments.  Args must be integers."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns the bit-wise and of its arguments.  Args must be integers."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Returns the bit-wise equivalence of its arguments.  Args must be integers."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns the complement of the logical AND of integer1 and integer2."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns the complement of the logical OR of integer1 and integer2."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns the logical AND of (LOGNOT integer1) and integer2."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns the logical AND of integer1 and (LOGNOT integer2)."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns the logical OR of (LOGNOT integer1) and integer2."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns the logical OR of integer1 and (LOGNOT integer2)."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns the bit-wise logical not of integer."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns the complement of the AND of integer1 and integer2"
msgstr ""

#: src/code/numbers.lisp
msgid "Returns the complement of the OR of integer1 and integer2"
msgstr ""

#: src/code/numbers.lisp
msgid "Returns the AND of (LOGNOT integer1) and integer2"
msgstr ""

#: src/code/numbers.lisp
msgid "Returns the AND of integer1 and (LOGNOT integer2)"
msgstr ""

#: src/code/numbers.lisp
msgid "Returns the OR of (LOGNOT integer1) and integer2"
msgstr ""

#: src/code/numbers.lisp
msgid "Returns the OR of integer1 and (LOGNOT integer2)"
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Count the number of 1 bits if INTEGER is positive, and the number of 0 bits\n"
"  if INTEGER is negative."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Predicate which returns T if logand of integer1 and integer2 is not zero."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Predicate returns T if bit index of integer is a 1.  The least\n"
"significant bit of INTEGER is bit 0."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Shifts integer left by count places preserving sign.  - count shifts right."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Returns the number of significant bits in the absolute value of integer."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns a byte specifier which may be used by other byte functions."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns the size part of the byte specifier bytespec."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns the position part of the byte specifier bytespec."
msgstr ""

#: src/code/numbers.lisp
msgid "Extract the specified byte from integer, and right justify result."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns T if any of the specified bits in integer are 1's."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Extract the specified byte from integer,  but do not right justify result."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Returns new integer with newbyte in specified position, newbyte is right "
"justified."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Returns new integer with newbyte in specified position, newbyte is not "
"right justified."
msgstr ""

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return 0."
msgstr ""

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return -1."
msgstr ""

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return integer1."
msgstr ""

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return integer2."
msgstr ""

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return complement of integer1."
msgstr ""

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return complement of integer2."
msgstr ""

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return logand of integer1 and integer2."
msgstr ""

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return logior of integer1 and integer2."
msgstr ""

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return logxor of integer1 and integer2."
msgstr ""

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return logeqv of integer1 and integer2."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Boole function op, makes BOOLE return log nand of integer1 and integer2."
msgstr ""

#: src/code/numbers.lisp
msgid "Boole function op, makes BOOLE return lognor of integer1 and integer2."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Boole function op, makes BOOLE return logandc1 of integer1 and integer2."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Boole function op, makes BOOLE return logandc2 of integer1 and integer2."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Boole function op, makes BOOLE return logorc1 of integer1 and integer2."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Boole function op, makes BOOLE return logorc2 of integer1 and integer2."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Bit-wise boolean function on two integers.  Function chosen by OP:\n"
"	0	BOOLE-CLR\n"
"	1	BOOLE-SET\n"
"	2	BOOLE-1\n"
"  	3	BOOLE-2\n"
"	4	BOOLE-C1\n"
"	5	BOOLE-C2\n"
"	6	BOOLE-AND\n"
"	7	BOOLE-IOR\n"
" 	8	BOOLE-XOR\n"
"	9	BOOLE-EQV\n"
"	10	BOOLE-NAND\n"
"	11	BOOLE-NOR\n"
"	12	BOOLE-ANDC1\n"
"	13	BOOLE-ANDC2\n"
"	14	BOOLE-ORC1\n"
"	15	BOOLE-ORC2"
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Returns the greatest common divisor of the arguments, which must be\n"
"  integers.  Gcd with no arguments is defined to be 0."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Returns the least common multiple of one or more integers.  LCM of no\n"
"  arguments is defined to be 1."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns T iff X is a positive prime integer."
msgstr ""

#: src/code/numbers.lisp
msgid ""
"Returns the root of the nearest integer less than n which is a perfect\n"
"   square."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns T if number = 0, NIL otherwise."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns T if number > 0, NIL otherwise."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns T if number < 0, NIL otherwise."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns T if number is odd, NIL otherwise."
msgstr ""

#: src/code/numbers.lisp
msgid "Returns T if number is even, NIL otherwise."
msgstr ""

#: src/code/float-trap.lisp
msgid "Unknown float trap kind: ~S."
msgstr ""

#: src/code/float-trap.lisp
msgid ""
"Encode the floating-point modes according to the give options and the\n"
"  specified mode, Floating-Point-Modes.  The resulting new mode is\n"
"  returned.  If a keyword is not supplied, then the current value is\n"
"  preserved.  Possible keywords:\n"
"\n"
"   :TRAPS\n"
"       A list of the exception conditions that should cause traps.  Possible"
"\n"
"       exceptions are :UNDERFLOW, :OVERFLOW, :INEXACT, :INVALID,\n"
"       :DIVIDE-BY-ZERO, and on the X86 :DENORMALIZED-OPERAND. Initially\n"
"       all traps except :INEXACT are enabled.\n"
"\n"
"   :ROUNDING-MODE\n"
"       The rounding mode to use when the result is not exact.  Possible "
"values\n"
"       are :NEAREST, :POSITIVE-INFINITY, :NEGATIVE-INFINITY and :ZERO.\n"
"       Initially, the rounding mode is :NEAREST.\n"
"\n"
"   :CURRENT-EXCEPTIONS\n"
"   :ACCRUED-EXCEPTIONS\n"
"       These arguments allow setting of the exception flags.  The main use "
"is\n"
"       setting the accrued exceptions to NIL to clear them.\n"
"\n"
"   :FAST-MODE\n"
"       Set the hardware's \"fast mode\" flag, if any.  When set, IEEE\n"
"       conformance or debuggability may be impaired.  Some machines may not\n"
"       have this feature, in which case the value is always NIL.\n"
"\n"
"   GET-FLOATING-POINT-MODES may be used to find the floating point modes\n"
"   currently in effect."
msgstr ""

#: src/code/float-trap.lisp
msgid "Unknown rounding mode: ~S."
msgstr ""

#: src/code/float-trap.lisp
msgid ""
"This function sets options controlling the floating-point hardware.  If a\n"
"  keyword is not supplied, then the current value is preserved.  Possible\n"
"  keywords:\n"
"\n"
"   :TRAPS\n"
"       A list of the exception conditions that should cause traps.  Possible"
"\n"
"       exceptions are :UNDERFLOW, :OVERFLOW, :INEXACT, :INVALID,\n"
"       :DIVIDE-BY-ZERO, and on the X86 :DENORMALIZED-OPERAND. Initially\n"
"       all traps except :INEXACT are enabled.\n"
"\n"
"   :ROUNDING-MODE\n"
"       The rounding mode to use when the result is not exact.  Possible "
"values\n"
"       are :NEAREST, :POSITIVE-INFINITY, :NEGATIVE-INFINITY and :ZERO.\n"
"       Initially, the rounding mode is :NEAREST.\n"
"\n"
"   :CURRENT-EXCEPTIONS\n"
"   :ACCRUED-EXCEPTIONS\n"
"       These arguments allow setting of the exception flags.  The main use "
"is\n"
"       setting the accrued exceptions to NIL to clear them.\n"
"\n"
"   :FAST-MODE\n"
"       Set the hardware's \"fast mode\" flag, if any.  When set, IEEE\n"
"       conformance or debuggability may be impaired.  Some machines may not\n"
"       have this feature, in which case the value is always NIL.\n"
"\n"
"   GET-FLOATING-POINT-MODES may be used to find the floating point modes\n"
"   currently in effect."
msgstr ""

#: src/code/float-trap.lisp
msgid ""
"This function returns a list representing the state of the floating point\n"
"  modes given in Modes.  The list is in the same format as the keyword "
"arguments to\n"
"  SET-FLOATING-POINT-MODES."
msgstr ""

#: src/code/float-trap.lisp
msgid ""
"This function returns a list representing the state of the floating point\n"
"  modes.  The list is in the same format as the keyword arguments to\n"
"  SET-FLOATING-POINT-MODES, i.e. \n"
"      (apply #'set-floating-point-modes (get-floating-point-modes))\n"
"\n"
"  sets the floating point modes to their current values (and thus is a "
"no-op)."
msgstr ""

#: src/code/float-trap.lisp
msgid ""
"Current-Float-Trap Trap-Name*\n"
"  Return true if any of the named traps are currently trapped, false\n"
"  otherwise."
msgstr ""

#: src/code/float-trap.lisp
msgid "SIGFPE with no exceptions currently enabled? (si-code = ~D)"
msgstr ""

#: src/code/float-trap.lisp
msgid ""
"Execute BODY with the floating point exceptions listed in TRAPS\n"
"  masked (disabled).  TRAPS should be a list of possible exceptions\n"
"  which includes :UNDERFLOW, :OVERFLOW, :INEXACT, :INVALID and\n"
"  :DIVIDE-BY-ZERO and on the X86 :DENORMALIZED-OPERAND. The respective\n"
"  accrued exceptions are cleared at the start of the body to support\n"
"  their testing within, and restored on exit."
msgstr ""

#: src/code/float-trap.lisp
msgid ""
"Execute BODY with the floating point exceptions listed in TRAPS\n"
"  enabled.  TRAPS should be a list of possible exceptions which\n"
"  includes :UNDERFLOW, :OVERFLOW, :INEXACT, :INVALID and\n"
"  :DIVIDE-BY-ZERO and on the X86 :DENORMALIZED-OPERAND. The respective\n"
"  accrued exceptions are cleared at the start of the body to support\n"
"  their testing within, and restored on exit."
msgstr ""

#: src/code/float.lisp
msgid "Return true if the float X is denormalized."
msgstr ""

#: src/code/float.lisp
msgid "Return true if the float X is an infinity (+ or -)."
msgstr ""

#: src/code/float.lisp
msgid "Return true if the float X is a quiet or signaling NaN (Not a Number)."
msgstr ""

#: src/code/float.lisp
msgid "Return true if the float X is a signaling NaN (Not a Number)."
msgstr ""

#: src/code/float.lisp
msgid "Deprecated.  Use FLOAT-SIGNALING-NAN-P instead."
msgstr ""

#: src/code/float.lisp
msgid ""
"Returns a non-negative number of significant digits in it's float argument.\n"
"  Will be less than FLOAT-DIGITS if denormalized or zero."
msgstr ""

#: src/code/float.lisp
msgid ""
"Returns a floating-point number that has the same sign as\n"
"   float1 and, if float2 is given, has the same absolute value\n"
"   as float2."
msgstr ""

#: src/code/float.lisp
msgid ""
"Returns a non-negative number of radix-b digits used in the\n"
"   representation of it's argument.  See Common Lisp: The Language\n"
"   by Guy Steele for more details."
msgstr ""

#: src/code/float.lisp
msgid "Returns (as an integer) the radix b of its floating-point\n"
"   argument."
msgstr ""

#: src/code/irrat.lisp src/code/float.lisp
msgid "Can't decode NAN or infinity: ~S."
msgstr ""

#: src/code/float.lisp
msgid ""
"Returns three values:\n"
"   1) an integer representation of the significand.\n"
"   2) the exponent for the power of 2 that the significand must be multiplie"
"d\n"
"      by to get the actual value.  This differs from the DECODE-FLOAT "
"exponent\n"
"      by FLOAT-DIGITS, since the significand has been scaled to have all "
"its\n"
"      digits before the radix point.\n"
"   3) -1 or 1 (i.e. the sign of the argument.)"
msgstr ""

#: src/code/float.lisp
msgid ""
"Returns three values:\n"
"   1) a floating-point number representing the significand.  This is always\n"
"      between 0.5 (inclusive) and 1.0 (exclusive).\n"
"   2) an integer representing the exponent.\n"
"   3) -1.0 or 1.0 (i.e. the sign of the argument.)"
msgstr ""

#: src/code/float.lisp
msgid ""
"Returns the value (* f (expt (float 2 f) ex)), but with no unnecessary loss\n"
"  of precision or overflow."
msgstr ""

#: src/code/float.lisp
msgid ""
"Converts any REAL to a float.  If OTHER is not provided, it returns a\n"
"  SINGLE-FLOAT if NUMBER is not already a FLOAT.  If OTHER is provided, the\n"
"  result is the same float format as OTHER."
msgstr ""

#: src/code/float.lisp
msgid ""
"RATIONAL produces a rational number for any real numeric argument.  This is\n"
"  more efficient than RATIONALIZE, but it assumes that floating-point is\n"
"  completely accurate, giving a result that isn't as pretty."
msgstr ""

#: src/code/float.lisp
msgid ""
"Converts any REAL to a RATIONAL.  Floats are converted to a simple rational\n"
"  representation exploiting the assumption that floats are only accurate to\n"
"  their precision.  RATIONALIZE (and also RATIONAL) preserve the invariant:\n"
"      (= x (float (rationalize x) x))"
msgstr ""

#: src/code/irrat.lisp
msgid "Return e raised to the power NUMBER."
msgstr ""

#: src/code/irrat.lisp
msgid "The absolute value of ~S exceeds limit ~S."
msgstr ""

#: src/code/irrat.lisp
msgid "Continue with calculation"
msgstr ""

#: src/code/irrat.lisp
msgid "Continue with calculation, update limit"
msgstr ""

#: src/code/irrat.lisp
msgid "Returns BASE raised to the POWER."
msgstr ""

#: src/code/irrat.lisp
msgid "Return the logarithm of NUMBER in the base BASE, which defaults to e."
msgstr ""

#: src/code/irrat.lisp
msgid "Return the square root of NUMBER."
msgstr ""

#: src/code/irrat.lisp
msgid "Returns the absolute value of the number."
msgstr ""

#: src/code/irrat.lisp
msgid ""
"Returns the angle part of the polar representation of a complex number.\n"
"  For complex numbers, this is (atan (imagpart number) (realpart number)).\n"
"  For non-complex positive numbers, this is 0.  For non-complex negative\n"
"  numbers this is PI."
msgstr ""

#: src/code/irrat.lisp
msgid "Return the sine of NUMBER."
msgstr ""

#: src/code/irrat.lisp
msgid "Return the cosine of NUMBER."
msgstr ""

#: src/code/irrat.lisp
msgid "Return the tangent of NUMBER."
msgstr ""

#: src/code/irrat.lisp
msgid "Return cos(Theta) + i sin(Theta), AKA exp(i Theta)."
msgstr ""

#: src/code/irrat.lisp
msgid "Argument to CIS is complex: ~S"
msgstr ""

#: src/code/irrat.lisp
msgid "Return the arc sine of NUMBER."
msgstr ""

#: src/code/irrat.lisp
msgid "Return the arc cosine of NUMBER."
msgstr ""

#: src/code/irrat.lisp
msgid "Return the arc tangent of Y if X is omitted or Y/X if X is supplied."
msgstr ""

#: src/code/irrat.lisp
msgid "Return the hyperbolic sine of NUMBER."
msgstr ""

#: src/code/irrat.lisp
msgid "Return the hyperbolic cosine of NUMBER."
msgstr ""

#: src/code/irrat.lisp
msgid "Return the hyperbolic tangent of NUMBER."
msgstr ""

#: src/code/irrat.lisp
msgid "Return the hyperbolic arc sine of NUMBER."
msgstr ""

#: src/code/irrat.lisp
msgid "Return the hyperbolic arc cosine of NUMBER."
msgstr ""

#: src/code/irrat.lisp
msgid "Return the hyperbolic arc tangent of NUMBER."
msgstr ""

#: src/code/irrat.lisp
msgid ""
"Compute 2^N * X without compute 2^N first (use properties of the\n"
"underlying floating-point format"
msgstr ""

#: src/code/irrat.lisp
msgid ""
"Same as logb but X is not infinity and non-zero and not a NaN, so\n"
"that we can always return an integer"
msgstr ""

#: src/code/irrat.lisp
msgid ""
"Compute an integer N such that 1 <= |2^(-N) * x| < 2.\n"
"For the special cases, the following values are used:\n"
"\n"
"    x             logb\n"
"   NaN            NaN\n"
"   +/- infinity   +infinity\n"
"   0              -infinity\n"
""
msgstr ""

#: src/code/irrat.lisp
msgid ""
"Create complex number with real part X and imaginary part Y such that\n"
"it has the same type as Z.  If Z has type (complex rational), the X\n"
"and Y are coerced to single-float."
msgstr ""

#: src/code/irrat-dd.lisp src/code/irrat.lisp
msgid ""
"Principle square root of Z\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""

#: src/code/irrat-dd.lisp src/code/irrat.lisp
msgid ""
"Compute log(2^j*z).\n"
"\n"
"This is for use with J /= 0 only when |z| is huge."
msgstr ""

#: src/code/irrat-dd.lisp src/code/irrat.lisp
msgid ""
"Log of Z = log |Z| + i * arg Z\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""

#: src/code/irrat-dd.lisp src/code/irrat.lisp
msgid "Compute atanh z = (log(1+z) - log(1-z))/2"
msgstr ""

#: src/code/irrat-dd.lisp src/code/irrat.lisp
msgid "Compute tanh z = sinh z / cosh z"
msgstr ""

#: src/code/irrat-dd.lisp src/code/irrat.lisp
msgid ""
"Compute acos z = pi/2 - asin z\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""

#: src/code/irrat-dd.lisp src/code/irrat.lisp
msgid ""
"Compute acosh z = 2 * log(sqrt((z+1)/2) + sqrt((z-1)/2))\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""

#: src/code/irrat-dd.lisp src/code/irrat.lisp
msgid ""
"Compute asin z = -i*log(i*z + sqrt(1-z^2))\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""

#: src/code/irrat-dd.lisp src/code/irrat.lisp
msgid ""
"Compute asinh z = log(z + sqrt(1 + z*z))\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""

#: src/code/irrat-dd.lisp src/code/irrat.lisp
msgid ""
"Compute atan z = (log(1+i*z) - log(1-i*z))/(2*i)\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""

#: src/code/irrat-dd.lisp src/code/irrat.lisp
msgid ""
"Compute tan z = -i * tanh(i * z)\n"
"\n"
"Z may be any number, but the result is always a complex."
msgstr ""

#: src/code/irrat-dd.lisp
msgid "log(most-positive-double-double-float)"
msgstr ""

#: src/code/irrat-dd.lisp
msgid "log(least-positive-double-double-float"
msgstr ""

#: src/code/irrat-dd.lisp
msgid "log(2)"
msgstr ""

#: src/code/irrat-dd.lisp
msgid "Log base 2 of e"
msgstr ""

#: src/code/irrat-dd.lisp
msgid "log2(e)-1"
msgstr ""

#: src/code/irrat-dd.lisp
msgid "Pi"
msgstr ""

#: src/code/irrat-dd.lisp
msgid "Pi/2"
msgstr ""

#: src/code/irrat-dd.lisp
msgid "Pi/4"
msgstr ""

#: src/code/irrat-dd.lisp
msgid "Sqrt(1/2)"
msgstr ""

#: src/code/irrat-dd.lisp
msgid "exp(x) - 1"
msgstr ""

#: src/code/irrat-dd.lisp
msgid "396 (hex) digits of 2/pi"
msgstr ""

#: src/code/irrat-dd.lisp
msgid "Overflow"
msgstr ""

#: src/compiler/proclaim.lisp
msgid ""
"~S uses lambda-list keyword naming convention, but is not a recognized "
"lambda-list keyword."
msgstr ""

#: src/compiler/proclaim.lisp
msgid "Misplaced &optional in lambda-list: ~S."
msgstr ""

#: src/compiler/proclaim.lisp
msgid "Misplaced &rest in lambda-list: ~S."
msgstr ""

#: src/compiler/proclaim.lisp
msgid "Misplaced &more in lambda-list: ~S."
msgstr ""

#: src/compiler/proclaim.lisp
msgid "Misplaced &key in lambda-list: ~S."
msgstr ""

#: src/compiler/proclaim.lisp
msgid "Misplaced &allow-other-keys in lambda-list: ~S."
msgstr ""

#: src/compiler/proclaim.lisp
msgid "Misplaced &aux in lambda-list: ~S."
msgstr ""

#: src/compiler/proclaim.lisp
msgid "Found garbage in lambda-list when expecting a keyword: ~S."
msgstr ""

#: src/compiler/proclaim.lisp
msgid "&rest not followed by required variable."
msgstr ""

#: src/compiler/proclaim.lisp
msgid "Illegal function name: ~S."
msgstr ""

#: src/compiler/proclaim.lisp
msgid "Special form is an illegal function name: ~S."
msgstr ""

#: src/compiler/proclaim.lisp
msgid ""
"Defining as a SETF function a name that already has a SETF macro:~\n"
"       ~%  ~S"
msgstr ""

#: src/compiler/proclaim.lisp
msgid "Assume redefinition is compatible and allow it"
msgstr ""

#: src/compiler/proclaim.lisp
msgid "Redefining slot accessor ~S for structure type ~S"
msgstr ""

#: src/compiler/proclaim.lisp
msgid "~S previously defined as a macro."
msgstr ""

#: src/compiler/proclaim.lisp
msgid "Unknown optimization quality ~S in ~S."
msgstr ""

#: src/compiler/proclaim.lisp
msgid "Malformed optimization quality specifier ~S in ~S."
msgstr ""

#: src/compiler/proclaim.lisp
msgid "DECLAIM Declaration*\n"
"  Do a declaration for the global environment."
msgstr ""

#: src/compiler/ir1tran.lisp src/compiler/proclaim.lisp
msgid "Malformed PROCLAIM spec: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp src/compiler/proclaim.lisp
msgid "Variable name is not a symbol: ~S."
msgstr ""

#: src/compiler/proclaim.lisp
msgid "Nihil ex nihil, can't declare ~S special."
msgstr ""

#: src/compiler/proclaim.lisp
msgid "Veritas aeterna, can't declare ~S special."
msgstr ""

#: src/compiler/proclaim.lisp
msgid "Can't declare ~S special, it is a keyword."
msgstr ""

#: src/compiler/proclaim.lisp
msgid "Proceed anyway."
msgstr ""

#: src/compiler/proclaim.lisp
msgid "Trying to declare ~S special, which is ~A."
msgstr ""

#: src/compiler/proclaim.lisp
msgid "a constant"
msgstr ""

#: src/compiler/proclaim.lisp
msgid "an alien variable"
msgstr ""

#: src/compiler/proclaim.lisp
msgid "a symbol macro"
msgstr ""

#: src/compiler/ir1tran.lisp src/compiler/proclaim.lisp
msgid "Declared functional type is not a function type: ~S."
msgstr ""

#: src/compiler/proclaim.lisp
msgid "Ignoring FTYPE declaration for slot accesor:~%  ~S"
msgstr ""

#: src/compiler/proclaim.lisp
msgid "Declaration to be RECOGNIZED is not a symbol: ~S."
msgstr ""

#: src/compiler/proclaim.lisp
msgid "Declaration already names a type: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp src/compiler/proclaim.lisp
msgid "Unrecognized proclamation: ~S."
msgstr ""

#: src/code/unidata.lisp
msgid ""
"Search the Unicode name dictionary for the longest entry that\n"
"  matches STRING.  STRING must be in Unicode name format.  That is, it\n"
"  must be upper case with spaces separating each word.\n"
"\n"
"  Two values are returned.  The first value is index into the codebook\n"
"  that continues the string..  The second value is the length of the\n"
"  substring of string that matches the codebook. "
msgstr ""

#: src/code/unidata.lisp
msgid "The Unicode data file is broken."
msgstr ""

#: src/code/unidata.lisp
msgid "Unicode data file is for Unicode ~D.~D.~D"
msgstr ""

#: src/code/unidata.lisp
msgid "No data in file."
msgstr ""

#: src/code/unidata.lisp
msgid "Dictionary of Hangul syllables"
msgstr ""

#: src/code/unidata.lisp
msgid "Dictionary of CJK Unified ideographs"
msgstr ""

#: src/code/unidata.lisp
msgid ""
"Try to complete the string Prefix using the dictionary in Dict.\n"
"  Three values are returned: (1) The best match of prefix, (2) a list\n"
"  of possible completions, (3) a boolean indicating whether the best\n"
"  match is a complete unicode name. "
msgstr ""

#: src/code/unidata.lisp
msgid ""
"Search the dictionary in Dict and return a list of the possible\n"
"  completions starting with Prefix.  If there is no match, NIL is\n"
"  returned."
msgstr ""

#: src/code/unidata.lisp
msgid "Build the dictionary for Hangul syllables"
msgstr ""

#: src/code/unidata.lisp
msgid "Build the dictionary for CJK Unified Ideographs"
msgstr ""

#: src/code/unidata.lisp
msgid ""
"Load all unicode data and set *UNIDATA-PATH* to NIL.\n"
"Normally, the unicode data is loaded as needed.  This loads all of the\n"
"data, which is useful for creating a core that no longer needs\n"
"unidata.bin."
msgstr ""

#: src/code/char.lisp
msgid "The upper exclusive bound on values produced by CHAR-CODE."
msgstr ""

#: src/code/char.lisp
msgid "The upper exclusive bound on the value of a Unicode codepoint"
msgstr ""

#: src/code/char.lisp
msgid ""
"This is the alist of (character-name . character) for characters with\n"
"  long names.  The first name in this list for a given character is used\n"
"  on typeout and is the preferred form for input."
msgstr ""

#: src/code/char.lisp
msgid "Returns the integer code of CHAR."
msgstr ""

#: src/code/char.lisp
msgid ""
"Returns the integer code of CHAR.  This is the same as char-code, as\n"
"   CMU Common Lisp does not implement character bits or fonts."
msgstr ""

#: src/code/char.lisp
msgid "Returns the character with the code CODE."
msgstr ""

#: src/code/char.lisp
msgid ""
"Coerces its argument into a character object if possible.  Accepts\n"
"  characters, strings and symbols of length 1."
msgstr ""

#: src/code/char.lisp
msgid "String is not of length one: ~S"
msgstr ""

#: src/code/char.lisp
msgid "Symbol name is not of length one: ~S"
msgstr ""

#: src/code/char.lisp
msgid "~S cannot be coerced to a character."
msgstr ""

#: src/code/char.lisp
msgid ""
"Given a character object, char-name returns the name for that\n"
"  object (a symbol)."
msgstr ""

#: src/code/char.lisp
msgid ""
"Given an argument acceptable to string, name-char returns a character\n"
"  object whose name is that symbol, if one exists, otherwise NIL."
msgstr ""

#: src/code/char.lisp
msgid ""
"The argument must be a character object.  Standard-char-p returns T if the\n"
"   argument is a standard character -- one of the 95 ASCII printing characte"
"rs\n"
"   or <return>."
msgstr ""

#: src/code/char.lisp
msgid ""
"Return T if and only if THING is a standard-char.  Differs from\n"
"  standard-char-p in that THING doesn't have to be a character."
msgstr ""

#: src/code/char.lisp
msgid ""
"The argument must be a character object.  Graphic-char-p returns T if the\n"
"  argument is a printing character, otherwise returns NIL."
msgstr ""

#: src/code/char.lisp
msgid ""
"The argument must be a character object.  Alpha-char-p returns T if the\n"
"  argument is an alphabetic character; otherwise NIL."
msgstr ""

#: src/code/char.lisp
msgid ""
"The argument must be a character object; upper-case-p returns T if the\n"
"  argument is an upper-case character, NIL otherwise."
msgstr ""

#: src/code/char.lisp
msgid ""
"The argument must be a character object; lower-case-p returns T if the \n"
"  argument is a lower-case character, NIL otherwise."
msgstr ""

#: src/code/char.lisp
msgid ""
"The argument must be a character object; title-case-p returns T if the\n"
"  argument is a title-case character, NIL otherwise."
msgstr ""

#: src/code/char.lisp
msgid ""
"The argument must be a character object.  Both-case-p returns T if the\n"
"  argument is an alphabetic character and if the character exists in\n"
"  both upper and lower case.  For ASCII, this is the same as Alpha-char-p."
msgstr ""

#: src/code/char.lisp
msgid ""
"If char is a digit in the specified radix, returns the fixnum for\n"
"  which that digit stands, else returns NIL.  Radix defaults to 10\n"
"  (decimal)."
msgstr ""

#: src/code/char.lisp
msgid ""
"Given a character-object argument, alphanumericp returns T if the\n"
"  argument is either numeric or alphabetic."
msgstr ""

#: src/code/char.lisp
msgid "Returns T if all of its arguments are the same character."
msgstr ""

#: src/code/char.lisp
msgid "Returns T if no two of its arguments are the same character."
msgstr ""

#: src/code/char.lisp
msgid ""
"Returns T if its arguments are in strictly increasing alphabetic order."
msgstr ""

#: src/code/char.lisp
msgid ""
"Returns T if its arguments are in strictly decreasing alphabetic order."
msgstr ""

#: src/code/char.lisp
msgid ""
"Returns T if its arguments are in strictly non-decreasing alphabetic order."
msgstr ""

#: src/code/char.lisp
msgid ""
"Returns T if its arguments are in strictly non-increasing alphabetic order."
msgstr ""

#: src/code/char.lisp
msgid ""
"Returns T if all of its arguments are the same character.\n"
"   Case is ignored."
msgstr ""

#: src/code/char.lisp
msgid ""
"Returns T if no two of its arguments are the same character.\n"
"   Case is ignored."
msgstr ""

#: src/code/char.lisp
msgid ""
"Returns T if its arguments are in strictly increasing alphabetic order.\n"
"   Case is ignored."
msgstr ""

#: src/code/char.lisp
msgid ""
"Returns T if its arguments are in strictly decreasing alphabetic order.\n"
"   Case is ignored."
msgstr ""

#: src/code/char.lisp
msgid ""
"Returns T if its arguments are in strictly non-decreasing alphabetic order.\n"
"   Case is ignored."
msgstr ""

#: src/code/char.lisp
msgid ""
"Returns T if its arguments are in strictly non-increasing alphabetic order.\n"
"   Case is ignored."
msgstr ""

#: src/code/char.lisp
msgid "Returns CHAR converted to upper-case if that is possible."
msgstr ""

#: src/code/char.lisp
msgid "Returns CHAR converted to title-case if that is possible."
msgstr ""

#: src/code/char.lisp
msgid "Returns CHAR converted to lower-case if that is possible."
msgstr ""

#: src/code/char.lisp
msgid ""
"All arguments must be integers.  Returns a character object that\n"
"  represents a digit of the given weight in the specified radix.  Returns\n"
"  NIL if no such character exists."
msgstr ""

#: src/code/misc.lisp
msgid ""
"Returns the documentation string of Doc-Type for X, or NIL if\n"
"  none exists.  System doc-types are VARIABLE, FUNCTION, STRUCTURE, TYPE,\n"
"  SETF, and T."
msgstr ""

#: src/code/misc.lisp
msgid "~S is not the name of a structure type."
msgstr ""

#: src/code/misc.lisp
msgid ""
"If X is an atom, see if it is present in *FEATURES*.  Also\n"
"  handle arbitrary combinations of atoms using NOT, AND, OR."
msgstr ""

#: src/code/misc.lisp
msgid "Unknown operator in feature expression: ~S."
msgstr ""

#: src/code/misc.lisp
msgid "Returns a string describing the implementation type."
msgstr ""

#: src/code/misc.lisp
msgid " Unicode"
msgstr ""

#: src/code/misc.lisp
msgid "Returns a string describing the implementation version."
msgstr ""

#: src/code/misc.lisp
msgid "Returns a string giving the name of the local machine."
msgstr ""

#: src/code/misc.lisp
msgid "The value of SOFTWARE-TYPE.  Set in FOO-os.lisp."
msgstr ""

#: src/code/misc.lisp
msgid "Returns a string describing the supporting software."
msgstr ""

#: src/code/misc.lisp
msgid "The value of SHORT-SITE-NAME.  Set in library:site-init.lisp."
msgstr ""

#: src/code/misc.lisp
msgid "Unknown"
msgstr ""

#: src/code/misc.lisp
msgid "Returns a string with the abbreviated site name."
msgstr ""

#: src/code/misc.lisp
msgid "The value of LONG-SITE-NAME.  Set in library:site-init.lisp."
msgstr ""

#: src/code/misc.lisp
msgid "Site name not initialized"
msgstr ""

#: src/code/misc.lisp
msgid "Returns a string with the long form of the site name."
msgstr ""

#: src/code/misc.lisp
msgid ""
"With a file name as an argument, dribble opens the file and\n"
"   sends a record of further I/O to that file.  Without an\n"
"   argument, it closes the dribble file, and quits logging."
msgstr ""

#: src/code/misc.lisp
msgid "Not currently dribbling."
msgstr ""

#: src/code/misc.lisp
msgid ""
"Default implementation of ed.  This does nothing.  If hemlock is\n"
"  loaded, ed can be used to edit a file"
msgstr ""

#: src/code/misc.lisp
msgid ""
"Disassemble the machine code associated with OBJECT, which can be a\n"
"  function, a lambda expression, or a symbol with a function definition.  "
"If\n"
"  it is not already compiled, the compiler is called to produce something "
"to\n"
"  disassemble."
msgstr ""

#: src/code/extensions.lisp
msgid ""
"This function can be used as the default value for keyword arguments that\n"
"  must be always be supplied.  Since it is known by the compiler to never\n"
"  return, it will avoid any compile-time type warnings that would result "
"from a\n"
"  default value inconsistent with the declared type.  When this function is\n"
"  called, it signals an error indicating that a required keyword argument "
"was\n"
"  not supplied.  This function is also useful for DEFSTRUCT slot defaults\n"
"  corresponding to required arguments."
msgstr ""

#: src/code/extensions.lisp
msgid "A required keyword argument was not supplied."
msgstr ""

#: src/code/extensions.lisp
msgid ""
"FILE-COMMENT String\n"
"  When COMPILE-FILE sees this form at top-level, it places the constant "
"string\n"
"  in the run-time source location information.  DESCRIBE will print the "
"file\n"
"  comment for the file that a function was defined in.  The string is also\n"
"  textually present in the FASL, so the RCS \"ident\" command can find it,\n"
"  etc."
msgstr ""

#: src/code/extensions.lisp
msgid "See listen.  Any whitespace in the input stream will be flushed."
msgstr ""

#: src/code/extensions.lisp
msgid ""
"Does what one might expect, saving the old values and setting the generalize"
"d\n"
"  variables to the new values in sequence.  Unwind-protects and get-setf-met"
"hod\n"
"  are used to preserve the semantics one might expect in analogy to let*,\n"
"  and the once-only evaluation of subforms."
msgstr ""

#: src/code/extensions.lisp
msgid ""
"Like letf*, but evaluates all the implicit subforms and new values of all\n"
"  the implied setfs before altering any values.  However, the store forms\n"
"  (see get-setf-method) must still be evaluated in sequence.  Uses unwind-\n"
"  protects to protect the environment."
msgstr ""

#: src/code/extensions.lisp
msgid ""
"Causes the output of the indenting Stream to indent More spaces.  More is\n"
"  evaluated twice."
msgstr ""

#: src/code/extensions.lisp
msgid "Just like dolist, but with one-dimensional arrays."
msgstr ""

#: src/code/extensions.lisp
msgid ""
"Iterate Name ({(Var Initial-Value)}*) Declaration* Form*\n"
"  This is syntactic sugar for Labels.  It creates a local function Name "
"with\n"
"  the specified Vars as its arguments and the Declarations and Forms as its\n"
"  body.  This function is then called with the Initial-Values, and the "
"result\n"
"  of the call is return from the macro."
msgstr ""

#: src/code/extensions.lisp
msgid "Malformed iterate variable spec: ~S."
msgstr ""

#: src/code/extensions.lisp
msgid ""
"Collect ({(Name [Initial-Value] [Function])}*) {Form}*\n"
"  Collect some values somehow.  Each of the collections specifies a bunch "
"of\n"
"  things which collected during the evaluation of the body of the form.  "
"The\n"
"  name of the collection is used to define a local macro, a la MACROLET.\n"
"  Within the body, this macro will evaluate each of its arguments and "
"collect\n"
"  the result, returning the current value after the collection is done.  "
"The\n"
"  body is evaluated as a PROGN; to get the final values when you are done, "
"just\n"
"  call the collection macro with no arguments.\n"
"\n"
"  Initial-Value is the value that the collection starts out with, which\n"
"  defaults to NIL.  Function is the function which does the collection.  It "
"is\n"
"  a function which will accept two arguments: the value to be collected and "
"the\n"
"  current collection.  The result of the function is made the new value for "
"the\n"
"  collection.  As a totally magical special-case, the Function may be "
"Collect,\n"
"  which tells us to build a list in forward order; this is the default.  If "
"an\n"
"  Initial-Value is supplied for Collect, the stuff will be rplacd'd onto "
"the\n"
"  end.  Note that Function may be anything that can appear in the functional"
"\n"
"  position, including macros and lambdas."
msgstr ""

#: src/code/extensions.lisp
msgid "Malformed collection specifier: ~S."
msgstr ""

#: src/code/extensions.lisp
msgid ""
"Once-Only ({(Var Value-Expression)}*) Form*\n"
"  Create a Let* which evaluates each Value-Expression, binding a temporary\n"
"  variable to the result, and wrapping the Let* around the result of the\n"
"  evaluation of Body.  Within the body, each Var is bound to the correspondi"
"ng\n"
"  temporary variable."
msgstr ""

#: src/code/extensions.lisp
msgid "Malformed Once-Only binding spec: ~S."
msgstr ""

#: src/code/extensions.lisp
msgid "Ill-formed ~S -- possibly illegal old style DO?"
msgstr ""

#: src/code/extensions.lisp
msgid "~S step variable is not a symbol: ~S"
msgstr ""

#: src/code/extensions.lisp
msgid "~S is an illegal form for a ~S varlist."
msgstr ""

#: src/code/extensions.lisp
msgid ""
"DO-ANONYMOUS ({(Var [Init] [Step])}*) (Test Exit-Form*) Declaration* Form*\n"
"  Like DO, but has no implicit NIL block.  Each Var is initialized in "
"parallel\n"
"  to the value of the specified Init form.  On subsequent iterations, the "
"Vars\n"
"  are assigned the value of the Step form (if any) in paralell.  The Test "
"is\n"
"  evaluated before each evaluation of the body Forms.  When the Test is "
"true,\n"
"  the Exit-Forms are evaluated as a PROGN, with the result being the value\n"
"  of the DO."
msgstr ""

#: src/code/extensions.lisp
msgid ""
"DO-HASH (Key-Var Value-Var Table [Result]) Declaration* Form*\n"
"   Iterate over the entries in a hash-table."
msgstr ""

#: src/code/extensions.lisp
msgid ""
"DEFINE-HASH-CACHE Name ({(Arg-Name Test-Function)}*) {Key Value}*\n"
"  Define a hash cache that associates some number of argument values to a\n"
"  result value.  The Test-Function paired with each Arg-Name is used to "
"compare\n"
"  the value for that arg in a cache entry with a supplied arg.  The\n"
"  Test-Function must not error when passed NIL as its first arg, but need "
"not\n"
"  return any particular value.  Test-Function may be any thing that can be\n"
"  place in CAR position.\n"
"\n"
"  Name is used to define functions these functions:\n"
"\n"
"  <name>-CACHE-LOOKUP Arg*\n"
"      See if there is an entry for the specified Args in the cache.  The if "
"not\n"
"      present, the :DEFAULT keyword (default NIL) determines the result(s).\n"
"\n"
"  <name>-CACHE-ENTER Arg* Value*\n"
"      Encache the association of the specified args with Value.\n"
"\n"
"  <name>-CACHE-FLUSH-<arg-name> Arg\n"
"      Flush all entries from the cache that have the value Arg for the "
"named\n"
"      arg.\n"
"\n"
"  <name>-CACHE-CLEAR\n"
"      Reinitialize the cache, invalidating all entries and allowing the\n"
"      arguments and result values to be GC'd.\n"
"\n"
"  These other keywords are defined:\n"
"\n"
"  :HASH-BITS <n>\n"
"      The size of the cache as a power of 2.\n"
"\n"
"  :HASH-FUNCTION function\n"
"      Some thing that can be placed in CAR position which will compute a "
"value\n"
"      between 0 and (1- (expt 2 <hash-bits>)).\n"
"\n"
"  :VALUES <n>\n"
"      The number of values cached.\n"
"\n"
"   :INIT-FORM <name>\n"
"      The DEFVAR for creating the cache is enclosed in a form with the\n"
"      specified name.  Default PROGN."
msgstr ""

#: src/code/extensions.lisp
msgid "Number of default values ~S differs from :VALUES ~D."
msgstr ""

#: src/code/extensions.lisp
msgid "Bad arg spec: ~S."
msgstr ""

#: src/code/extensions.lisp
msgid ""
"DEFUN-CACHED (Name {Key Value}*) ({(Arg-Name Test-Function)}*) Form*\n"
"  Some syntactic sugar for defining a function whose values are cached by\n"
"  DEFINE-HASH-CACHE."
msgstr ""

#: src/code/extensions.lisp
msgid ""
"Return an EQ hash of X.  The value of this hash for any given object can "
"(of\n"
"  course) change at arbitary times."
msgstr ""

#: src/code/commandline.lisp
msgid "A list of all the command line arguments after --"
msgstr ""

#: src/code/commandline.lisp
msgid ""
"A list of cmd-switch's representing the arguments used to invoke\n"
"  this process."
msgstr ""

#: src/code/commandline.lisp
msgid "The string name that was used to invoke this process."
msgstr ""

#: src/code/commandline.lisp
msgid "A list of words between the utility name and the first switch."
msgstr ""

#: src/code/commandline.lisp
msgid ""
"A list of strings obtained from the command line that invoked this process."
msgstr ""

#: src/code/commandline.lisp
msgid "An Alist of (\"argument-name\" . demon-function)"
msgstr ""

#: src/code/commandline.lisp
msgid ""
"When True runs lisp with its input coming from standard-input.\n"
"  If an error is detected returns error code 1, otherwise 0."
msgstr ""

#: src/code/commandline.lisp
msgid ""
"Accepts the name of a switch as a string and returns the value of\n"
"  the switch.  If no value was specified, then any following words are\n"
"  returned.  If there are no following words, then t is returned.  If\n"
"  the switch was not specified, then nil is returned."
msgstr ""

#: src/code/commandline.lisp
msgid ""
"When set, invoking switch demons complains about illegal switches\n"
"  that have not been defined with DEFSWITCH."
msgstr ""

#: src/code/commandline.lisp
msgid "~S is an illegal switch"
msgstr ""

#: src/code/commandline.lisp
msgid ""
"Associates function with the switch name in\n"
"  *command-switch-demons*.  Name is a simple-string that does not\n"
"  begin with a hyphen, unless the switch name really does begin with\n"
"  one.  Function is optional, but defining the switch is necessary to\n"
"  keep invoking switch demons from complaining about illegal switches.\n"
"  This can be inhibited with *complain-about-illegal-switches*.\n"
"\n"
"  The optional arguments, arg-name and docstring, are used by -help to\n"
"  describe the switch.  Arg-name is a string naming the argument (if\n"
"  any) for the switch.  Docstring describe the switch."
msgstr ""

#: src/code/commandline.lisp
msgid ""
"Evaluate the specified Lisp expression during the start up\n"
"  sequence.  the value of the form will not be printed unless it is\n"
"  wrapped in a form that does output."
msgstr ""

#: src/code/commandline.lisp
msgid "expression"
msgstr ""

#: src/code/commandline.lisp
msgid "a symbol or function"
msgstr ""

#: src/code/commandline.lisp
msgid ""
"Loads the specified file into Lisp before entering Lisp's\n"
"  read-eval-print loop."
msgstr ""

#: src/code/commandline.lisp
msgid "filename"
msgstr ""

#: src/code/commandline.lisp
msgid "Specifies the suspended Lisp image ('core' file) to start up"
msgstr ""

#: src/code/commandline.lisp
msgid "corefile"
msgstr ""

#: src/code/commandline.lisp
msgid ""
"Specifies the name of a file containing user customizations that is\n"
"  to be loaded each time Lisp starts up (default ~/init or\n"
"  ~/.cmucl-init.lisp).  The loader loads any existing compiled binary\n"
"  or the lisp source if none."
msgstr ""

#: src/code/commandline.lisp
msgid ""
"Suppresses loading of the init file and also prevents -edit from\n"
"  loading the Hemlock init file."
msgstr ""

#: src/code/commandline.lisp
msgid ""
"Suppresses loading of the site-init site specific initialization\n"
"  file."
msgstr ""

#: src/code/commandline.lisp
msgid ""
"Specifies the name of the Hemlock init file (default ~/hemlock-init\n"
"  or ~/.hemlock-init), which is loaded only when Hemlock is started."
msgstr ""

#: src/code/commandline.lisp
msgid ""
"Causes Lisp to run in batch mode where all input is directed from\n"
"  standard-input.  A unix return code of 0 is returned upon\n"
"  encountering an EOF, while any unhandled error condition will cause\n"
"  an immediate exit with a return code of 1, instead of entering the\n"
"  debugger."
msgstr ""

#: src/code/commandline.lisp
msgid ""
"Specifies the number of megabytes that should be allocated to the\n"
"  heap.  If not specified, a platform-specific default is used.  If 0,\n"
"  the platform-specific maximum heap size is used.  The actual maximum\n"
"  allowed heap size is platform-specific."
msgstr ""

#: src/code/commandline.lisp
msgid "megabytes"
msgstr ""

#: src/code/commandline.lisp
msgid ""
"Specifies the number of megabytes that should be allocated for the\n"
"  read-only space.  If not specified, a platform-specific default is\n"
"  used.  The actual maximum allowed read-only size is\n"
"  platform-specific."
msgstr ""

#: src/code/commandline.lisp
msgid ""
"Specifies the number of megabytes that should be allocated for the\n"
"  static space.  If not specified, a platform-specific default is\n"
"  used.  The actual maximum allowed static space size is\n"
"  platform-specific."
msgstr ""

#: src/code/commandline.lisp
msgid ""
"Specifies the number of megabytes that should be allocated for the\n"
"  control stack.  If not specified, a platform-specific default is\n"
"  used.  The actual maximum allowed control stack size is\n"
"  platform-specific."
msgstr ""

#: src/code/commandline.lisp
msgid ""
"Specifies the number of megabytes that should be allocated for the\n"
"  binding stack.  If not specified, a platform-specific default is\n"
"  used.  The actual maximum allowed binding stack size is\n"
"  platform-specific."
msgstr ""

#: src/code/commandline.lisp
msgid ""
"A colon-separated list of directories to be used for the library:\n"
"  search-list."
msgstr ""

#: src/code/commandline.lisp
msgid "libpath"
msgstr ""

#: src/code/commandline.lisp
msgid ""
"Causes Lisp to start up silently, disabling printing of the herald\n"
"  and causing most unnecessary noise, like GC messages,load messages,\n"
"  etc. to be suppressed."
msgstr ""

#: src/code/commandline.lisp
msgid ""
"Enables printing of messages indication how CMUCL is searching for\n"
"  its default core file."
msgstr ""

#: src/code/commandline.lisp
msgid "Specify the unidata.bin file to be used."
msgstr ""

#: src/code/commandline.lisp
msgid "~&Usage: ~A <options>~2%"
msgstr ""

#: src/code/commandline.lisp
msgid "Print out the command line options and exit"
msgstr ""

#: src/code/commandline.lisp
msgid "Same as -help."
msgstr ""

#: src/code/env-access.lisp
msgid ""
"Returns information about the symbol VAR in the lexical environment ENV.\n"
"Three values are returned:\n"
"  1) Type or binding of VAR.\n"
"     NIL           No definition or binding\n"
"     :special      VAR is special\n"
"     :lexical      VAR is lexical\n"
"     :symbol-macro VAR refers to a SYMBOL-MACROLET binding\n"
"     :constant     VAR refers to a named constant or VAR is a keyword\n"
"  2) non-NIL if there is a local binding\n"
"  3) An a-list containing information about any declarations that apply."
msgstr ""

#: src/code/env-access.lisp
msgid ""
"Returns information about declarations named by the symbol DECLARATION-NAME"
".\n"
"Supported DECLARATION-NAMES are\n"
"  1) OPTIMIZE\n"
"     A list whose entries are of the form (QUALITY VALUE) is returned,\n"
"     where QUALITY and VALUE are standard optimization qualities and\n"
"     values.\n"
"  2) EXT:OPTIMIZE-INTERFACE\n"
"     Like OPTIMIZE, but for the EXT:OPTIMIZE-INTERFACE declaration.\n"
"  3) DECLARATION.\n"
"     A list of the declaration names the have been proclaimed as valid."
msgstr ""

#: src/code/env-access.lisp
msgid "Unsupported declaration ~S."
msgstr ""

#: src/code/env-access.lisp
msgid ""
"Process a macro in the same way that DEFMACRO or MACROLET would.\n"
"Three values are returned:\n"
"  1) A lambda-expression that accepts two arguments\n"
"  2) A form\n"
"  3) An environment"
msgstr ""

#: src/code/env-access.lisp
msgid ""
"Returns information about the function name FUNCTION in the lexical environm"
"ent ENV.\n"
"Three values are returned:\n"
"  1) Type of definition or binding:\n"
"     NIL          No apparent definition\n"
"    :function    FUNCTION refers to a function\n"
"    :macro        FUNCTION refers to a macro\n"
"    :special-form FUNCTION is a special form\n"
"  2) non-NIL if definition is local\n"
"  3) An a-list containing information about the declarations that apply."
msgstr ""

#: src/code/env-access.lisp
msgid ""
"Return a new environment containing information in ENV that is augmented\n"
"by the specified parameters:\n"
"  :VARIABLE     a list of symbols visible as bound variables in the new\n"
"                environemnt\n"
"  :SYMBOL-MACRO a list of symbol macro definitions\n"
"  :FUNCTION     a list of function names that will be visible as local\n"
"                functions\n"
"  :MACRO        a list of local macro definitions\n"
"  :DECLARE      a list of declaration specifiers"
msgstr ""

#: src/code/dfixnum.lisp
msgid "increments dfixnum v by dfixnum i"
msgstr ""

#: src/code/dfixnum.lisp
msgid "dfixnum became too big ~a + ~a"
msgstr ""

#: src/code/dfixnum.lisp
msgid "increments dfixnum v by i (max half fixnum)"
msgstr ""

#: src/code/dfixnum.lisp
msgid "not a half-fixnum: ~a"
msgstr ""

#: src/code/dfixnum.lisp
msgid "decrement dfixnum v by dfixnum i"
msgstr ""

#: src/code/dfixnum.lisp
msgid "dfixnum became negative ~a - ~a (~a/~a)"
msgstr ""

#: src/code/dfixnum.lisp
msgid "decrement dfixnum v by half-fixnum i"
msgstr ""

#: src/code/dfixnum.lisp
msgid ""
"increments dfixnum by an interger which may be bigger than fixnum.\n"
"   May cons"
msgstr ""

#: src/code/dfixnum.lisp
msgid "returns a new dfixnum from number i"
msgstr ""

#: src/code/dfixnum.lisp
msgid "increments a pair of halffixnums by another pair"
msgstr ""

#: src/code/dfixnum.lisp
msgid "decrement dfixnum pair by another pair"
msgstr ""

#: src/code/room.lisp
msgid "~2&Summary of spaces: ~(~{~A ~}~)~%"
msgstr ""

#: src/code/room.lisp
msgid "~%~A:~%    ~:D bytes, ~:D object"
msgid_plural "~%~A:~%    ~:D bytes, ~:D objects"
msgstr[0] ""

#: src/code/room.lisp
msgid "~%Summary total:~%    ~:D bytes, ~:D objects.~%"
msgstr ""

#: src/code/room.lisp
msgid "~2&Breakdown for ~(~A~) space:~%"
msgstr ""

#: src/code/room.lisp
msgid "  ~13:D bytes for ~9:D other object.~%"
msgid_plural "  ~13:D bytes for ~9:D other objects.~%"
msgstr[0] ""

#: src/code/room.lisp
msgid "  ~13:D bytes for ~9:D ~(~A~) object.~%"
msgid_plural "  ~13:D bytes for ~9:D ~(~A~) objects.~%"
msgstr[0] ""

#: src/code/room.lisp
msgid "  ~13:D bytes for ~9:D ~(~A~) object (space total.)~%"
msgid_plural "  ~13:D bytes for ~9:D ~(~A~) objects (space total.)~%"
msgstr[0] ""

#: src/code/room.lisp
msgid ""
"Print out information about the heap memory in use.  :Print-Spaces is a "
"list\n"
"  of the spaces to print detailed information for.  :Count-Spaces is a list "
"of\n"
"  the spaces to scan.  For either one, T means all spaces (:Static, :Dyanmic"
"\n"
"  and :Read-Only.)  If :Print-Summary is true, then summary information "
"will be\n"
"  printed.  The defaults print only summary information for dynamic space.\n"
"  If true, Cutoff is a fraction of the usage in a report below which types "
"will\n"
"  be combined as OTHER."
msgstr ""

#: src/code/room.lisp
msgid "Print info about how much code and no-ops there are in Space."
msgstr ""

#: src/code/room.lisp
msgid "~:D code-object bytes, ~:D code words, with ~:D no-ops (~D%).~%"
msgstr ""

#: src/code/room.lisp
msgid "Bogus type: ~D"
msgstr ""

#: src/code/room.lisp
msgid "~:D words allocated for descriptor objects.~%"
msgstr ""

#: src/code/room.lisp
msgid "~:D bytes data/~:D words header for non-descriptor objects.~%"
msgstr ""

#: src/code/room.lisp
msgid ""
"Print a breakdown by instance type of all the instances allocated in\n"
"  Space.  If TOP-N is true, print only information for the the TOP-N types "
"with\n"
"  largest usage."
msgstr ""

#: src/code/room.lisp
msgid "~2&~@[Top ~D ~]~(~A~) instance types:~%"
msgstr ""

#: src/code/room.lisp
msgid "  ~32A: ~7:D bytes, ~5D object.~%"
msgid_plural "  ~32A: ~7:D bytes, ~5D objects.~%"
msgstr[0] ""

#: src/code/room.lisp
msgid "  Other types: ~:D bytes, ~D: object~:P.~%"
msgid_plural "  Other types: ~:D bytes, ~D: object~:P.~%"
msgstr[0] ""

#: src/code/room.lisp
msgid "  ~:(~A~) instance total: ~:D bytes, ~:D object.~%"
msgid_plural "  ~:(~A~) instance total: ~:D bytes, ~:D objects.~%"
msgstr[0] ""

#: src/code/room.lisp
msgid "In ~A space:~%"
msgstr ""

#: src/code/room.lisp
msgid "~D bytes at #x~X~%"
msgstr ""

#: src/code/room.lisp
msgid "No source for ~S"
msgstr ""

#: src/code/room.lisp
msgid "~%Package ~A: ~32T~9:D bytes, ~9:D object.~%"
msgid_plural "~%Package ~A: ~32T~9:D bytes, ~9:D objects.~%"
msgstr[0] ""

#: src/code/room.lisp
msgid "~30@A: ~9:D bytes, ~9:D object.~%"
msgid_plural "~30@A: ~9:D bytes, ~9:D objects.~%"
msgstr[0] ""

#: src/code/room.lisp
msgid ""
"Given a hashtable, print a histogram of the contents.  Function should give\n"
"  the value to plot when applied to the hashtable values."
msgstr ""

#: src/code/room.lisp
msgid ""
"Report the Top-N entries in the hashtable Table, when sorted by Function\n"
"  applied to the hash value.  If Top-N is NIL, report all entries."
msgstr ""

#: src/code/room.lisp
msgid "~8:D: Other~%"
msgstr ""

#: src/code/room.lisp
msgid "~8:D: Total~%"
msgstr ""

#: src/code/room.lisp
msgid ""
"Return a hashtable mapping each function in for which a call appears in\n"
"  Space to the number of times such a call appears."
msgstr ""

#: src/code/room.lisp
msgid ""
"Return a hashtable translating code objects to function constant counts for\n"
"  all code objects in Space with more than Above function constants."
msgstr ""

#: src/code/gc.lisp
msgid "Oh no.  The current dynamic space is missing!"
msgstr ""

#: src/code/gc.lisp
msgid "Dynamic Space Usage:    ~13:D bytes (out of ~4:D MB).~%"
msgstr ""

#: src/code/gc.lisp
msgid "Read-Only Space Usage:  ~13:D bytes (out of ~4:D MB).~%"
msgstr ""

#: src/code/gc.lisp
msgid "Static Space Usage:     ~13:D bytes (out of ~4:D MB).~%"
msgstr ""

#: src/code/gc.lisp
msgid "Control Stack Usage:    ~13:D bytes (out of ~4:D MB).~%"
msgstr ""

#: src/code/gc.lisp
msgid "Binding Stack Usage:    ~13:D bytes (out of ~4:D MB).~%"
msgstr ""

#: src/code/gc.lisp
msgid "The current dynamic space is ~D.~%"
msgstr ""

#: src/code/gc.lisp
msgid "Garbage collection is currently ~:[enabled~;DISABLED~].~%"
msgstr ""

#: src/code/gc.lisp
msgid ""
"Prints to *STANDARD-OUTPUT* information about the state of internal\n"
"  storage and its management.  The optional argument controls the\n"
"  verbosity of ROOM.  If it is T, ROOM prints out a maximal amount of\n"
"  information.  If it is NIL, ROOM prints out a minimal amount of\n"
"  information.  If it is :DEFAULT or it is not supplied, ROOM prints out\n"
"  an intermediate amount of information.  See also VM:MEMORY-USAGE and\n"
"  VM:INSTANCE-USAGE for finer report control."
msgstr ""

#: src/code/gc.lisp
msgid ""
"No way man!  The optional argument to ROOM must be T, NIL, ~\n"
"		 or :DEFAULT.~%What do you think you are doing?"
msgstr ""

#: src/code/gc.lisp
msgid "resetting GC counters"
msgstr ""

#: src/code/gc.lisp
msgid ""
"Returns the number of bytes consed since the first time this function\n"
"  was called.  The first time it is called, it returns zero."
msgstr ""

#: src/code/gc.lisp
msgid ""
"This number specifies the minimum number of bytes of dynamic space\n"
"   that must be consed before the next gc will occur."
msgstr ""

#: src/code/gc.lisp
msgid ""
"The total CPU time spend doing garbage collection (as reported by\n"
"   GET-INTERNAL-RUN-TIME.)"
msgstr ""

#: src/code/gc.lisp
msgid ""
"A list of functions that are called before garbage collection occurs.\n"
"  The functions should take no arguments."
msgstr ""

#: src/code/gc.lisp
msgid ""
"A list of functions that are called after garbage collection occurs.\n"
"  The functions should take no arguments."
msgstr ""

#: src/code/gc.lisp
msgid ""
"Should be bound to a function or NIL.  If it is a function, this\n"
"  function should take one argument, the current amount of dynamic\n"
"  usage.  The function should return NIL if garbage collection should\n"
"  continue and non-NIL if it should be inhibited.  Use with caution."
msgstr ""

#: src/code/gc.lisp
msgid ""
"When non-NIL, causes the functions bound to *GC-NOTIFY-BEFORE* and\n"
"  *GC-NOTIFY-AFTER* to be called before and after a garbage collection\n"
"  occurs respectively.  If :BEEP, causes the default notify functions to "
"beep\n"
"  annoyingly."
msgstr ""

#: src/code/gc.lisp
msgid ""
"~&; [GC threshold exceeded with ~:D bytes in use.  ~\n"
"             Commencing GC.]~%"
msgstr ""

#: src/code/gc.lisp
msgid ""
"This function bound to this variable is invoked before GC'ing (unless\n"
"  *GC-VERBOSE* is NIL) with the current amount of dynamic usage (in\n"
"  bytes).  It should notify the user that the system is going to GC."
msgstr ""

#: src/code/gc.lisp
msgid "~&; [GC completed with ~:D bytes retained and ~:D bytes freed.]~%"
msgstr ""

#: src/code/gc.lisp
msgid "~&; [GC will next occur when at least ~:D bytes are in use.]~%"
msgstr ""

#: src/code/gc.lisp
msgid ""
"The function bound to this variable is invoked after GC'ing (unless\n"
"  *GC-VERBOSE* is NIL) with the amount of dynamic usage (in bytes) now\n"
"  free, the number of bytes freed by the GC, and the new GC trigger\n"
"  threshold.  The function should notify the user that the system has\n"
"  finished GC'ing."
msgstr ""

#: src/code/gc.lisp
msgid ""
"The value of *BYTES-CONSED-BETWEEN-GCS*, ~S, is not an ~\n"
"	       integer.  Resetting it to ~D."
msgstr ""

#: src/code/gc.lisp
msgid "(FUNCALL ~S~{ ~S~}) lost:~%~A"
msgstr ""

#: src/code/gc.lisp
msgid ""
"Initiates a garbage collection.  The optional argument, VERBOSE-P,\n"
"  which defaults to the value of the variable *GC-VERBOSE* controls\n"
"  whether or not GC statistics are printed."
msgstr ""

#: src/code/gc.lisp
msgid ""
"Initiates a garbage collection.  The keyword :VERBOSE, which\n"
"   defaults to the value of the variable *GC-VERBOSE* controls whether or\n"
"   not GC statistics are printed. The keyword :GEN defaults to 0, and\n"
"   controls the number of generations to garbage collect."
msgstr ""

#: src/code/gc.lisp
msgid ""
"Return the amount of memory that will be allocated before the next garbage\n"
"   collection is initiated.  This can be set with SETF."
msgstr ""

#: src/code/gc.lisp
msgid "Enables the garbage collector."
msgstr ""

#: src/code/gc.lisp
msgid "Disables the garbage collector."
msgstr ""

#: src/code/gc.lisp
msgid ""
"Return some GC statistics for the specified GENERATION.  The\n"
"  statistics are the number of bytes allocated in this generation; the\n"
"  gc-trigger; the number of bytes consed between GCs; the number of\n"
"  GCs that have occurred; the trigger age; the cumulative number of\n"
"  bytes allocated in this generation; and the average age of this\n"
"  generation.  See the gencgc source code for more info."
msgstr ""

#: src/code/purify.lisp
msgid ""
"This function optimizes garbage collection by moving all currently live\n"
"   objects into non-collected storage.  ROOT-STRUCTURES is an optional list "
"of\n"
"   objects which should be copied first to maximize locality.\n"
"\n"
"   DEFSTRUCT structures defined with the (:PURE T) option are moved into\n"
"   read-only storage, further reducing GC cost.  List and vector slots of "
"pure\n"
"   structures are also moved into read-only storage.\n"
"\n"
"   ENVIRONMENT-NAME is gratuitous documentation for compacted version of "
"the\n"
"   current global environment (as seen in C::*INFO-ENVIRONMENT*.)  If NIL "
"is\n"
"   supplied, then environment compaction is inhibited."
msgstr ""

#: src/code/purify.lisp
msgid "[Doing purification: "
msgstr ""

#: src/code/purify.lisp
msgid "Done.]"
msgstr ""

#: src/code/scavhook.lisp
msgid "Returns T if OBJECT is a scavenger-hook, and NIL if not."
msgstr ""

#: src/code/scavhook.lisp
msgid ""
"Create a new scavenger-hook with the specified VALUE and FUNCTION.  For\n"
"   as long as the scavenger-hook is alive, the scavenger in the garbage\n"
"   collector will note whenever VALUE is moved, and arrange for FUNCTION\n"
"   to be funcalled."
msgstr ""

#: src/code/scavhook.lisp
msgid "Returns the VALUE being monitored by SCAVHOOK.  Can be setf."
msgstr ""

#: src/code/scavhook.lisp
msgid ""
"Returns the FUNCTION invoked when the monitored value is moved.  Can be\n"
"   setf."
msgstr ""

#: src/code/save.lisp
msgid ""
"This is a list of functions which are called before creating a saved core\n"
"  image.  These functions are executed in the child process which has no "
"ports,\n"
"  so they cannot do anything that tries to talk to the outside world."
msgstr ""

#: src/code/save.lisp
msgid ""
"This is a list of functions which are called when a saved core image starts\n"
"  up.  The system itself should be initialized at this point, but applicatio"
"ns\n"
"  might not be."
msgstr ""

#: src/code/save.lisp
msgid ""
"An alist mapping each environment variable (as a keyword) to its\n"
"  value."
msgstr ""

#: src/code/save.lisp
msgid "Non-NIL if environment-init has been called"
msgstr ""

#: src/code/save.lisp
msgid ""
"This is true if and only if the lisp was started with the -edit switch."
msgstr ""

#: src/code/save.lisp
msgid ""
"Saves a CMU Common Lisp core image in the file of the specified name.  The\n"
"  following keywords are defined:\n"
"  \n"
"  :purify\n"
"      If true (the default), do a purifying GC which moves all dynamically\n"
"  allocated objects into static space so that they stay pure.  This takes\n"
"  somewhat longer than the normal GC which is otherwise done, but GC's will\n"
"  be done less often and take less time in the resulting core file.  See\n"
"  EXT:PURIFY.\n"
"\n"
"  :root-structures\n"
"      This should be a list of the main entry points in any newly loaded\n"
"  systems.  This need not be supplied, but locality and/or GC performance\n"
"  will be better if they are.  Meaningless if :purify is NIL.  See EXT:PURIF"
"Y.\n"
"\n"
"  :environment-name\n"
"      Also passed to EXT:PURIFY when :PURIFY is T.  Rarely used.\n"
"  \n"
"  :init-function\n"
"      This is the function that starts running when the created core file "
"is\n"
"  resumed.  The default function simply invokes the top level\n"
"  read-eval-print loop.  If the function returns the lisp will exit.\n"
"  \n"
"  :load-init-file\n"
"      If true, then look for an init file when the core file is resumed.\n"
"  Look for home:init first and then home:.cmucl-init.  No error if\n"
"  there is no init file.\n"
"\n"
"  :site-init\n"
"      If true, then the name of the site init file to load.  The default is\n"
"  library:site-init.  No error if this does not exist.\n"
"\n"
"  :print-herald\n"
"      If true (the default), print out the lisp system herald when "
"starting.\n"
"\n"
"  :process-command-line\n"
"      If true (the default), process command-line switches via the normal\n"
"  mechanisms, otherwise ignore all switches (except those processed by\n"
"  the C startup code).  In either case, the command line switches are\n"
"  saved in *COMMAND-LINE-STRINGS* and\n"
"  *COMMAND-LINE-APPLICATION-ARGUMENTS*.\n"
"\n"
"  :executable\n"
"      If nil (the default), save-lisp will save using the traditional\n"
"   core-file format.  If true, save-lisp will create an executable\n"
"   file that contains the lisp image built in. \n"
"   (Not all architectures support this yet.)\n"
"\n"
"  :batch-mode\n"
"      If nil (the default), then the presence of the -batch command-line\n"
"  switch will invoke batch-mode processing.  If true, the produced core\n"
"  will always be in batch-mode, regardless of any command-line switches.\n"
"\n"
"  :quiet\n"
"     If non-NIL, loading, compiling, and GC messages are suppressed.\n"
"     This is equivalent to setting *load-verbose*, *compile-verbose*,\n"
"     *compile-print*, *compile-progress*, *require-verbose*, and\n"
"     *gc-verbose* all to NIL.  If NIL (the default), the default\n"
"     values of these variables are used."
msgstr ""

#: src/code/save.lisp
msgid "Directory ~S does not exist"
msgstr ""

#: src/code/save.lisp
msgid "Skip remaining initializations."
msgstr ""

#: src/code/save.lisp
msgid "Error in batch processing:~%~A~%"
msgstr ""

#: src/code/save.lisp
msgid ""
"Determines what PRINT-HERALD prints (the system startup banner.)  This is a\n"
"   database which can be augmented by each loaded system.  The format is a\n"
"   property list which maps from subsystem names to the banner information "
"for\n"
"   that system.  This list can be manipulated with GETF -- entries are "
"printed\n"
"   in, reverse order, so the newest entry is printed last.  Usually the "
"system\n"
"   feature keyword is used as the system name.  A given banner is a list of\n"
"   strings and functions (or function names).  Strings are printed, and\n"
"   functions are called with an output stream argument."
msgstr ""

#: src/code/save.lisp
msgid ", running on "
msgstr ""

#: src/code/save.lisp
msgid "With core: "
msgstr ""

#: src/code/save.lisp
msgid "Dumped on: "
msgstr ""

#: src/code/save.lisp
msgid " on "
msgstr ""

#: src/code/save.lisp
msgid "See <http://www.cmucl.org/> for support information."
msgstr ""

#: src/code/save.lisp
msgid "Loaded subsystems:"
msgstr ""

#: src/code/save.lisp
msgid "    Unicode "
msgstr ""

#: src/code/save.lisp
msgid "with Unicode version "
msgstr ""

#: src/code/save.lisp
msgid ""
"Print some descriptive information about the Lisp system version and\n"
"   configuration."
msgstr ""

#: src/code/save.lisp
msgid "Unrecognized *HERALD-ITEMS* entry: ~S."
msgstr ""

#: src/code/save.lisp
msgid "Change *PACKAGE* to the USER package and try again."
msgstr ""

#: src/code/stream.lisp
msgid "Terminal I/O stream."
msgstr ""

#: src/code/stream.lisp
msgid "Default input stream."
msgstr ""

#: src/code/stream.lisp
msgid "Default output stream."
msgstr ""

#: src/code/stream.lisp
msgid "Error output stream."
msgstr ""

#: src/code/stream.lisp
msgid "Query I/O stream."
msgstr ""

#: src/code/stream.lisp
msgid "Trace output stream."
msgstr ""

#: src/code/stream.lisp
msgid "Interactive debugging stream."
msgstr ""

#: src/code/stream.lisp
msgid "~S is not an input stream."
msgstr ""

#: src/code/stream.lisp
msgid "~S is not an output stream."
msgstr ""

#: src/code/stream.lisp
msgid "~S is not a character input stream."
msgstr ""

#: src/code/stream.lisp
msgid "~S is not a character output stream."
msgstr ""

#: src/code/stream.lisp
msgid "~S is not a binary input stream."
msgstr ""

#: src/code/stream.lisp
msgid ""
"~S is not a binary input stream ~\n"
"                          or does not support multi-byte read operations."
msgstr ""

#: src/code/stream.lisp
msgid "~S is not a binary output stream."
msgstr ""

#: src/code/stream.lisp
msgid "~S is closed."
msgstr ""

#: src/code/stream.lisp
msgid "~S is an unsupported Gray stream."
msgstr ""

#: src/pcl/gray-streams.lisp src/code/stream.lisp
msgid "Returns non-nil if the given Stream can perform input operations."
msgstr ""

#: src/pcl/gray-streams.lisp src/code/stream.lisp
msgid "Returns non-nil if the given Stream can perform output operations."
msgstr ""

#: src/code/stream.lisp
msgid "Return true if Stream is not closed."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Returns a type specifier for the kind of object returned by the Stream."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Return true if Stream does I/O on a terminal or other interactive device."
msgstr ""

#: src/code/stream.lisp
msgid "Can't set interactive flag on ~S."
msgstr ""

#: src/code/stream.lisp
msgid "Returns the external format used by the given Stream."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Closes the given Stream.  No more I/O may be performed, but inquiries\n"
"  may still be made.  If :Abort is non-nil, an attempt is made to clean\n"
"  up the side effects of having created the stream."
msgstr ""

#: src/code/stream.lisp
msgid ""
"With one argument returns the current position within the file\n"
"   File-Stream is open to.  If the second argument is supplied, then\n"
"   this becomes the new file position.  The second argument may also\n"
"   be :start or :end for the start and end of the file, respectively."
msgstr ""

#: src/code/stream.lisp
msgid ""
"This function returns the length of the file that File-Stream is open to."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Returns a line of text read from the Stream as a string, discarding the\n"
"  newline character."
msgstr ""

#: src/code/stream.lisp
msgid "Inputs a character from Stream and returns it."
msgstr ""

#: src/code/stream.lisp
msgid "Puts the Character back on the front of the input Stream."
msgstr ""

#: src/code/stream.lisp
msgid "Nothing to unread."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Peeks at the next character in the input Stream.  See manual for details."
msgstr ""

#: src/code/stream.lisp
msgid "~@<bad PEEK-TYPE=~S, ~_expected ~S~:>"
msgstr ""

#: src/code/stream.lisp
msgid "Impossible case reached in PEEK-CHAR"
msgstr ""

#: src/code/stream.lisp
msgid "Returns T if a character is available on the given Stream."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Returns the next character from the Stream if one is available, or nil."
msgstr ""

#: src/code/stream.lisp
msgid "Clears any buffered input associated with the Stream."
msgstr ""

#: src/code/stream.lisp
msgid "Returns the next byte of the Stream."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Reads Numbytes bytes into the Buffer starting at Start, returning the "
"number\n"
"   of bytes read.\n"
"   -- If EOF-ERROR-P is true, an END-OF-FILE condition is signalled if\n"
"      end-of-file is encountered before Count bytes have been read.\n"
"   -- If EOF-ERROR-P is false, READ-N-BYTES reads as much data as is "
"currently\n"
"      available (up to count bytes).  On pipes or similar devices, this\n"
"      function returns as soon as any data is available, even if the amount\n"
"      read is less than Count and eof has not been hit."
msgstr ""

#: src/code/stream.lisp
msgid "Outputs the Character to the Stream."
msgstr ""

#: src/code/stream.lisp
msgid "Outputs a new line to the Stream."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Outputs a new line to the Stream if it is not positioned at the beginning "
"of\n"
"   a line.  Returns T if it output a new line, nil otherwise."
msgstr ""

#: src/code/stream.lisp
msgid "Outputs the String to the given Stream."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Outputs the String to the given Stream, followed by a newline character."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Returns the number of characters on the current line of output of the given\n"
"  Stream, or Nil if that information is not availible."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Returns the number of characters that will fit on a line of output on the\n"
"  given Stream, or Nil if that information is not available."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Attempts to ensure that all output sent to the Stream has reached its\n"
"   destination, and only then returns."
msgstr ""

#: src/code/stream.lisp
msgid "Attempts to force any buffered output to be sent."
msgstr ""

#: src/code/stream.lisp
msgid "Clears the given output Stream."
msgstr ""

#: src/code/stream.lisp
msgid "Outputs the Integer to the binary Stream."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Returns an output stream which sends its output to all of the given\n"
"streams."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Returns a stream which performs its operations on the stream which is the\n"
"   value of the dynamic variable named by Symbol."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Returns a bidirectional stream which gets its input from Input-Stream and\n"
"   sends its output to Output-Stream."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Returns a stream which takes its input from each of the Streams in turn,\n"
"   going on to the next at EOF."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Returns an echo stream that takes input from Input-stream and sends\n"
"output to Output-stream"
msgstr ""

#: src/code/stream.lisp
msgid ""
"Returns a bidirectional stream which gets its input from Input-Stream and\n"
"   sends its output to Output-Stream.  In addition, all input is echoed to\n"
"   the output stream"
msgstr ""

#: src/code/stream.lisp
msgid ""
"Returns an input stream which will supply the characters of String between\n"
"  Start and End in order."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Returns an Output stream which will accumulate all output given to it for\n"
"   the benefit of the function Get-Output-Stream-String."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Returns a string of all the characters sent to a stream made by\n"
"   Make-String-Output-Stream since the last call to this function."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Dumps the characters buffer up in the In-Stream to the Out-Stream as\n"
"  Get-Output-Stream-String would return them."
msgstr ""

#: src/code/stream.lisp
msgid "Returns an output stream which indents its output by some amount."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Returns a stream that sends all output to the stream TARGET, but modifies\n"
"   the case of letters, depending on KIND, which should be one of:\n"
"     :upcase - convert to upper case.\n"
"     :downcase - convert to lower case.\n"
"     :capitalize - convert the first letter of words to upper case and the\n"
"        rest of the word to lower case.\n"
"     :capitalize-first - convert the first letter of the first word to "
"upper\n"
"        case and everything else to lower case."
msgstr ""

#: src/code/stream.lisp
msgid ""
"This takes a stream and waits for text or a command to appear on it.  If\n"
"   text appears before a command, this returns nil, and otherwise it "
"returns\n"
"   a command."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Destructively modify SEQ by reading elements from STREAM.\n"
"\n"
"  Seq is bounded by Start and End. Seq is destructively modified by\n"
"  copying successive elements into it from Stream. If the end of file\n"
"  for Stream is reached before copying all elements of the subsequence,\n"
"  then the extra elements near the end of sequence are not updated.\n"
"\n"
"  Argument(s):\n"
"  SEQ:	    a proper SEQUENCE\n"
"  STREAM:   an input STREAM\n"
"  START:    a bounding index designator of type '(INTEGER 0 *)' (default 0)\n"
"  END:      a bounding index designator which be NIL or an INTEGER of\n"
"	    type '(INTEGER 0 *)' (default NIL)\n"
"\n"
"  Value(s):\n"
"  POSITION: an INTEGER greater than or equal to zero, and less than or\n"
"	    equal to the length of the SEQ. POSITION is the index of\n"
"	    the first element of SEQ that was not updated, which might be\n"
"	    less than END because the end of file was reached."
msgstr ""

#: src/code/stream.lisp
msgid "The stream is not open."
msgstr ""

#: src/code/stream.lisp
msgid "The stream is not open for input."
msgstr ""

#: src/code/stream.lisp
msgid "Trying to read characters from a binary stream."
msgstr ""

#: src/code/stream.lisp
msgid ""
"Writes the elements of the Seq bounded by Start and End to Stream.\n"
"\n"
"  Argument(s):\n"
"  SEQ:     a proper SEQUENCE\n"
"  STREAM:  an output STREAM\n"
"  START:   a bounding index designator of type '(INTEGER 0 *)' (default 0)\n"
"  END:     a bounding index designator which be NIL or an INTEGER of\n"
"           type '(INTEGER 0 *)' (default NIL)\n"
"\n"
"  Value(s):\n"
"  SEQ:	a proper SEQUENCE\n"
""
msgstr ""

#: src/code/stream.lisp
msgid "The stream is not open for output."
msgstr ""

#: src/code/stream.lisp
msgid "Trying to output an element of unproper type to a stream."
msgstr ""

#: src/code/stream.lisp
msgid "Trying to output a string to a binary stream."
msgstr ""

#: src/code/stream.lisp
msgid "Trying to output binary data to a text stream."
msgstr ""

#: src/code/print.lisp
msgid ""
"If true, all objects will printed readably.  If readably printing is\n"
"  impossible, an error will be signalled.  This overrides the value of\n"
"  *PRINT-ESCAPE*."
msgstr ""

#: src/code/print.lisp
msgid "Flag which indicates that slashification is on.  See the manual"
msgstr ""

#: src/code/print.lisp
msgid "Flag which indicates that pretty printing is to be used"
msgstr ""

#: src/code/print.lisp
msgid "The output base for integers and rationals."
msgstr ""

#: src/code/print.lisp
msgid "This flag requests to verify base when printing rationals."
msgstr ""

#: src/code/print.lisp
msgid "How many levels deep to print.  Unlimited if null."
msgstr ""

#: src/code/print.lisp
msgid "How many elements to print on each level.  Unlimited if null."
msgstr ""

#: src/code/print.lisp
msgid "Whether to worry about circular list structures. See the manual."
msgstr ""

#: src/code/print.lisp
msgid "What kind of case the printer should use by default"
msgstr ""

#: src/code/print.lisp
msgid "Whether the array should print it's guts out"
msgstr ""

#: src/code/print.lisp
msgid ""
"If true, symbols with no home package are printed with a #: prefix.\n"
"  If false, no prefix is printed."
msgstr ""

#: src/code/print.lisp
msgid "The maximum number of lines to print.  If NIL, unlimited."
msgstr ""

#: src/code/print.lisp
msgid ""
"The position of the right margin in ems.  If NIL, try to determine this\n"
"   from the stream in use."
msgstr ""

#: src/code/print.lisp
msgid ""
"If the remaining space between the current column and the right margin\n"
"   is less than this, then print using ``miser-style'' output.  Miser\n"
"   style conditional newlines are turned on, and all indentations are\n"
"   turned off.  If NIL, never use miser mode."
msgstr ""

#: src/code/print.lisp
msgid ""
"The pprint-dispatch-table that controls how to pretty print objects.  See\n"
"   COPY-PPRINT-DISPATH, PPRINT-DISPATCH, and SET-PPRINT-DISPATCH."
msgstr ""

#: src/code/print.lisp
msgid ""
"Bind the reader and printer control variables to values that enable READ\n"
"   to reliably read the results of PRINT.  These values are:\n"
"       *PACKAGE*			The COMMON-LISP-USER package\n"
"       *PRINT-ARRAY*			T\n"
"       *PRINT-BASE*			10\n"
"       *PRINT-CASE*			:UPCASE\n"
"       *PRINT-CIRCLE*			NIL\n"
"       *PRINT-ESCAPE*			T\n"
"       *PRINT-GENSYM*			T\n"
"       *PRINT-LENGTH*			NIL\n"
"       *PRINT-LEVEL*			NIL\n"
"       *PRINT-LINES*			NIL\n"
"       *PRINT-MISER-WIDTH*		NIL\n"
"       *PRINT-PPRINT-DISPATCH*          The standard pprint dispatch table\n"
"       *PRINT-PRETTY*			NIL\n"
"       *PRINT-RADIX*			NIL\n"
"       *PRINT-READABLY*			T\n"
"       *PRINT-RIGHT-MARGIN*		NIL\n"
"       *READ-BASE*			10\n"
"       *READ-DEFAULT-FLOAT-FORMAT* 	SINGLE-FLOAT\n"
"       *READ-EVAL*			T\n"
"       *READ-SUPPRESS*			NIL\n"
"       *READTABLE*			the standard readtable."
msgstr ""

#: src/code/print.lisp
msgid ""
"Outputs OBJECT to the specified stream, defaulting to *standard-output*"
msgstr ""

#: src/code/print.lisp
msgid ""
"Outputs a mostly READable printed representation of OBJECT on the specified\n"
"  stream."
msgstr ""

#: src/code/print.lisp
msgid ""
"Outputs an asthetic but not READable printed representation of OBJECT on "
"the\n"
"  specified stream."
msgstr ""

#: src/code/print.lisp
msgid ""
"Outputs a terpri, the mostly READable printed represenation of OBJECT, and \n"
"  space to the stream."
msgstr ""

#: src/code/print.lisp
msgid "Prettily outputs the Object preceded by a newline."
msgstr ""

#: src/code/print.lisp
msgid "Returns the printed representation of OBJECT as a string."
msgstr ""

#: src/code/print.lisp
msgid ""
"Returns the printed representation of OBJECT as a string with \n"
"   slashification on."
msgstr ""

#: src/code/print.lisp
msgid ""
"Returns the printed representation of OBJECT as a string with\n"
"  slashification off and readability off."
msgstr ""

#: src/compiler/byte-comp.lisp src/compiler/dyncount.lisp
#: src/compiler/knownfun.lisp src/compiler/new-assem.lisp
#: src/compiler/meta-vmdef.lisp src/compiler/vop.lisp src/compiler/node.lisp
#: src/compiler/sset.lisp src/compiler/backend.lisp src/code/print.lisp
msgid "~S cannot be printed readably."
msgstr ""

#: src/code/print.lisp
msgid "Determines whether or not the character is considered whitespace."
msgstr ""

#: src/code/print.lisp
msgid ""
"Check to see if OBJECT is a circular reference, and return something "
"non-NIL\n"
"   if it is.  If ASSIGN is T, then the number to use in the #n= and #n# "
"noise\n"
"   is assigned at this time.  Note: CHECK-FOR-CIRCULARITY must be called\n"
"   *EXACTLY* once with ASSIGN T, or the circularity detection noise will "
"get\n"
"   confused about when to use #n= and when to use #n#.  If this returns\n"
"   non-NIL when ASSIGN is T, then you must call HANDLE-CIRCULARITY on it."
msgstr ""

#: src/code/print.lisp
msgid ""
"Handle the results of CHECK-FOR-CIRCULARITY.  If this returns T then\n"
"   you should go ahead and print the object.  If it returns NIL, then\n"
"   you should blow it off."
msgstr ""

#: src/code/print.lisp
msgid ""
"Attempt to use CHECK-FOR-CIRCULARITY when circularity ~\n"
"	       checking has not been initiated."
msgstr ""

#: src/code/print.lisp
msgid ""
"The current level we are printing at, to be compared against *PRINT-LEVEL*.\n"
"   See the macro DESCEND-INTO for a handy interface to depth abbreviation."
msgstr ""

#: src/code/print.lisp
msgid ""
"Automatically handle *print-level* abbreviation.  If we are too deep, then\n"
"   a # is printed to STREAM and BODY is ignored."
msgstr ""

#: src/code/print.lisp
msgid ""
"Punt if INDEX is equal or larger then *PRINT-LENGTH* (and *PRINT-READABLY*\n"
"   is NIL) by outputting \"...\" and returning from the block named NIL."
msgstr ""

#: src/code/print.lisp
msgid ""
"The current pretty printer.  Should be either a function that takes two\n"
"   arguments (the object and the stream) or NIL to indicate that there is\n"
"   no pretty printer installed."
msgstr ""

#: src/code/print.lisp
msgid "Output OBJECT to STREAM observing all printer control variables."
msgstr ""

#: src/code/print.lisp
msgid ""
"Output OBJECT to STREAM observing all printer control variables except\n"
"   for *PRINT-PRETTY*.  Note: if *PRINT-PRETTY* is non-NIL, then the pretty\n"
"   printer will be used for any components of OBJECT, just not for OBJECT\n"
"   itself."
msgstr ""

#: src/code/print.lisp
msgid "Invalid *PRINT-CASE* value: ~S"
msgstr ""

#: src/code/print.lisp
msgid "Invalid READTABLE-CASE value: ~S"
msgstr ""

#: src/code/print.lisp
msgid ""
"Outputs the printed representation of any array in either the #< or #A\n"
"   form."
msgstr ""

#: src/code/print.lisp
msgid "Obsolete Instance"
msgstr ""

#: src/code/print.lisp
msgid "Unprintable Instance"
msgstr ""

#: src/code/print.lisp
msgid "~A is not a reasonable value for *Print-Base*."
msgstr ""

#: src/code/print.lisp
msgid ""
"Compute a list of pairs (2^i . r^{2^i}), stopping with the largest r^{2^i}\n"
"greater than n."
msgstr ""

#: src/code/print.lisp
msgid "overflow in digit-to-char"
msgstr ""

#: src/code/print.lisp
msgid "Convert digit into a character representation."
msgstr ""

#: src/code/print.lisp
msgid ""
"Print a fixnum N to stream S, maybe with leading zeros.  This isn't\n"
"ever-so efficient, but we probably don't need to care."
msgstr ""

#: src/code/print.lisp
msgid ""
"Use the power list (see power-list) PL to split N roughly in half; then\n"
"print the left and right halves using (cdr PL).  Make sure we count the\n"
"leading zeroes correctly."
msgstr ""

#: src/code/print.lisp
msgid ""
"Primary fast bignum-printing interface.  Prints integer N to stream S in\n"
"radix-R.  If you have a power-list then pass it in as PL."
msgstr ""

#: src/code/print.lisp
msgid ""
"Minimum power of 10 that allows the float printer to use free format,\n"
"   instead of exponential format.  See section 22.1.3.1.3: Printing Floats\n"
"   in the ANSI CL standard."
msgstr ""

#: src/code/print.lisp
msgid ""
"Maximum power of 10 that allows the float printer to use free format,\n"
"   instead of exponential format.  See section 22.1.3.1.3: Printing Floats\n"
"   in the ANSI CL standard."
msgstr ""

#: src/code/print.lisp
msgid "Convert a DD number to a lisp rational"
msgstr ""

#: src/code/print.lisp
msgid "Print out a double-double to a string"
msgstr ""

#: src/code/print.lisp
msgid "Weak Pointer: "
msgstr ""

#: src/code/print.lisp
msgid "Broken Weak Pointer"
msgstr ""

#: src/code/print.lisp
msgid "Bogus Code Object"
msgstr ""

#: src/code/print.lisp
msgid "Code Object"
msgstr ""

#: src/code/print.lisp
msgid "Return PC Object"
msgstr ""

#: src/code/print.lisp
msgid "FDEFINITION object for "
msgstr ""

#: src/code/print.lisp
msgid "Function "
msgstr ""

#: src/code/print.lisp
msgid "Interpreted Function ~S"
msgstr ""

#: src/code/print.lisp
msgid "Byte Compiled Function"
msgstr ""

#: src/code/print.lisp
msgid "Byte Compiled Closure"
msgstr ""

#: src/code/print.lisp
msgid "Closure Over "
msgstr ""

#: src/code/print.lisp
msgid "Unknown Function"
msgstr ""

#: src/code/print.lisp
msgid "Value Cell "
msgstr ""

#: src/code/print.lisp
msgid "Unknown Pointer Object, type="
msgstr ""

#: src/code/print.lisp
msgid "Unbound Marker"
msgstr ""

#: src/code/print.lisp
msgid "Unknown Immediate Object, lowtag="
msgstr ""

#: src/code/print.lisp
msgid ", type="
msgstr ""

#: src/code/print.lisp
msgid "Continue anyway"
msgstr ""

#: src/code/print.lisp
msgid "Cannot find ~S, so unicode support is not available"
msgstr ""

#: src/code/pprint.lisp
msgid ""
"Insert an annotation into the pretty-printing stream STREAM.\n"
"HANDLER is a function, and RECORD is an arbitrary datum.  The\n"
"pretty-printing stream conceptionally queues annotations in sequence\n"
"with the characters that are printed to the stream, until the stream\n"
"has decided on the concrete layout.  When the characters are forwarded\n"
"to the target stream, annotations are invoked at the right position.\n"
"An annotation is invoked by calling the function HANDLER with the\n"
"three arguments RECORD, TARGET-STREAM, and TRUNCATEP.  The argument\n"
"TRUNCATEP is true if the text surrounding the annotation is suppressed\n"
"due to line abbreviation (see *PRINT-LINES*).\n"
"If STREAM is not a pretty-printing stream, simply call HANDLER\n"
"with the arguments RECORD, STREAM and nil."
msgstr ""

#: src/code/pprint.lisp
msgid "Insert ANNOTATION into the queue of annotations in STREAM."
msgstr ""

#: src/code/pprint.lisp
msgid ""
"Insert all annotations in STREAM from the queue of pending\n"
"operations into the queue of annotations.  When END is non-nil, \n"
"stop before reaching the queued-op END."
msgstr ""

#: src/code/pprint.lisp
msgid ""
"Dequeue the next annotation from the queue of annotations of STREAM\n"
"and return it.  Return nil if there are no more annotations.  When\n"
":END-POSN is given and the next annotation has a posn greater than\n"
"this, also return nil."
msgstr ""

#: src/code/pprint.lisp
msgid ""
"Output the buffer of STREAM up to (excluding) the buffer index END.\n"
"When annotations are present, invoke them at the right positions."
msgstr ""

#: src/code/pprint.lisp
msgid ""
"Invoke all annotations in STREAM up to (including) the buffer index END."
msgstr ""

#: src/code/pprint.lisp
msgid "Output-partial-line called when nothing can be output."
msgstr ""

#: src/code/pprint.lisp
msgid ""
"Group some output into a logical block.  STREAM-SYMBOL should be either a\n"
"   stream, T (for *TERMINAL-IO*), or NIL (for *STANDARD-OUTPUT*).  The "
"printer\n"
"   control variable *PRINT-LEVEL* is automatically handled."
msgstr ""

#: src/code/pprint.lisp
msgid "Cannot specify both a prefix and a per-line-prefix."
msgstr ""

#: src/code/pprint.lisp
msgid ""
"Cause the closest enclosing use of PPRINT-LOGICAL-BLOCK to return\n"
"   if it's list argument is exhausted.  Can only be used inside\n"
"   PPRINT-LOGICAL-BLOCK, and only when the LIST argument to\n"
"   PPRINT-LOGICAL-BLOCK is supplied."
msgstr ""

#: src/code/pprint.lisp
msgid ""
"PPRINT-EXIT-IF-LIST-EXHAUSTED must be lexically inside ~\n"
"	  PPRINT-LOGICAL-BLOCK."
msgstr ""

#: src/code/pprint.lisp
msgid ""
"Return the next element from LIST argument to the closest enclosing\n"
"   use of PPRINT-LOGICAL-BLOCK, automatically handling *PRINT-LENGTH*\n"
"   and *PRINT-CIRCLE*.  Can only be used inside PPRINT-LOGICAL-BLOCK.\n"
"   If the LIST argument to PPRINT-LOGICAL-BLOCK was NIL, then nothing\n"
"   is poped, but the *PRINT-LENGTH* testing still happens."
msgstr ""

#: src/code/pprint.lisp
msgid "PPRINT-POP must be lexically inside PPRINT-LOGICAL-BLOCK."
msgstr ""

#: src/code/pprint.lisp
msgid ""
"Output a conditional newline to STREAM (which defaults to\n"
"   *STANDARD-OUTPUT*) if it is a pretty-printing stream, and do\n"
"   nothing if not.  KIND can be one of:\n"
"     :LINEAR - A line break is inserted if and only if the immediatly\n"
"        containing section cannot be printed on one line.\n"
"     :MISER - Same as LINEAR, but only if ``miser-style'' is in effect.\n"
"        (See *PRINT-MISER-WIDTH*.)\n"
"     :FILL - A line break is inserted if and only if either:\n"
"       (a) the following section cannot be printed on the end of the\n"
"           current line,\n"
"       (b) the preceding section was not printed on a single line, or\n"
"       (c) the immediately containing section cannot be printed on one\n"
"           line and miser-style is in effect.\n"
"     :MANDATORY - A line break is always inserted.\n"
"   When a line break is inserted by any type of conditional newline, any\n"
"   blanks that immediately precede the conditional newline are ommitted\n"
"   from the output and indentation is introduced at the beginning of the\n"
"   next line.  (See PPRINT-INDENT.)"
msgstr ""

#: src/code/pprint.lisp
msgid ""
"Specify the indentation to use in the current logical block if STREAM\n"
"   (which defaults to *STANDARD-OUTPUT*) is a pretty-printing stream\n"
"   and do nothing if not.  (See PPRINT-LOGICAL-BLOCK.)  N is the indention\n"
"   to use (in ems, the width of an ``m'') and RELATIVE-TO can be either:\n"
"     :BLOCK - Indent relative to the column the current logical block\n"
"        started on.\n"
"     :CURRENT - Indent relative to the current column.\n"
"   The new indention value does not take effect until the following line\n"
"   break.  The indention value is silently truncated to an integer."
msgstr ""

#: src/code/pprint.lisp
msgid ""
"If STREAM (which defaults to *STANDARD-OUTPUT*) is a pretty-printing\n"
"   stream, perform tabbing based on KIND, otherwise do nothing.  KIND can\n"
"   be one of:\n"
"     :LINE - Tab to column COLNUM.  If already past COLNUM tab to the next\n"
"       multiple of COLINC.\n"
"     :SECTION - Same as :LINE, but count from the start of the current\n"
"       section, not the start of the line.\n"
"     :LINE-RELATIVE - Output COLNUM spaces, then tab to the next multiple "
"of\n"
"       COLINC.\n"
"     :SECTION-RELATIVE - Same as :LINE-RELATIVE, but count from the start\n"
"       of the current section, not the start of the line."
msgstr ""

#: src/code/pprint.lisp
msgid ""
"Output LIST to STREAM putting :FILL conditional newlines between each\n"
"   element.  If COLON? is NIL (defaults to T), then no parens are printed\n"
"   around the output.  ATSIGN? is ignored (but allowed so that PPRINT-FILL\n"
"   can be used with the ~/.../ format directive."
msgstr ""

#: src/code/pprint.lisp
msgid ""
"Output LIST to STREAM putting :LINEAR conditional newlines between each\n"
"   element.  If COLON? is NIL (defaults to T), then no parens are printed\n"
"   around the output.  ATSIGN? is ignored (but allowed so that PPRINT-LINEAR"
"\n"
"   can be used with the ~/.../ format directive."
msgstr ""

#: src/code/pprint.lisp
msgid ""
"Output LIST to STREAM tabbing to the next column that is an even multiple\n"
"   of TABSIZE (which defaults to 16) between each element.  :FILL style\n"
"   conditional newlines are also output between each element.  If COLON? is\n"
"   NIL (defaults to T), then no parens are printed around the output.\n"
"   ATSIGN? is ignored (but allowed so that PPRINT-TABULAR can be used with\n"
"   the ~/.../ format directive."
msgstr ""

#: src/code/pprint.lisp
msgid "CONS PPRINT dispatch ignored w/o compiler loaded:~%  ~S"
msgstr ""

#: src/pcl/env.lisp src/pcl/methods.lisp src/pcl/std-class.lisp
#: src/pcl/defclass.lisp src/code/format.lisp src/code/pprint-loop.lisp
#: src/code/pprint.lisp
msgid "No more arguments."
msgstr ""

#: src/code/format.lisp
msgid "~:[~;Error in format: ~]~\n"
"	      ~?~@[~%  ~A~%  ~V@T^~]"
msgstr ""

#: src/code/format.lisp
msgid ""
"A justification directive cannot be in the same format string~%~\n"
"                         as ~~W, ~~I, ~~:T, or a logical-block directive."
msgstr ""

#: src/code/format.lisp
msgid "String ended before directive was found."
msgstr ""

#: src/code/format.lisp
msgid "Too many colons supplied."
msgstr ""

#: src/code/format.lisp
msgid "Too many at-signs supplied."
msgstr ""

#: src/code/format.lisp
msgid "No matching closing slash."
msgstr ""

#: src/code/format.lisp
msgid ""
"Provides various facilities for formatting output.\n"
"  CONTROL-STRING contains a string to be output, possibly with embedded\n"
"  directives, which are flagged with the escape character \"~\".  Directives\n"
"  generally expand into additional text to be output, usually consuming one\n"
"  or more of the FORMAT-ARGUMENTS in the process.  A few useful directives\n"
"  are:\n"
"        ~A or ~nA     Prints one argument as if by PRINC\n"
"        ~S or ~nS     Prints one argument as if by PRIN1\n"
"        ~D or ~nD     Prints one argument as a decimal integer\n"
"        ~%            Does a TERPRI\n"
"        ~&            Does a FRESH-LINE\n"
"\n"
"         where n is the width of the field in which the object is printed.\n"
"  \n"
"  DESTINATION controls where the result will go.  If DESTINATION is T, then\n"
"  the output is sent to the standard output stream.  If it is NIL, then the\n"
"  output is returned in a string as the value of the call.  Otherwise,\n"
"  DESTINATION must be a stream to which the output will be sent.\n"
"\n"
"  Example:   (FORMAT NIL \"The answer is ~D.\" 10) => \"The answer is 10.\"\n"
"\n"
"  FORMAT has many additional capabilities not described here.  Consult\n"
"  Section 22.3 (Formatted Output) of the ANSI Common Lisp standard for\n"
"  details."
msgstr ""

#: src/code/format.lisp
msgid "Unknown format directive."
msgstr ""

#: src/code/format.lisp
msgid "Unknown directive."
msgstr ""

#: src/code/format.lisp
msgid "Too many parameters, expected no more than ~D"
msgstr ""

#: src/code/format.lisp
msgid "Too many parameters, expected no more than 0"
msgstr ""

#: src/code/format.lisp
msgid "Table of ordinal ones-place digits in English"
msgstr ""

#: src/code/format.lisp
msgid "Table of ordinal tens-place digits in English"
msgstr ""

#: src/code/format.lisp
msgid "Number too large to print in old Roman numerals: ~:D"
msgstr ""

#: src/code/format.lisp
msgid "Number too large to print in Roman numerals: ~:D"
msgstr ""

#: src/code/format.lisp
msgid "No previous argument."
msgstr ""

#: src/code/format.lisp
msgid "Cannot specify the colon modifier with this directive."
msgstr ""

#: src/code/format.lisp
msgid "Cannot specify either colon or atsign for this directive."
msgstr ""

#: src/code/format.lisp
msgid "Cannot specify both colon and atsign for this directive."
msgstr ""

#: src/code/format.lisp
msgid "Cannot specify the at-sign modifier."
msgstr ""

#: src/code/format.lisp
msgid "Cannot specify both colon and at-sign."
msgstr ""

#: src/code/format.lisp
msgid "Index ~D out of bounds.  Should have been ~\n"
"				   between 0 and ~D."
msgstr ""

#: src/code/format.lisp
msgid ""
"Index ~D out of bounds.  Should have been ~\n"
"			       between 0 and ~D."
msgstr ""

#: src/code/format.lisp
msgid "Cannot specify the colon modifier."
msgstr ""

#: src/pcl/seal.lisp src/pcl/method-slot-access-optimization.lisp
#: src/pcl/low.lisp src/code/format.lisp
msgid "~A~%while processing indirect format string:"
msgstr ""

#: src/code/format.lisp
msgid "No corresponding close paren."
msgstr ""

#: src/code/format.lisp
msgid "No corresponding open paren."
msgstr ""

#: src/code/format.lisp
msgid "No corresponding close bracket."
msgstr ""

#: src/code/format.lisp
msgid "Cannot specify both the colon and at-sign modifiers."
msgstr ""

#: src/code/format.lisp
msgid "Can only specify one section"
msgstr ""

#: src/code/format.lisp
msgid "~~:; directive not effective in ~~:["
msgstr ""

#: src/code/format.lisp
msgid "Must specify exactly two sections."
msgstr ""

#: src/code/format.lisp
msgid "~~; not contained within either ~~[...~~] or ~~<...~~>."
msgstr ""

#: src/code/format.lisp
msgid "No corresponding open bracket."
msgstr ""

#: src/code/format.lisp
msgid "Attempt to use ~~:^ outside a ~~:{...~~} construct."
msgstr ""

#: src/code/format.lisp
msgid "No corresponding close brace."
msgstr ""

#: src/code/format.lisp
msgid "No corresponding open brace."
msgstr ""

#: src/code/format.lisp
msgid "~D illegal directive found inside justification block"
msgid_plural "~D illegal directives found inside justification block"
msgstr[0] ""

#: src/code/format.lisp
msgid "No parameters can be supplied with ~~<...~~:>."
msgstr ""

#: src/code/format.lisp
msgid ""
"Cannot include format directives inside the ~\n"
"			       ~:[suffix~;prefix~] segment of ~~<...~~:>"
msgstr ""

#: src/code/format.lisp
msgid "Too many segments for ~~<...~~:>."
msgstr ""

#: src/code/format.lisp
msgid "Malformed ~~/ directive."
msgstr ""

#: src/code/format.lisp
msgid "No package named ~S"
msgstr ""

#: src/code/package.lisp
msgid ""
"The list of packages to use by default of no :USE argument is supplied\n"
"   to MAKE-PACKAGE or other package creation forms."
msgstr ""

#: src/code/package.lisp
msgid "The ~A package, ~D/~D internal, ~D/~D external"
msgstr ""

#: src/code/package.lisp
msgid "The ~A package"
msgstr ""

#: src/code/package.lisp
msgid "deleted package"
msgstr ""

#: src/code/package.lisp
msgid "The current package."
msgstr ""

#: src/code/package.lisp
msgid "~&~@<Attempt to modify the locked package ~A, by ~3i~:_~?~:>"
msgstr ""

#: src/code/package.lisp
msgid "redefining function ~A"
msgstr ""

#: src/code/macros.lisp src/code/defstruct.lisp src/code/package.lisp
msgid "Ignore the lock and continue"
msgstr ""

#: src/code/package.lisp
msgid "Disable package's definition-lock, then continue"
msgstr ""

#: src/code/package.lisp
msgid "Disable all package locks, then continue"
msgstr ""

#: src/code/package.lisp
msgid "Bogus ~A name: ~S"
msgstr ""

#: src/code/package.lisp
msgid "Can't do anything to a deleted package: ~S"
msgstr ""

#: src/code/package.lisp
msgid ""
"Given PACKAGE-SPECIFIER, a package, symbol or string, return the\n"
"  parent package.  If there is not a parent, signal an error."
msgstr ""

#: src/code/package.lisp
msgid "The parent of ~a does not exist."
msgstr ""

#: src/code/package.lisp
msgid "There is no parent of ~a."
msgstr ""

#: src/code/package.lisp
msgid ""
"Given PACKAGE-SPECIFIER, a package, symbol or string, return all the\n"
"  packages which are in the hierarchy 'under' the given package.  If\n"
"  :recurse is nil, then only return the immediate children of the package."
msgstr ""

#: src/code/package.lisp
msgid "Find the package having the specified name."
msgstr ""

#: src/code/package.lisp
msgid "Make this package."
msgstr ""

#: src/code/package.lisp
msgid "#<Package-Hashtable: Size = ~D, Free = ~D, Deleted = ~D>"
msgstr ""

#: src/code/package.lisp
msgid ""
"DO-SYMBOLS (VAR [PACKAGE [RESULT-FORM]]) {DECLARATION}* {TAG | FORM}*\n"
"   Executes the FORMs at least once for each symbol accessible in the given\n"
"   PACKAGE with VAR bound to the current symbol."
msgstr ""

#: src/code/package.lisp
msgid ""
"DO-EXTERNAL-SYMBOLS (VAR [PACKAGE [RESULT-FORM]]) {DECL}* {TAG | FORM}*\n"
"   Executes the FORMs once for each external symbol in the given PACKAGE "
"with\n"
"   VAR bound to the current symbol."
msgstr ""

#: src/code/package.lisp
msgid ""
"DO-ALL-SYMBOLS (VAR [RESULT-FORM]) {DECLARATION}* {TAG | FORM}*\n"
"   Executes the FORMs once for each symbol in every package with VAR bound\n"
"   to the current symbol."
msgstr ""

#: src/code/package.lisp
msgid ""
"Within the lexical scope of the body forms, MNAME is defined via macrolet\n"
"   such that successive invocations of (mname) will return the symbols,\n"
"   one by one, from the packages in PACKAGE-LIST. SYMBOL-TYPES may be\n"
"   any of :inherited :external :internal."
msgstr ""

#: src/code/package.lisp
msgid ""
"Must supply at least one of :internal, ~\n"
"	                             :external, or :inherited."
msgstr ""

#: src/code/package.lisp
msgid ""
"~S is not one of :internal, :external, ~\n"
"		                       or :inherited."
msgstr ""

#: src/code/package.lisp
msgid ""
"Defines a new package called PACKAGE.  Each of OPTIONS should be one of the\n"
"   following:\n"
"     (:NICKNAMES {package-name}*)\n"
"     (:SIZE <integer>)\n"
"     (:SHADOW {symbol-name}*)\n"
"     (:SHADOWING-IMPORT-FROM <package-name> {symbol-name}*)\n"
"     (:USE {package-name}*)\n"
"     (:IMPORT-FROM <package-name> {symbol-name}*)\n"
"     (:INTERN {symbol-name}*)\n"
"     (:EXPORT {symbol-name}*)\n"
"     (:DOCUMENTATION doc-string)\n"
"   All options except :SIZE and :DOCUMENTATION can be used multiple times."
msgstr ""

#: src/code/package.lisp
msgid "Bogus DEFPACKAGE option: ~S"
msgstr ""

#: src/code/package.lisp
msgid "Can't specify :SIZE twice."
msgstr ""

#: src/code/package.lisp
msgid "Bogus :SIZE, must be a positive integer: ~S"
msgstr ""

#: src/code/package.lisp
msgid "Can't specify :DOCUMENTATION twice."
msgstr ""

#: src/code/package.lisp
msgid ""
"Parameters ~S and ~S must be disjoint ~\n"
"	                             but have common elements ~%   ~S"
msgstr ""

#: src/code/package.lisp
msgid "~A is a nick-name for the package ~A"
msgstr ""

#: src/code/package.lisp
msgid "~A also shadows the following symbols:~%  ~S"
msgstr ""

#: src/code/package.lisp
msgid "~A previously used the following packages:~%  ~S"
msgstr ""

#: src/code/package.lisp
msgid "~A also exports the following symbols:~%  ~S"
msgstr ""

#: src/code/package.lisp
msgid "~A does not contain a symbol ~A"
msgstr ""

#: src/code/package.lisp
msgid "~S is a package name, so it cannot be a nickname for ~S."
msgstr ""

#: src/code/package.lisp
msgid "Ignore this nickname."
msgstr ""

#: src/code/package.lisp
msgid "~S is already a nickname for ~S."
msgstr ""

#: src/code/package.lisp
msgid "Redefine this nickname."
msgstr ""

#: src/code/package.lisp
msgid ""
"Makes a new package having the specified Name and Nicknames.  The\n"
"  package will inherit all external symbols from each package in\n"
"  the use list.  :Internal-Symbols and :External-Symbols are\n"
"  estimates for the number of internal and external symbols which\n"
"  will ultimately be present in the package."
msgstr ""

#: src/code/package.lisp
msgid "Leave existing package alone."
msgstr ""

#: src/code/package.lisp
msgid "A package named ~S already exists"
msgstr ""

#: src/code/package.lisp
msgid ""
"Sets *PACKAGE* to package with given NAME, creating the package if\n"
"   it does not exist.  If the package already exists then it is modified\n"
"   to agree with the :USE and :NICKNAMES arguments.  Any new nicknames\n"
"   are added without removing any old ones not specified.  If any package\n"
"   in the :Use list is not currently used, then it is added to the use\n"
"   list."
msgstr ""

#: src/code/package.lisp
msgid "Old-style IN-PACKAGE."
msgstr ""

#: src/code/package.lisp
msgid "The package named ~S doesn't exist."
msgstr ""

#: src/code/package.lisp
msgid ""
"Replaces the name and nicknames of Package. The old name and all of\n"
"  the old nicknames of Package are eliminated and are replaced by\n"
"  New-Name and New-Nicknames."
msgstr ""

#: src/code/package.lisp
msgid "A package named ~S already exists."
msgstr ""

#: src/code/package.lisp
msgid "Delete the PACKAGE-OR-NAME from the package system data structures."
msgstr ""

#: src/code/package.lisp
msgid "No package of name ~S."
msgstr ""

#: src/code/package.lisp
msgid "Return NIL"
msgstr ""

#: src/code/package.lisp
msgid "Remove dependency in other packages."
msgstr ""

#: src/code/package.lisp
msgid "Returns a list of all existing packages."
msgstr ""

#: src/code/package.lisp
msgid "Returns a symbol having the specified name, creating it if necessary."
msgstr ""

#: src/code/package.lisp
msgid ""
"Returns the symbol NAME in PACKAGE.  If such a symbol is found\n"
"  then the second value is :internal, :external or :inherited to indicate\n"
"  how the symbol is accessible.  If no symbol is found then both values\n"
"  are NIL."
msgstr ""

#: src/code/package.lisp
msgid ""
"Makes SYMBOL no longer present in PACKAGE.  If SYMBOL was present\n"
"  then T is returned, otherwise NIL.  If PACKAGE is SYMBOL's home\n"
"  package, then it is made uninterned."
msgstr ""

#: src/code/package.lisp
msgid "uninterning symbol ~A"
msgstr ""

#: src/code/package.lisp
msgid "Disable package's lock then continue"
msgstr ""

#: src/code/macros.lisp src/code/defstruct.lisp src/code/package.lisp
msgid "Unlock all packages, then continue"
msgstr ""

#: src/code/package.lisp
msgid "prompt for a symbol to shadowing-import."
msgstr ""

#: src/code/package.lisp
msgid "Uninterning symbol ~S causes name conflict among these symbols:~%~S"
msgstr ""

#: src/code/package.lisp
msgid "Symbol to shadowing-import: "
msgstr ""

#: src/code/package.lisp
msgid "~S is not a symbol."
msgstr ""

#: src/code/package.lisp
msgid "~S is not one of the conflicting symbols."
msgstr ""

#: src/code/package.lisp
msgid "~S is neither a symbol nor a list of symbols."
msgstr ""

#: src/code/package.lisp
msgid "Exports SYMBOLS from PACKAGE, checking that no name conflicts result."
msgstr ""

#: src/code/package.lisp
msgid ""
"Exporting these symbols from the ~A package:~%~S~%~\n"
"	      results in name conflicts with these packages:~%~{~A ~}"
msgstr ""

#: src/code/package.lisp
msgid "Unintern conflicting symbols."
msgstr ""

#: src/code/package.lisp
msgid "Skip exporting conflicting symbols."
msgstr ""

#: src/code/package.lisp
msgid "These symbols are not accessible in the ~A package:~%~S"
msgstr ""

#: src/code/package.lisp
msgid "Import these symbols into the ~A package."
msgstr ""

#: src/code/package.lisp
msgid "Makes SYMBOLS no longer exported from PACKAGE."
msgstr ""

#: src/code/package.lisp
msgid "unexporting symbols ~A"
msgstr ""

#: src/code/package.lisp
msgid "~S is not accessible in the ~A package."
msgstr ""

#: src/code/package.lisp
msgid ""
"Make SYMBOLS accessible as internal symbols in PACKAGE.  If a symbol\n"
"  is already accessible then it has no effect.  If a name conflict\n"
"  would result from the importation, then a correctable error is signalled."
msgstr ""

#: src/code/package.lisp
msgid ""
"Importing these symbols into the ~A package ~\n"
"		causes a name conflict:~%~S"
msgstr ""

#: src/code/package.lisp
msgid "Import these symbols with Shadowing-Import."
msgstr ""

#: src/code/package.lisp
msgid ""
"Import SYMBOLS into PACKAGE, disregarding any name conflict.  If\n"
"  a symbol of the same name is present, then it is uninterned.\n"
"  The symbols are added to the Package-Shadowing-Symbols."
msgstr ""

#: src/code/package.lisp
msgid ""
"Make an internal symbol in PACKAGE with the same name as each of the\n"
"  specified SYMBOLS, adding the new symbols to the Package-Shadowing-Symbols"
".\n"
"  If a symbol with the given name is already present in PACKAGE, then\n"
"  the existing symbol is placed in the shadowing symbols list if it is\n"
"  not already present."
msgstr ""

#: src/code/package.lisp
msgid ""
"Add all the PACKAGES-TO-USE to the use list for PACKAGE so that\n"
"  the external symbols of the used packages are accessible as internal\n"
"  symbols in PACKAGE."
msgstr ""

#: src/code/package.lisp
msgid "Unintern the conflicting symbols in the ~2*~A package."
msgstr ""

#: src/code/package.lisp
msgid "Use'ing package ~A results in name conflicts for these symbols:~%~S"
msgstr ""

#: src/code/package.lisp
msgid "Remove PACKAGES-TO-UNUSE from the use list for PACKAGE."
msgstr ""

#: src/code/package.lisp
msgid "Return a list of all symbols in the system having the specified name."
msgstr ""

#: src/code/describe.lisp src/code/package.lisp
msgid "special variable"
msgstr ""

#: src/code/describe.lisp src/code/package.lisp
msgid "constant"
msgstr ""

#: src/code/describe.lisp src/code/package.lisp
msgid "undefined variable"
msgstr ""

#: src/code/describe.lisp src/code/package.lisp
msgid "symbol macro"
msgstr ""

#: src/code/package.lisp
msgid "alien variable"
msgstr ""

#: src/code/package.lisp
msgid "value: "
msgstr ""

#: src/code/package.lisp
msgid "macro"
msgstr ""

#: src/code/package.lisp
msgid "special operator"
msgstr ""

#: src/code/package.lisp
msgid "function"
msgstr ""

#: src/code/package.lisp
msgid "class"
msgstr ""

#: src/code/package.lisp
msgid "type"
msgstr ""

#: src/code/package.lisp
msgid ""
"Call FUN with each symbol that contains STRING.\n"
"  If PACKAGE is supplied then only use symbols present in\n"
"  that package.  If EXTERNAL-ONLY is true then only use\n"
"  symbols exported from the specified package."
msgstr ""

#: src/code/package.lisp
msgid ""
"Briefly describe all symbols which contain the specified STRING.\n"
"  If PACKAGE is supplied then only describe symbols present in\n"
"  that package.  If EXTERNAL-ONLY is non-NIL then only describe\n"
"  external symbols in the specified package."
msgstr ""

#: src/code/package.lisp
msgid ""
"Identical to APROPOS, except that it returns a list of the symbols\n"
"  found instead of describing them."
msgstr ""

#: src/code/reader.lisp
msgid "Float format for 1.0E1"
msgstr ""

#: src/code/reader.lisp
msgid "Variable bound to current readtable."
msgstr ""

#: src/code/reader.lisp
msgid "Reader error ~@[at ~D ~]on ~S:~%~?"
msgstr ""

#: src/code/reader.lisp
msgid "Unexpected EOF on ~S ~A."
msgstr ""

#: src/code/reader.lisp
msgid ""
"Standard lisp readtable. This is for recovery from broken\n"
"   read-tables, and should not normally be user-visible."
msgstr ""

#: src/code/reader.lisp
msgid "Value of *package* at the start of the last read or Nil."
msgstr ""

#: src/code/reader.lisp
msgid "Undefined read-macro character ~S"
msgstr ""

#: src/code/reader.lisp
msgid "A copy is made of from-readtable and place into to-readtable."
msgstr ""

#: src/code/reader.lisp
msgid ""
"Causes the syntax of to-char to be the same as from-char in the \n"
"  optional readtable (defaults to the current readtable).  The\n"
"  from-table defaults the standard lisp readtable by being nil."
msgstr ""

#: src/code/reader.lisp
msgid ""
"Causes char to be a macro character which invokes function when\n"
"   seen by the reader.  The non-terminatingp flag can be used to\n"
"   make the macro character non-terminating.  The optional readtable\n"
"   argument defaults to the current readtable.  Set-macro-character\n"
"   returns T."
msgstr ""

#: src/code/reader.lisp
msgid ""
"Returns the function associated with the specified char which is a macro\n"
"  character.  The optional readtable argument defaults to the current\n"
"  readtable."
msgstr ""

#: src/code/reader.lisp
msgid "Bind *read-buffer* to a fresh buffer and execute Body."
msgstr ""

#: src/code/reader.lisp
msgid ""
"If true, only warn when there is an extra close paren, otherwise error."
msgstr ""

#: src/code/reader.lisp
msgid ""
"Reads from stream and returns the object read, preserving the whitespace\n"
"   that followed the object."
msgstr ""

#: src/code/reader.lisp
msgid ""
"Reads in the next object in the stream, which defaults to\n"
"   *standard-input*. For details see the I/O chapter of\n"
"   the manual."
msgstr ""

#: src/code/reader.lisp
msgid ""
"Reads objects from input-stream until the next character after an\n"
"   object's representation is endchar.  A list of those objects read\n"
"   is returned."
msgstr ""

#: src/code/reader.lisp
msgid "Nothing appears before . in list."
msgstr ""

#: src/code/reader.lisp
msgid "Nothing appears after . in list."
msgstr ""

#: src/code/reader.lisp
msgid "More than one object follows . in list."
msgstr ""

#: src/code/reader.lisp
msgid "Ignoring unmatched close parenthesis~\n"
"		  ~@[ at file position ~D~]."
msgstr ""

#: src/code/reader.lisp
msgid "Unmatched close parenthesis."
msgstr ""

#: src/code/reader.lisp
msgid "after escape character"
msgstr ""

#: src/code/reader.lisp
msgid "inside extended token"
msgstr ""

#: src/code/reader.lisp
msgid "invalid constituent"
msgstr ""

#: src/code/reader.lisp
msgid "Suppresses most interpreting of the reader when T"
msgstr ""

#: src/code/reader.lisp
msgid "The radix that Lisp reads numbers in."
msgstr ""

#: src/code/reader.lisp
msgid "impossible!"
msgstr ""

#: src/code/reader.lisp
msgid "dot context error"
msgstr ""

#: src/code/reader.lisp
msgid "too many dots"
msgstr ""

#: src/code/reader.lisp
msgid "too many colons in ~S"
msgstr ""

#: src/code/reader.lisp
msgid "after reading a colon"
msgstr ""

#: src/code/reader.lisp
msgid "package ~S not found"
msgstr ""

#: src/code/reader.lisp
msgid "Use symbol anyway."
msgstr ""

#: src/code/reader.lisp
msgid "The symbol ~S is not external in the ~A package."
msgstr ""

#: src/code/reader.lisp
msgid "Symbol ~S not found in the ~A package."
msgstr ""

#: src/code/reader.lisp
msgid "This function is just an fsm that recognizes numbers and symbols."
msgstr ""

#: src/code/reader.lisp
msgid ""
"For semi-external use: returns 3 values: the string for the token,\n"
"   a flag for whether there was an escape char, and the position of any\n"
"   package delimiter."
msgstr ""

#: src/code/reader.lisp
msgid "after escape"
msgstr ""

#: src/code/reader.lisp
msgid ""
"For semi-external use: read an extended token with the first character\n"
"  escaped.  Returns the string for the token."
msgstr ""

#: src/code/reader.lisp
msgid ""
"Holds the mapping of base to 'safe' number of digits to read for a fixnum."
msgstr ""

#: src/code/reader.lisp
msgid "Holds the largest fixnum power of the base for make-integer."
msgstr ""

#: src/code/reader.lisp
msgid ""
"Minimizes bignum-fixnum multiplies by reading a 'safe' number of digits, \n"
"  then multiplying by a power of the base and adding."
msgstr ""

#: src/code/reader.lisp
msgid ""
"Fast bignum-reading interface.  Reads from stream S an integer in radix\n"
"R.  If we find some kind of error (bad characters, EOF), then NIL is\n"
"returned; otherwise the number.  Reads at least one digit, but may not get "
"to\n"
"the end of the stream."
msgstr ""

#: src/code/reader.lisp
msgid "Internal error in floating point reader."
msgstr ""

#: src/code/reader.lisp
msgid "Underflow"
msgstr ""

#: src/code/reader.lisp
msgid "Number not representable as a ~S: ~S"
msgstr ""

#: src/code/reader.lisp
msgid "Invalid ratio: ~S/~S"
msgstr ""

#: src/code/reader.lisp
msgid "No dispatch function defined for ~S."
msgstr ""

#: src/code/reader.lisp
msgid ""
"Causes char to become a dispatching macro character in readtable\n"
"   (which defaults to the current readtable).  If the non-terminating-p\n"
"   flag is set to T, the char will be non-terminating.  Make-dispatch-\n"
"   macro-character returns T."
msgstr ""

#: src/code/reader.lisp
msgid "Dispatch Sub-Char must not be a decimal digit: ~S"
msgstr ""

#: src/code/reader.lisp
msgid "~S is not a dispatch character."
msgstr ""

#: src/code/reader.lisp
msgid ""
"Causes function to be called whenever the reader reads\n"
"   disp-char followed by sub-char. Set-dispatch-macro-character\n"
"   returns T."
msgstr ""

#: src/code/reader.lisp
msgid ""
"Returns the macro character function for sub-char under disp-char\n"
"   or nil if there is no associated function."
msgstr ""

#: src/code/reader.lisp
msgid "inside dispatch character"
msgstr ""

#: src/code/reader.lisp
msgid "No dispatch table for dispatch char."
msgstr ""

#: src/code/reader.lisp
msgid "A resource of string streams for Read-From-String."
msgstr ""

#: src/code/reader.lisp
msgid ""
"The characters of string are successively given to the lisp reader\n"
"   and the lisp object built by the reader is returned.  Macro chars\n"
"   will take effect."
msgstr ""

#: src/code/reader.lisp
msgid "There are no digits in this string: ~S"
msgstr ""

#: src/code/reader.lisp
msgid "There's junk in this string: ~S."
msgstr ""

#: src/code/reader.lisp
msgid ""
"Examine the substring of string delimited by start and end\n"
"  (default to the beginning and end of the string)  It skips over\n"
"  whitespace characters and then tries to parse an integer.  The\n"
"  radix parameter must be between 2 and 36."
msgstr ""

#: src/code/sharpm.lisp
msgid "Numeric argument ignored in #~D~A."
msgstr ""

#: src/code/sharpm.lisp
msgid "Unrecognized character name: ~S"
msgstr ""

#: src/code/sharpm.lisp
msgid "Ill-formed vector: #~S"
msgstr ""

#: src/code/sharpm.lisp
msgid "Vector longer than specified length: #~S~S"
msgstr ""

#: src/code/sharpm.lisp
msgid "Escape character appeared after #*"
msgstr ""

#: src/code/sharpm.lisp
msgid "You have to give a little bit for non-zero #* bit-vectors."
msgstr ""

#: src/code/sharpm.lisp
msgid "Illegal element given for bit-vector: ~S"
msgstr ""

#: src/code/sharpm.lisp
msgid "Bit vector is longer than specified length #~A*~A"
msgstr ""

#: src/code/sharpm.lisp
msgid "Symbol following #: contains a package marker: ~S"
msgstr ""

#: src/code/sharpm.lisp
msgid "If false, then the #. read macro is disabled."
msgstr ""

#: src/code/sharpm.lisp
msgid "Attempt to read #. while *READ-EVAL* is bound to NIL."
msgstr ""

#: src/code/sharpm.lisp
msgid "Radix missing in #R."
msgstr ""

#: src/code/sharpm.lisp
msgid "Illegal radix for #R: ~D."
msgstr ""

#: src/code/sharpm.lisp
msgid "#~A (base ~D) value is not a rational: ~S."
msgstr ""

#: src/code/sharpm.lisp
msgid "#~DA axis ~D is empty, but axis ~\n"
"				          ~D is non-empty."
msgstr ""

#: src/code/sharpm.lisp
msgid "Non-list following #S: ~S"
msgstr ""

#: src/code/sharpm.lisp
msgid "Structure type is not a symbol: ~S"
msgstr ""

#: src/code/sharpm.lisp
msgid "~S is not a defined structure type."
msgstr ""

#: src/code/sharpm.lisp
msgid "The ~S structure does not have a default constructor."
msgstr ""

#: src/code/sharpm.lisp
msgid "Non-list following #S"
msgstr ""

#: src/code/sharpm.lisp
msgid "Missing label for #=."
msgstr ""

#: src/code/sharpm.lisp
msgid "Multiply defined label: #~D="
msgstr ""

#: src/code/sharpm.lisp
msgid "Have to tag something more than just #~D#."
msgstr ""

#: src/code/sharpm.lisp
msgid "Missing label for ##."
msgstr ""

#: src/code/sharpm.lisp
msgid "reference to undefined label #~D#"
msgstr ""

#: src/code/sharpm.lisp
msgid "Illegal complex number format: #C~S"
msgstr ""

#: src/code/sharpm.lisp
msgid "Illegal sharp character ~S"
msgstr ""

#: src/code/backq.lisp
msgid "How deep we are into backquotes"
msgstr ""

#: src/code/backq.lisp
msgid ",@ after backquote in ~S"
msgstr ""

#: src/code/backq.lisp
msgid ",. after backquote in ~S"
msgstr ""

#: src/code/backq.lisp
msgid "Comma not inside a backquote."
msgstr ""

#: src/code/backq.lisp
msgid ",@ after dot in ~S"
msgstr ""

#: src/code/backq.lisp
msgid ",. after dot in ~S"
msgstr ""

#: src/code/backq.lisp
msgid ""
"Given a lisp form containing the magic functions BACKQ-LIST, BACKQ-LIST*,\n"
"  BACKQ-APPEND, etc. produced by the backquote reader macro, will return a\n"
"  corresponding backquote input form.  In this form, `,' `,@' and `,.' are\n"
"  represented by lists whose cars are BACKQ-COMMA, BACKQ-COMMA-AT, and\n"
"  BACKQ-COMMA-DOT respectively, and whose cadrs are the form after the "
"comma.\n"
"  SPLICING indicates whether a comma-escape return should be modified for\n"
"  splicing with other forms: a value of T or :NCONC meaning that an extra\n"
"  level of parentheses should be added."
msgstr ""

#: src/code/backq.lisp
msgid "### illegal dotted backquote form ###"
msgstr ""

#: src/code/serve-event.lisp
msgid ""
"Make an object set for use by a RPC/xevent server.  Name is for\n"
"      descriptive purposes only."
msgstr ""

#: src/code/serve-event.lisp
msgid "You lose, object: ~S"
msgstr ""

#: src/code/serve-event.lisp
msgid ""
"Return as multiple values the object and object-set mapped to by xwindow."
msgstr ""

#: src/code/serve-event.lisp
msgid "Add a new xwindow/object/object-set association."
msgstr ""

#: src/code/serve-event.lisp
msgid "Remove xwindow and its associated object/object-set pair."
msgstr ""

#: src/code/serve-event.lisp
msgid ""
"Return the handler function in Object-Set for the operation specified by\n"
"   Message-ID, if none, NIL is returned."
msgstr ""

#: src/code/serve-event.lisp
msgid "#<Handler for ~A on ~:[~;BOGUS ~]descriptor ~D: ~S>"
msgstr ""

#: src/code/serve-event.lisp
msgid "List of all the currently active handlers for file descriptors"
msgstr ""

#: src/code/serve-event.lisp
msgid ""
"Arange to call FUNCTION whenever FD is usable. DIRECTION should be\n"
"  either :INPUT or :OUTPUT. The value returned should be passed to\n"
"  SYSTEM:REMOVE-FD-HANDLER when it is no longer needed."
msgstr ""

#: src/code/serve-event.lisp
msgid "Invalid direction ~S, must be either :INPUT or :OUTPUT"
msgstr ""

#: src/code/serve-event.lisp
msgid "Removes HANDLER from the list of active handlers."
msgstr ""

#: src/code/serve-event.lisp
msgid ""
"Remove any handers refering to FD. This should only be used when attempting\n"
"  to recover from a detected inconsistency."
msgstr ""

#: src/code/serve-event.lisp
msgid ""
"Establish a handler with SYSTEM:ADD-FD-HANDLER for the duration of BODY.\n"
"   DIRECTION should be either :INPUT or :OUTPUT, FD is the file descriptor "
"to\n"
"   use, and FUNCTION is the function to call whenever FD is usable."
msgstr ""

#.  This needs more work.
#: src/code/serve-event.lisp
msgid "~S ~[have~;has a~:;have~] bad file descriptor."
msgid_plural "~S ~[have~;has a~:;have~] bad file descriptors."
msgstr[0] ""

#: src/code/serve-event.lisp
msgid "Remove bogus handlers."
msgstr ""

#: src/code/serve-event.lisp
msgid "Retry bogus handlers."
msgstr ""

#: src/code/serve-event.lisp
msgid "Go on, leaving handlers marked as bogus."
msgstr ""

#: src/code/serve-event.lisp
msgid "Timeout is not a real number or NIL: ~S"
msgstr ""

#: src/code/serve-event.lisp
msgid ""
"Wait until FD is usable for DIRECTION. DIRECTION should be either :INPUT or\n"
"  :OUTPUT. TIMEOUT, if supplied, is the number of seconds to wait before "
"giving\n"
"  up."
msgstr ""

#: src/code/time.lisp src/code/serve-event.lisp
msgid "Syscall ~A failed: ~A"
msgstr ""

#: src/code/serve-event.lisp
msgid ""
"This is an alist mapping displays to user functions to be called when\n"
"   SYSTEM:SERVE-EVENT notices input on a display connection.  Do not modify\n"
"   this directly; use EXT:ENABLE-CLX-EVENT-HANDLING.  A given display\n"
"   should be represented here only once."
msgstr ""

#: src/code/serve-event.lisp
msgid ""
"SERVE-ALL-EVENTS calls SERVE-EVENT with the specified timeout.  If\n"
"  SERVE-EVENT does something (returns T) it loops over SERVE-EVENT with "
"timeout\n"
"  0 until all events have been served.  SERVE-ALL-EVENTS returns T if\n"
"  SERVE-EVENT did something and NIL if not."
msgstr ""

#: src/code/serve-event.lisp
msgid ""
"Receive on all ports and Xevents and dispatch to the appropriate handler\n"
"  function.  If timeout is specified, server will wait the specified time "
"(in\n"
"  seconds) and then return, otherwise it will wait until something happens.\n"
"  Server returns T if something happened and NIL otherwise."
msgstr ""

#: src/code/serve-event.lisp
msgid "Event-listen was true, but handler didn't handle: ~%~S"
msgstr ""

#: src/code/extfmts.lisp
msgid ""
"The default external format to use if no other external format is\n"
"  specified"
msgstr ""

#: src/code/extfmts.lisp
msgid "Hash table of all the external formats that have been loaded"
msgstr ""

#: src/code/extfmts.lisp
msgid ""
"Hash table mapping an external format alias to the actual external\n"
"  format implementation"
msgstr ""

#: src/code/extfmts.lisp
msgid "Attempting unimplemented external-format I/O."
msgstr ""

#: src/code/extfmts.lisp
msgid "External format ~S not found."
msgstr ""

#: src/code/extfmts.lisp
msgid "Bad entry in external-format aliases file: ~S => ~S."
msgstr ""

#: src/code/extfmts.lisp
msgid "External-format aliases file ends early."
msgstr ""

#: src/code/extfmts.lisp
msgid ""
"List the available external formats.  A list is returned where each\n"
"  element is list of the external format and a list of aliases for the\n"
"  format.  No distinction is made between external formats and\n"
"  composing external formats."
msgstr ""

#: src/code/extfmts.lisp
msgid ""
"Print a description of the given External-Format.  This may cause\n"
"  the external format to be loaded (silently), if it is not already\n"
"  loaded."
msgstr ""

#: src/code/extfmts.lisp
msgid "~&~S is an alias for the external format ~S.~2%"
msgstr ""

#: src/code/extfmts.lisp
msgid "~&~S is a composed external format.~2%"
msgstr ""

#: src/code/extfmts.lisp
msgid "~S~:[~; - [Aliases: ~{~S~^, ~}~]]~%"
msgstr ""

#: src/code/extfmts.lisp
msgid "~&~S is a composing external format.~2%"
msgstr ""

#: src/code/extfmts.lisp
msgid "~&Could not find external format ~S~%"
msgstr ""

#: src/code/extfmts.lisp
msgid "External-format aliasing depth exceeded."
msgstr ""

#: src/code/extfmts.lisp
msgid "~S is a Composing-External-Format."
msgstr ""

#: src/code/extfmts.lisp
msgid "~S is not a Composing-External-Format."
msgstr ""

#: src/code/extfmts.lisp
msgid "~S is not a valid external format name."
msgstr ""

#: src/code/extfmts.lisp
msgid "Attempting I/O through void external-format."
msgstr ""

#: src/code/extfmts.lisp
msgid "Void external format that signals an error on any input or output."
msgstr ""

#: src/code/extfmts.lisp
msgid ""
"ISO8859-1 is an 8-bit character encoding generally intended for\n"
"Western European languages including English, German, Italian,\n"
"Norwegian, Portuguese, Spanish, Swedish and many others.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

#: src/code/extfmts.lisp
msgid ""
"Convert String to octets using the specified External-format.  The\n"
"  string is bounded by Start (defaulting to 0) and End (defaulting to\n"
"  the end of the string.  If Buffer is given, the octets are stored\n"
"  there.  If not, a new buffer is created.  Buffer-start specifies\n"
"  where in the buffer the first octet will be placed.\n"
"\n"
"  Three values are returned: The buffer, the number of valid octets\n"
"  written, and the number of characters converted.  Note that the\n"
"  actual number of octets written may be greater than the returned\n"
"  value, These represent the partial octets of the next character to\n"
"  be converted, but there was not enough room to hold the complete set\n"
"  of octets."
msgstr ""

#: src/code/extfmts.lisp
msgid ""
"Octets-to-string converts an array of octets in Octets to a string\n"
"  according to the specified External-format.  The array of octets is\n"
"  bounded by Start (defaulting ot 0) and End (defaulting to the end of\n"
"  the array.  If String is not given, a new string is created.  If\n"
"  String is given, the converted octets are stored in String, starting\n"
"  at S-Start (defaulting to the 0) and ending at S-End (defaulting to\n"
"  the length of String).  If the string is not large enough to hold\n"
"  all of characters, then some octets will not be converted.  A State\n"
"  may also be specified; this is used as the state of the external\n"
"  format.  An error method may also be specified by Error, which\n"
"  defaults to NIL to mean the default handling of conversion errors is\n"
"  done.\n"
"\n"
"  Four values are returned: the string, the position of where the next\n"
"  character would be read into the string, the number of octets\n"
"  actually consumed and the new state of the external format."
msgstr ""

#: src/code/extfmts.lisp
msgid ""
"Octets-to-string converts an array of octets in Octets to a string\n"
"  according to the specified External-format.  The array of octets is\n"
"  bounded by Start (defaulting ot 0) and End (defaulting to the end of\n"
"  the array.  If String is not given, a new string is created.  If\n"
"  String is given, the converted octets are stored in String, starting\n"
"  at S-Start (defaulting to the 0) and ending at S-End (defaulting to\n"
"  the length of String).  If the string is not large enough to hold\n"
"  all of characters, then some octets will not be converted.  A State\n"
"  may also be specified; this is used as the state of the external\n"
"  format.\n"
"\n"
"  In Ocount, the number of octets read for each character in the\n"
"  string is saved\n"
"\n"
"  Four values are returned: the string, the number of characters read,\n"
"  the number of octets actually consumed and the new state of the\n"
"  external format."
msgstr ""

#: src/code/extfmts.lisp
msgid ""
"Encode the given String using External-Format and return a new\n"
"  string.  The characters of the new string are the octets of the\n"
"  encoded result, with each octet converted to a character via\n"
"  code-char.  This is the inverse to String-Decode"
msgstr ""

#: src/code/extfmts.lisp
msgid ""
"Decode String using the given External-Format and return the new\n"
"  string.  The input string is treated as if it were an array of\n"
"  octets, where the char-code of each character is the octet.  This is\n"
"  the inverse of String-Encode."
msgstr ""

#: src/code/extfmts.lisp
msgid ""
"Change the external format of the standard streams to Terminal.\n"
"  The standard streams are sys::*stdin*, sys::*stdout*, and\n"
"  sys::*stderr*, which are normally the input and/or output streams\n"
"  for *standard-input* and *standard-output*.  Also sets sys::*tty*\n"
"  (normally *terminal-io* to the given external format.  The value of\n"
"  *default-external-format* is not changed.\n"
"\n"
"  If the optional argument Filenames is given, then the filename\n"
"  encoding is set to the specified format, if it has not already been\n"
"  specified previously."
msgstr ""

#: src/code/extfmts.lisp
msgid "Can't find external-format ~S."
msgstr ""

#: src/code/extfmts.lisp
msgid "Change it anyway."
msgstr ""

#: src/code/extfmts.lisp
msgid "The external-format for encoding filenames is already set."
msgstr ""

#: src/code/extfmts.lisp
msgid ""
"UTF-8 is a variable-length character encoding for Unicode.  By\n"
"default, illegal input sequences are replaced by the Unicode\n"
"replacement character."
msgstr ""

#: src/code/fd-stream.lisp
msgid ""
"List of available buffers.  Each buffer is an sap pointing to\n"
"  bytes-per-buffer of memory."
msgstr ""

#: src/code/fd-stream.lisp
msgid "Number of bytes per buffer."
msgstr ""

#: src/code/fd-stream.lisp
msgid "The maximum supported byte size for a stream element-type."
msgstr ""

#: src/code/fd-stream.lisp
msgid "Timeout ~(~A~)ing ~S."
msgstr ""

#: src/code/fd-stream.lisp
msgid ""
"List of all available output routines. Each element is a list of the\n"
"  element-type output, the kind of buffering, the function name, and the "
"number\n"
"  of bytes per element."
msgstr ""

#: src/code/fd-stream.lisp
msgid "Write would have blocked, but SERVER told us to go."
msgstr ""

#: src/code/fd-stream.lisp
msgid "While writing ~S: ~A"
msgstr ""

#: src/code/fd-stream.lisp
msgid ""
"Output THING to stream.  THING can be any kind of vector or a sap.  If "
"THING\n"
"  is a SAP, END must be supplied (as length won't work)."
msgstr ""

#: src/code/fd-stream.lisp
msgid "Just go on as if nothing happened..."
msgstr ""

#: src/code/fd-stream.lisp
msgid "~S called with :END before :START!"
msgstr ""

#: src/code/fd-stream.lisp
msgid ""
"List of all available input routines. Each element is a list of the\n"
"  element-type input, the function name, and the number of bytes per "
"element."
msgstr ""

#: src/code/fd-stream.lisp
msgid "Error reading ~S: ~A"
msgstr ""

#: src/code/fd-stream.lisp
msgid "Could not find any input routine for ~S"
msgstr ""

#: src/code/fd-stream.lisp
msgid "Could not find any output routine for ~S buffered ~S."
msgstr ""

#: src/code/fd-stream.lisp
msgid "Element sizes for input (~S:~S) and output (~S:~S) differ?"
msgstr ""

#: src/code/fd-stream.lisp
msgid "Input type (~S) and output type (~S) are unrelated?"
msgstr ""

#: src/code/fd-stream.lisp
msgid "Go on as if nothing bad happened."
msgstr ""

#: src/code/fd-stream.lisp
msgid "Could not restore ~S to its original contents: ~A"
msgstr ""

#: src/code/fd-stream.lisp
msgid "~s is not a stream associated with a file."
msgstr ""

#: src/code/fd-stream.lisp
msgid "Error fstating ~S: ~A"
msgstr ""

#: src/code/fd-stream.lisp
msgid "Error lseek'ing ~S: ~A"
msgstr ""

#: src/code/fd-stream.lisp
msgid "Invalid position given to file-position: ~S"
msgstr ""

#: src/code/fd-stream.lisp
msgid "Use Unicode replacement character instead"
msgstr ""

#: src/code/fd-stream.lisp
msgid "Use question mark character instead"
msgstr ""

#: src/code/fd-stream.lisp
msgid ""
"Create a stream for the given unix file descriptor.\n"
"  If input is non-nil, allow input operations.\n"
"  If output is non-nil, allow output operations.\n"
"  If neither input nor output are specified, default to allowing input.\n"
"  Element-type indicates the element type to use (as for open).\n"
"  Buffering indicates the kind of buffering to use.\n"
"  Timeout (if true) is the number of seconds to wait for input.  If NIL "
"(the\n"
"    default), then wait forever.  When we time out, we signal IO-TIMEOUT.\n"
"  File is the name of the file (will be returned by PATHNAME).\n"
"  Name is used to identify the stream when printed.\n"
"  External-format is the external format to use for the stream.\n"
"  Decoding-error and Encoding-error indicate how decoding/encoding errors "
"on\n"
"    the stream should be handled.  The default is to use a replacement "
"character."
msgstr ""

#: src/code/fd-stream.lisp
msgid "File descriptor must be opened either for input or output."
msgstr ""

#: src/code/fd-stream.lisp
msgid "** Closed ~A~%"
msgstr ""

#: src/code/fd-stream.lisp
msgid ""
"This is a string that OPEN tacks on the end of a file namestring to produce\n"
"   a name for the :if-exists :rename-and-delete and :rename options.  Also,\n"
"   this can be a function that takes a namestring and returns a complete\n"
"   namestring."
msgstr ""

#: src/code/fd-stream.lisp
msgid "Enter new value for ~*~S"
msgstr ""

#: src/code/fd-stream.lisp
msgid "~S is invalid for ~S. Must be one of~{ ~S~}"
msgstr ""

#: src/code/fd-stream.lisp
msgid "Enter new value for ~S: "
msgstr ""

#: src/code/fd-stream.lisp
msgid "Try to rename it anyway."
msgstr ""

#: src/code/fd-stream.lisp
msgid "File ~S is not writable."
msgstr ""

#: src/code/fd-stream.lisp
msgid "Use :SUPERSEDE instead."
msgstr ""

#: src/code/fd-stream.lisp
msgid "Could not rename ~S to ~S: ~A."
msgstr ""

#: src/code/fd-stream.lisp
msgid "Cannot open ~S for output: Is a directory."
msgstr ""

#: src/code/fd-stream.lisp
msgid "Cannot find ~S: ~A"
msgstr ""

#: src/code/fd-stream.lisp
msgid "Return NIL."
msgstr ""

#: src/code/fd-stream.lisp
msgid "Error opening ~S, ~A."
msgstr ""

#: src/code/fd-stream.lisp
msgid "Error creating ~S, path does not exist."
msgstr ""

#: src/pcl/braid.lisp src/code/fd-stream.lisp
msgid "Try again."
msgstr ""

#: src/code/fd-stream.lisp
msgid ""
"Return a stream which reads from or writes to Filename.\n"
"  Defined keywords:\n"
"   :direction - one of :input, :output, :io, or :probe\n"
"   :element-type - Type of object to read or write, default BASE-CHAR\n"
"   :if-exists - one of :error, :new-version, :rename, :rename-and-delete,\n"
"                       :overwrite, :append, :supersede or nil\n"
"   :if-does-not-exist - one of :error, :create or nil\n"
"   :external-format - an external format name\n"
"   :decoding-error - How to handle decoding errors from the external "
"format.\n"
"                       If a character, then that character is used as\n"
"                       the replacment character for all errors.  If T,\n"
"                       then a continuable error is signaled.  If\n"
"                       continued, the Unicode replacement character is\n"
"                       used.  Otherwise, it should be a symbol or\n"
"                       function of 3 arguments.  If it returns, it\n"
"                       should return a code point to use as the\n"
"                       replacment.  The function arguments are a\n"
"                       format message string, the offending octet, and\n"
"                       the number of octets read in the current\n"
"                       encoding.\n"
"   :encoding-error - Like :decoding-error, but for errors when encoding the\n"
"                       stream.  If a character, that character is used\n"
"                       as the replacment code point.  Otherwise, it\n"
"                       should be a symbol or function oof two\n"
"                       arguments: a format message string and the\n"
"                       incorrect codepoint.\n"
"\n"
"  See the manual for details."
msgstr ""

#: src/pcl/std-class.lisp src/pcl/boot.lisp src/pcl/defs.lisp
#: src/pcl/defclass.lisp src/code/fd-stream.lisp
msgid "Odd-length property list in REMF."
msgstr ""

#: src/code/fd-stream.lisp
msgid "Do it anyway."
msgstr ""

#: src/code/fd-stream.lisp
msgid "Can't create simple-streams with an element-type."
msgstr ""

#: src/code/fd-stream.lisp
msgid "Unable to open streams of class ~S."
msgstr ""

#: src/code/fd-stream.lisp
msgid ""
"The stream connected to the controlling terminal or NIL if there is none."
msgstr ""

#: src/code/fd-stream.lisp
msgid "The stream connected to the standard input (file descriptor 0)."
msgstr ""

#: src/code/fd-stream.lisp
msgid "The stream connected to the standard output (file descriptor 1)."
msgstr ""

#: src/code/fd-stream.lisp
msgid "The stream connected to the standard error output (file descriptor 2)."
msgstr ""

#: src/code/fd-stream.lisp
msgid "This is called in BEEP to feep the user.  It takes a stream."
msgstr ""

#: src/code/fd-stream.lisp
msgid ""
"Return the delta in Stream's FILE-POSITION that would be caused by writing\n"
"   Object to Stream.  Non-trivial only in implementations that support\n"
"   international character sets."
msgstr ""

#: src/code/fd-stream-extfmt.lisp
msgid "Don't know how to set external-format for ~S."
msgstr ""

#: src/code/fd-stream-extfmt.lisp
msgid "Loading simple-streams should redefine this"
msgstr ""

#: src/code/fd-stream-extfmt.lisp
msgid "Setting external-format on Gray streams not supported."
msgstr ""

#: src/code/fd-stream-comp.lisp
msgid "Surrogate codepoint #x~~4,'0X is illegal for ~A"
msgstr ""

#: src/code/fd-stream-comp.lisp
msgid "Illegal codepoint on input: #x~X"
msgstr ""

#: src/code/fd-stream-comp.lisp
msgid "Cannot output codepoint #x~X to ISO8859-1 stream"
msgstr ""

#: src/code/fd-stream-comp.lisp
msgid "Cannot convert invalid surrogate #x~X to character"
msgstr ""

#: src/code/fd-stream-comp.lisp
msgid "Cannot convert lone trailing surrogate #x~X to character"
msgstr ""

#: src/code/pathname.lisp
msgid ""
"When non-nil, attempt to load \"library:<host>.translations\" to resolve\n"
"   an otherwise undefined logical host."
msgstr ""

#: src/code/pathname.lisp
msgid "A path specification, either a string, file-stream or pathname."
msgstr ""

#: src/code/pathname.lisp
msgid "Convert thing (a pathname, string or stream) into a pathname."
msgstr ""

#: src/code/pathname.lisp
msgid ""
"Construct a filled in pathname by completing the unspecified components\n"
"   from the defaults."
msgstr ""

#: src/code/pathname.lisp
msgid "~S is not allowed as a directory component."
msgstr ""

#: src/code/pathname.lisp
msgid ""
"Makes a new pathname from the component arguments.  Note that host is\n"
"a host-structure or string."
msgstr ""

#: src/code/pathname.lisp
msgid "Silly argument for a unix ~A: ~S"
msgstr ""

#: src/code/pathname.lisp
msgid "Silly argument for a unix PATHNAME-NAME: ~S"
msgstr ""

#: src/code/pathname.lisp
msgid ""
"Illegal pathname: ~\n"
"                                Directory with ~S immediately followed by "
"~S"
msgstr ""

#: src/code/pathname.lisp
msgid "Accessor for the pathname's host."
msgstr ""

#: src/code/pathname.lisp
msgid "Accessor for pathname's device."
msgstr ""

#: src/code/pathname.lisp
msgid "Accessor for the pathname's directory list."
msgstr ""

#: src/code/pathname.lisp
msgid "Accessor for the pathname's name."
msgstr ""

#: src/code/pathname.lisp
msgid "Accessor for the pathname's version."
msgstr ""

#: src/code/pathname.lisp
msgid "Parse error in namestring: ~?~%  ~A~%  ~V@T^"
msgstr ""

#: src/code/pathname.lisp
msgid ""
"When Host arg is not supplied, Defaults arg must ~\n"
"		  have a non-null PATHNAME-HOST."
msgstr ""

#: src/code/pathname.lisp
msgid ""
"Host in namestring: ~S~@\n"
"		    does not match explicit host argument: ~S"
msgstr ""

#: src/code/pathname.lisp
msgid ""
"Converts pathname, a pathname designator, into a pathname structure,\n"
"   for a physical pathname, returns the printed representation. Host may be\n"
"   a physical host structure or host namestring."
msgstr ""

#: src/code/pathname.lisp
msgid "Hosts do not match: ~S and ~S."
msgstr ""

#: src/code/pathname.lisp
msgid "Can't figure out the file associated with stream:~%  ~S"
msgstr ""

#: src/code/pathname.lisp
msgid ""
"A LIST representing a pathname host is not ~\n"
"                              supported in this implementation:~%  ~S"
msgstr ""

#: src/code/pathname.lisp
msgid "Construct the full (name)string form of the pathname."
msgstr ""

#: src/code/pathname.lisp
msgid ""
"Cannot determine the namestring for pathnames with no ~\n"
"		  host:~%  ~S"
msgstr ""

#: src/code/pathname.lisp
msgid ""
"Returns a string representation of the name of the host in the pathname."
msgstr ""

#: src/code/pathname.lisp
msgid "Cannot determine the namestring for pathnames with no host:~%  ~S"
msgstr ""

#: src/code/pathname.lisp
msgid ""
"Returns a string representation of the directories used in the pathname."
msgstr ""

#: src/code/pathname.lisp
msgid "Returns a string representation of the name used in the pathname."
msgstr ""

#: src/code/pathname.lisp
msgid ""
"Returns an abbreviated pathname sufficent to identify the pathname relative\n"
"   to the defaults."
msgstr ""

#: src/code/pathname.lisp
msgid "Predicate for determining whether pathname contains any wildcards."
msgstr ""

#: src/code/pathname.lisp
msgid "Pathname matches the wildname template?"
msgstr ""

#: src/code/pathname.lisp
msgid ""
"Not enough wildcards in FROM pattern to match ~\n"
"		       TO pattern:~%  ~S"
msgstr ""

#: src/code/pathname.lisp
msgid "Can't substitute this into the middle of a word:~\n"
"			  ~%  ~S"
msgstr ""

#: src/code/pathname.lisp
msgid ""
"Pathname components from Source and From args to TRANSLATE-PATHNAME~@\n"
"	  did not match:~%  ~S ~S"
msgstr ""

#: src/code/pathname.lisp
msgid ":WILD-INFERIORS not paired in from and to ~\n"
"			   patterns:~%  ~S ~S"
msgstr ""

#: src/code/pathname.lisp
msgid ""
"Use the source pathname to translate the from-wildname's wild and\n"
"   unspecified elements into a completed to-pathname based on the to-wildnam"
"e."
msgstr ""

#: src/code/pathname.lisp
msgid "~S doesn't match ~S"
msgstr ""

#: src/code/pathname.lisp
msgid "Search-list ~a not defined."
msgstr ""

#: src/code/pathname.lisp
msgid ""
"Clear the current definition for the search-list NAME.  Returns T if such\n"
"   a definition existed, and NIL if not."
msgstr ""

#: src/code/pathname.lisp
msgid ""
"Clear the definition for all search-lists.  Only use this if you know\n"
"   what you are doing."
msgstr ""

#: src/code/pathname.lisp
msgid "~S doesn't start with a search-list."
msgstr ""

#: src/code/pathname.lisp
msgid ""
"Return the expansions for the search-list starting PATHNAME.  If PATHNAME\n"
"   does not start with a search-list, then an error is signaled.  If\n"
"   the search-list has not been defined yet, then an error is signaled.\n"
"   The expansion for a search-list can be set with SETF."
msgstr ""

#: src/code/pathname.lisp
msgid "Search list ~S has not been defined yet."
msgstr ""

#: src/code/pathname.lisp
msgid ""
"Returns T if the search-list starting PATHNAME is currently defined, and\n"
"   NIL otherwise.  An error is signaled if PATHNAME does not start with a\n"
"   search-list."
msgstr ""

#: src/code/pathname.lisp
msgid "That would result in a circularity:~%  ~\n"
"		     ~A~{ -> ~A~} -> ~A"
msgstr ""

#: src/code/pathname.lisp
msgid ""
"Search-lists cannot expand into pathnames that have ~\n"
"		       a name, type, or ~%version specified:~%  ~S"
msgstr ""

#: src/code/pathname.lisp
msgid ""
"Execute BODY with VAR bound to each successive possible expansion for\n"
"   PATHNAME and then return RESULT.  Note: if PATHNAME does not contain a\n"
"   search-list, then BODY is executed exactly once.  Everything is wrapped\n"
"   in a block named NIL, so RETURN can be used to terminate early.  Note:\n"
"   VAR is *not* bound inside of RESULT."
msgstr ""

#: src/code/pathname.lisp
msgid "Undefined search list: ~A"
msgstr ""

#: src/code/pathname.lisp
msgid ""
"Logical namestring character ~\n"
"			     is not alphanumeric or hyphen:~%  ~S"
msgstr ""

#: src/code/pathname.lisp
msgid "Logical host not yet defined: ~S"
msgstr ""

#: src/code/pathname.lisp
msgid "Double asterisk inside of logical ~\n"
"				     word: ~S"
msgstr ""

#: src/code/pathname.lisp
msgid "Illegal character for logical pathname:~%  ~S"
msgstr ""

#: src/code/pathname.lisp
msgid "a host name"
msgstr ""

#: src/code/pathname.lisp
msgid "a directory name"
msgstr ""

#: src/code/pathname.lisp
msgid "a file name"
msgstr ""

#: src/code/pathname.lisp
msgid "Expecting a dot, got ~S."
msgstr ""

#: src/code/pathname.lisp
msgid "a file type"
msgstr ""

#: src/code/pathname.lisp
msgid "a positive integer, * or NEWEST"
msgstr ""

#: src/code/pathname.lisp
msgid "Expecting ~A, got ~:[nothing~;~:*~S~]."
msgstr ""

#: src/code/pathname.lisp
msgid "Expected a positive integer, ~\n"
"					    got ~S"
msgstr ""

#: src/code/pathname.lisp
msgid "Extra stuff after end of file name."
msgstr ""

#: src/code/pathname.lisp
msgid "Converts the pathspec argument to a logical-pathname and returns it."
msgstr ""

#: src/code/pathname.lisp
msgid "Logical namestring does not specify a host:~%  ~S"
msgstr ""

#: src/code/filesys.lisp src/code/pathname.lisp
msgid "Invalid directory component: ~S"
msgstr ""

#: src/code/pathname.lisp
msgid "Invalid keyword: ~S"
msgstr ""

#: src/code/pathname.lisp
msgid "Logical pathname translation is not a two-list:~%  ~S"
msgstr ""

#: src/code/pathname.lisp
msgid "Return the (logical) host object argument's list of translations."
msgstr ""

#: src/code/pathname.lisp
msgid ""
"Set the translations list for the logical host argument.\n"
"   Return translations."
msgstr ""

#: src/code/pathname.lisp
msgid "Clobber search-list host with logical pathname host"
msgstr ""

#: src/code/pathname.lisp
msgid "~S names a CMUCL search-list"
msgstr ""

#: src/code/pathname.lisp
msgid ""
"Search for a logical pathname named host, if not already defined. If "
"already\n"
"   defined no attempt to find or load a definition is attempted and NIL is\n"
"   returned. If host is not already defined, but definition is found and "
"loaded\n"
"   successfully, T is returned, else error."
msgstr ""

#: src/code/pathname.lisp
msgid ";; Loading pathname translations from ~A~%"
msgstr ""

#: src/code/pathname.lisp
msgid "Translates pathname to a physical pathname, which is returned."
msgstr ""

#: src/code/pathname.lisp
msgid "No translation for ~S"
msgstr ""

#: src/code/filesys.lisp
msgid ""
"Remove any occurrences of \\ from the string because we've already\n"
"   checked for whatever may have been backslashed."
msgstr ""

#: src/code/filesys.lisp
msgid "Backslash in bad place."
msgstr ""

#: src/code/filesys.lisp
msgid ""
"If non-NIL, Unix shell-style wildcards are ignored when parsing\n"
"  pathname namestrings.  They are also ignored when computing\n"
"  namestrings for pathname objects.  Thus, *, ?, etc. are not\n"
"  wildcards when parsing a namestring, and are not escaped when\n"
"  printing pathnames."
msgstr ""

#: src/code/filesys.lisp
msgid "``['' with no corresponding ``]''"
msgstr ""

#: src/code/filesys.lisp
msgid "~A already names a logical host"
msgstr ""

#: src/code/filesys.lisp
msgid "Invalid pattern piece: ~S"
msgstr ""

#: src/code/filesys.lisp
msgid ":BACK cannot be represented in namestrings."
msgstr ""

#: src/code/filesys.lisp
msgid "Cannot represent \"\" in namestrings."
msgstr ""

#: src/code/filesys.lisp
msgid "Cannot represent an explicit directory separator in namestrings."
msgstr ""

#: src/code/filesys.lisp
msgid "Cannot specify a directory separator in a pathname name: ~S"
msgstr ""

#: src/code/filesys.lisp
msgid "Cannot specify a dot in a pathname name without a pathname type: ~S"
msgstr ""

#: src/code/filesys.lisp
msgid "Invalid value for a pathname name: ~S"
msgstr ""

#: src/code/filesys.lisp
msgid "Cannot specify the type without a file: ~S"
msgstr ""

#: src/code/filesys.lisp
msgid "Cannot specify a directory separator in a pathname type: ~S"
msgstr ""

#: src/code/filesys.lisp
msgid "Cannot specify a dot in a pathname type: ~S"
msgstr ""

#: src/code/filesys.lisp
msgid "Cannot specify a version without a file: ~S"
msgstr ""

#: src/code/filesys.lisp
msgid "~S cannot be represented relative to ~S"
msgstr ""

#: src/code/filesys.lisp
msgid "Cannot supply a type without a name:~%  ~S"
msgstr ""

#: src/code/filesys.lisp
msgid ""
"Convert PATHNAME into a string that can be used with UNIX system calls.\n"
"   Search-lists and wild-cards are expanded. If optional argument\n"
"   FOR-INPUT is true and PATHNAME doesn't exist, NIL is returned.\n"
"   If optional argument EXECUTABLE-ONLY is true, NIL is returned\n"
"   unless an executable version of PATHNAME exists."
msgstr ""

#: src/code/filesys.lisp
msgid "~S is ambiguous:~{~%  ~A~}"
msgstr ""

#: src/code/filesys.lisp
msgid ""
"Return the pathname for the actual file described by the pathname\n"
"  An error of type file-error is signalled if no such file exists,\n"
"  or the pathname is wild."
msgstr ""

#: src/code/filesys.lisp
msgid "Bad place for a wild pathname."
msgstr ""

#: src/code/filesys.lisp
msgid "The file ~S does not exist."
msgstr ""

#: src/code/filesys.lisp
msgid ""
"Return a pathname which is the truename of the file if it exists, NIL\n"
"  otherwise. An error of type file-error is signalled if pathname is wild."
msgstr ""

#: src/code/filesys.lisp
msgid ""
"Rename File to have the specified New-Name.  If file is a stream\n"
"  open to a file, then the associated file is renamed.\n"
"\n"
"  Three values are returned if successful: the defaulted new name\n"
"  composed of New-Name with missing components filled in from File;\n"
"  the truename of File before it was renamed; the new truename of the\n"
"  File after it was renamed."
msgstr ""

#: src/code/filesys.lisp
msgid "~S can't be created."
msgstr ""

#: src/code/filesys.lisp
msgid "Failed to rename ~A to ~A: ~A"
msgstr ""

#: src/code/filesys.lisp
msgid "Delete the specified file."
msgstr ""

#: src/code/filesys.lisp
msgid "~S doesn't exist."
msgstr ""

#: src/code/filesys.lisp
msgid "Could not delete ~A: ~A."
msgstr ""

#: src/code/filesys.lisp
msgid ""
"Delete old versions of files matching the given Pathname,\n"
"optionally keeping some of the most recent old versions."
msgstr ""

#: src/code/filesys.lisp
msgid ""
"Returns the home directory of the logged in user as a pathname.\n"
"  This is obtained from the logical name \"home:\"."
msgstr ""

#: src/code/filesys.lisp
msgid ""
"Return file's creation date, or NIL if it doesn't exist.\n"
" An error of type file-error is signalled if file is a wild pathname"
msgstr ""

#: src/code/filesys.lisp
msgid ""
"Returns the file author as a string, or nil if the author cannot be\n"
" determined.  Signals an error of type file-error if file doesn't exist,\n"
" or file is a wild pathname."
msgstr ""

#: src/code/filesys.lisp
msgid ""
"Returns a list of pathnames, one for each file that matches the given\n"
"   pathname.  Supplying :ALL as nil causes this to ignore Unix dot files.  "
"This\n"
"   never includes Unix dot and dot-dot in the result.  If :TRUENAMEP is NIL,"
"\n"
"   then symbolic links in the result are not expanded, which is not the\n"
"   default because TRUENAME does follow links and the result pathnames are\n"
"   defined to be the TRUENAME of the pathname (the truename of a link may "
"well\n"
"   be in another directory).  If FOLLOW-LINKS is NIL then symbolic links "
"are\n"
"   not followed."
msgstr ""

#: src/code/filesys.lisp
msgid ""
"Like Directory, but prints a terse, multi-column directory listing\n"
"   instead of returning a list of pathnames.  When :all is supplied and\n"
"   non-nil, then Unix dot files are included too (as ls -a).  When :verbose\n"
"   is supplied and non-nil, then a long listing of miscellaneous\n"
"   information is output one file per line."
msgstr ""

#: src/code/filesys.lisp
msgid "Directory of ~A:~%"
msgstr ""

#: src/code/filesys.lisp
msgid "Couldn't stat ~A -- ~A.~%"
msgstr ""

#: src/code/filesys.lisp
msgid ""
"Return a list of all files which are possible completions of Pathname.\n"
"   We look in the directory specified by Defaults as well as looking down\n"
"   the search list."
msgstr ""

#: src/code/filesys.lisp
msgid ""
"File-writable accepts a pathname and returns T if the current\n"
"  process can write it, and NIL otherwise."
msgstr ""

#: src/code/filesys.lisp
msgid ""
"Returns the pathname for the default directory.  This is the place where\n"
"  a file will be written if no directory is specified.  This may be changed\n"
"  with setf."
msgstr ""

#: src/code/filesys.lisp
msgid ""
"Tests whether the directories containing the specified file\n"
"  actually exist, and attempts to create them if they do not.\n"
"  Portable programs should avoid using the :MODE keyword argument."
msgstr ""

#: src/code/filesys.lisp
msgid "~&Creating directory: ~A~%"
msgstr ""

#: src/code/filesys.lisp
msgid "Can't create directory ~A."
msgstr ""

#: src/code/load.lisp
msgid "The default for the :IF-SOURCE-NEWER argument to load."
msgstr ""

#: src/code/load.lisp
msgid "The source file types which LOAD recognizes."
msgstr ""

#: src/code/load.lisp
msgid "A list of the object file types recognized by LOAD."
msgstr ""

#: src/code/load.lisp
msgid ""
"A list of the object file types recognized by LOAD for logical pathnames."
msgstr ""

#: src/code/load.lisp
msgid "The default for the :VERBOSE argument to Load."
msgstr ""

#: src/code/load.lisp
msgid "The default for the :PRINT argument to Load."
msgstr ""

#: src/code/load.lisp
msgid "The TRUENAME of the file that LOAD is currently loading."
msgstr ""

#: src/code/load.lisp
msgid "The defaulted pathname that LOAD is currently loading."
msgstr ""

#: src/code/load.lisp
msgid "Count of the number of recursive loads."
msgstr ""

#: src/code/load.lisp
msgid ""
"~A was compiled for fasl-file version ~X, ~\n"
"                     but this is version ~X"
msgstr ""

#: src/code/load.lisp
msgid "List of free fop tables for the fasloader."
msgstr ""

#: src/code/load.lisp
msgid "The fop stack (we only need one!)."
msgstr ""

#: src/code/load.lisp
msgid "Vector indexed by a FaslOP that yields the FOP's name."
msgstr ""

#: src/code/load.lisp
msgid ""
"Vector indexed by a FaslOP that yields a function of 0 arguments which\n"
"  will perform the operation."
msgstr ""

#: src/code/load.lisp
msgid "Losing FOP!"
msgstr ""

#: src/code/load.lisp
msgid "Loading ~S.~%"
msgstr ""

#: src/code/load.lisp
msgid "Loading stuff from ~S.~%"
msgstr ""

#: src/code/load.lisp
msgid "Attempt to load an empty FASL FILE:~%  ~S"
msgstr ""

#: src/code/load.lisp
msgid "Bad FASL file format."
msgstr ""

#: src/code/load.lisp
msgid ""
"Loads the file named by Filename into the Lisp environment.  The file type\n"
"   (a.k.a extension) is defaulted if missing.  These options are defined:\n"
"\n"
"   :IF-SOURCE-NEWER <keyword>\n"
"	If the file type is not specified, and both source and object files\n"
"        exist, then this argument controls which is loaded:\n"
"	    :LOAD-OBJECT - load object file (default),\n"
"	    :LOAD-SOURCE - load the source file,\n"
"	    :COMPILE - compile the source and then load the object file, or\n"
"	    :QUERY - ask the user which to load.\n"
"\n"
"   :IF-DOES-NOT-EXIST {:ERROR | NIL}\n"
"       If :ERROR (the default), signal an error if the file can't be "
"located.\n"
"       If NIL, simply return NIL (LOAD normally returns T.)\n"
"\n"
"   :VERBOSE {T | NIL}\n"
"       If true (the default), print a line describing each file loaded.\n"
"\n"
"   :PRINT {T | NIL}\n"
"       If true, print information about loaded values.  When loading the\n"
"       source, the result of evaluating each top-level form is printed.\n"
"\n"
"   :CONTENTS {NIL | :SOURCE | :BINARY}\n"
"       Forces the input to be interpreted as a source or object file, "
"instead\n"
"       of guessing based on the file type.  This also inhibits file type\n"
"       defaulting.  Probably only necessary if you have source files with a\n"
"       \"fasl\" type. \n"
"\n"
"   :EXTERNAL-FORMAT\n"
"       The external-format to use when opening the FILENAME. The default is\n"
"       :default which uses the EXT:*DEFAULT-EXTERNAL-FORMAT*.\n"
"\n"
"   The variables *LOAD-VERBOSE*, *LOAD-PRINT* and EXT:*LOAD-IF-SOURCE-NEWER"
"*\n"
"   determine the defaults for the corresponding keyword arguments.  These\n"
"   variables are also bound to the specified argument values, so specifying "
"a\n"
"   keyword affects nested loads.  The variables EXT:*LOAD-SOURCE-TYPES*,\n"
"   EXT:*LOAD-OBJECT-TYPES*, and EXT:*LOAD-LP-OBJECT-TYPES* determine the "
"file\n"
"   types that we use for defaulting when none is specified."
msgstr ""

#: src/code/load.lisp
msgid "Return NIL from load of ~S."
msgstr ""

#: src/code/load.lisp
msgid "~S does not exist."
msgstr ""

#: src/code/load.lisp
msgid "See if it exists now."
msgstr ""

#: src/code/load.lisp
msgid "Prompt for a new name."
msgstr ""

#: src/code/load.lisp
msgid "New name: "
msgstr ""

#: src/code/load.lisp
msgid "Load it as a source file."
msgstr ""

#: src/code/load.lisp
msgid "File has a fasl file type, but no fasl file header:~%  ~S"
msgstr ""

#: src/code/load.lisp
msgid ""
"Loading object file ~A,~@\n"
"		  which is older than the presumed source:~%  ~A."
msgstr ""

#: src/code/load.lisp
msgid ""
"Loading source file ~A,~@\n"
"		  which is newer than the presumed object file:~%  ~A."
msgstr ""

#: src/code/load.lisp
msgid "Compile of source failed, cannot load object."
msgstr ""

#: src/code/load.lisp
msgid "Object file ~A is~@\n"
"		       older than the presumed source:~%  ~A."
msgstr ""

#: src/code/load.lisp
msgid "load source file"
msgstr ""

#: src/code/load.lisp
msgid "load object file"
msgstr ""

#: src/code/load.lisp
msgid "Fop-End-Header was executed???"
msgstr ""

#: src/code/load.lisp
msgid "Fasl table of improper size.  Bug!"
msgstr ""

#: src/code/load.lisp
msgid "Fasl stack not empty.  Bug!"
msgstr ""

#: src/code/load.lisp
msgid "The package ~S does not exist."
msgstr ""

#: src/code/load.lisp
msgid "Losing i-vector element size: ~S"
msgstr ""

#: src/code/load.lisp
msgid "Load ~A anyway"
msgstr ""

#: src/code/load.lisp
msgid "~A was compiled for a ~A, but this is a ~A"
msgstr ""

#: src/compiler/generic/core.lisp src/code/load.lisp
msgid "Unaligned function object, offset = #x~X."
msgstr ""

#: src/code/load.lisp
msgid "~S defined~%"
msgstr ""

#: src/code/load.lisp
msgid "Cannot load assembler code."
msgstr ""

#: src/compiler/generic/core.lisp src/code/load.lisp
msgid "Undefined assembler routine: ~S"
msgstr ""

#: src/code/foreign-linkage.lisp
msgid "~A is not defined as a foreign symbol"
msgstr ""

#: src/code/module.lisp
msgid ""
"This is a list of module names that have been loaded into Lisp so far.\n"
"   It is used by PROVIDE and REQUIRE."
msgstr ""

#: src/code/module.lisp
msgid "*load-verbose* is bound to this before loading files."
msgstr ""

#: src/code/module.lisp
msgid "See function documentation for REQUIRE"
msgstr ""

#: src/code/module.lisp
msgid ""
"Defines a module by registering the files that need to be loaded when\n"
"   the module is required.  If name is a symbol, its print name is used\n"
"   after downcasing it."
msgstr ""

#: src/code/module.lisp
msgid ""
"Adds a new module name to *modules* indicating that it has been\n"
"  loaded.  Module-name may be any valid string designator.  All\n"
"  comparisons are done using string=, i.e. module names are\n"
"  case-sensitive."
msgstr ""

#: src/code/module.lisp
msgid ""
"Loads a module when it has not been already.  Pathname, if\n"
"  supplied, is a single pathname or list of pathnames to be loaded if\n"
"  the module needs to be.  If pathname is not supplied, then functions\n"
"  from the list *MODULE-PROVIDER-FUNCTIONS* are called in order with\n"
"  the stringified MODULE-NAME as the argument, until one of them\n"
"  returns non-NIL.  By default the functions\n"
"  MODULE-PROVIDE-CMUCL-DEFMODULE and MODULE-PROVIDE- CMUCL-LIBRARY are\n"
"  on this list of functions, in that order.  The first of those looks\n"
"  for a list of files that was registered by a EXT:DEFMODULE form.  If\n"
"  the module has not been defined, then the second function causes a\n"
"  file to be loaded whose name is formed by merging \"modules:\" and\n"
"  the concatenation of module-name with the suffix \"-LIBRARY\".  Note\n"
"  that both the module-name and the suffix are each, separately,\n"
"  converted from :case :common to :case :local.  This merged name will\n"
"  be probed with both a .lisp and .fasl extensions, calling LOAD if it\n"
"  exists.\n"
"\n"
"  Note that in all cases covered above, user code is responsible for\n"
"  calling PROVIDE to indicate a successful load of the module.\n"
"\n"
"  While loading any files, *load-verbose* is bound to *require-verbose*\n"
"  which defaults to t.\n"
"\n"
"  The predefined modules included are :defsystem, :asdf, :lisp-unit,\n"
"  :unix, :clx, :clm, :hemlock, and :cmu-contribs.\n"
"\n"
"  The module :cmu-contribs differs from the other modules in that\n"
"  requiring this module only defines the following modules:\n"
"  \"contrib-demos\", \"contrib-follow-mouse\",\n"
"  \"contrib-games-feebs\", \"contrib-hist\", \"contrib-psgraph\",\n"
"  \"contrib-ops\", \"contrib-embedded-c\", \"contrib-sprof\", and\n"
"  \"contrib-packed-sse2\". "
msgstr ""

#: src/code/module.lisp
msgid "Don't know how to load ~A"
msgstr ""

#: src/code/module.lisp
msgid "Coerce a string designator to a module name."
msgstr ""

#: src/code/module.lisp
msgid ""
"Derive a default pathname to try to load for an undefined module\n"
"  named module-name.  The default pathname is constructed from the\n"
"  module-name by appending the suffix \"-LIBRARY\" to it, and merging\n"
"  with \"modules:\".  Note that both the module-name and the suffix\n"
"  are each, separately, converted from :case :common to :case :local."
msgstr ""

#: src/code/eval.lisp
msgid ""
"Keywords that you can put in a lambda-list, supposing you should want\n"
"  to do such a thing."
msgstr ""

#: src/code/eval.lisp
msgid ""
"The exclusive upper bound on the number of arguments which may be passed\n"
"  to a function, including rest args."
msgstr ""

#: src/code/eval.lisp
msgid ""
"The exclusive upper bound on the number of parameters which may be specifed\n"
"  in a given lambda list.  This is actually the limit on required and "
"optional\n"
"  parameters.  With &key and &aux you can get more."
msgstr ""

#: src/code/eval.lisp
msgid ""
"The exclusive upper bound on the number of multiple-values that you can\n"
"  have."
msgstr ""

#: src/code/eval.lisp
msgid ""
"This variable controls whether assignments to unknown variables at top-level"
"\n"
"   (or in any other call to EVAL of SETQ) will implicitly declare the "
"variable\n"
"   SPECIAL.  These values are meaningful:\n"
"     :WARN  -- Print a warning, but declare the variable special (the "
"default.)\n"
"      T     -- Quietly declare the variable special.\n"
"      NIL   -- Never declare the variable, giving warnings on each use."
msgstr ""

#: src/code/eval.lisp
msgid ""
"Evaluates its single arg in a null lexical environment, returns the\n"
"  result or results."
msgstr ""

#: src/code/eval.lisp
msgid "Wrong number of args to FUNCTION:~% ~S."
msgstr ""

#: src/code/eval.lisp
msgid "~S is a macro."
msgstr ""

#: src/code/eval.lisp
msgid "~S is a special operator."
msgstr ""

#: src/code/eval.lisp
msgid "Wrong number of args to QUOTE:~% ~S."
msgstr ""

#: src/code/eval.lisp
msgid "Odd number of args to SETQ:~% ~S."
msgstr ""

#: src/code/eval.lisp
msgid "Declaring ~S special."
msgstr ""

#: src/compiler/ir1tran.lisp src/code/eval.lisp
msgid "Bad Eval-When situation list: ~S."
msgstr ""

#: src/code/eval.lisp
msgid ""
"Attempt to evaluation a complex expression:~%     ~S~@\n"
"	  This expression must be compiled, but the compiler is not loaded."
msgstr ""

#: src/code/eval.lisp
msgid ""
"EVAL called on #'(lambda (x) ...) when the compiler isn't loaded:~\n"
"	  ~%     ~S~%"
msgstr ""

#: src/code/eval.lisp
msgid ""
"Given a function, return three values:\n"
"   1] A lambda expression that could be used to define the function, or NIL "
"if\n"
"      the definition isn't available.\n"
"   2] NIL if the function was definitely defined in a null lexical environme"
"nt,\n"
"      and T otherwise.\n"
"   3] Some object that \"names\" the function.  Although this is allowed to "
"be\n"
"      any object, CMU CL always returns a valid function name or a string."
msgstr ""

#: src/code/eval.lisp
msgid "If the symbol globally names a special form, returns T, otherwise NIL."
msgstr ""

#: src/code/eval.lisp
msgid ""
"The value of this variable must be a function that can take three\n"
"  arguments, a macro expander function, the macro form to be expanded,\n"
"  and the lexical environment to expand in.  The function should\n"
"  return the expanded form.  This function is called by MACROEXPAND-1\n"
"  whenever a runtime expansion is needed.  Initially this is set to\n"
"  FUNCALL."
msgstr ""

#: src/code/eval.lisp
msgid ""
"Invoke *MACROEXPAND-HOOK* on FUN, FORM, and ENV after coercing it to\n"
"   a function."
msgstr ""

#: src/code/eval.lisp
msgid ""
"If SYMBOL names a macro in ENV, returns the expansion function,\n"
"   else returns NIL.  If ENV is unspecified or NIL, use the global\n"
"   environment only."
msgstr ""

#: src/code/eval.lisp
msgid "~S names a special form."
msgstr ""

#: src/code/eval.lisp
msgid "Cannot funcall macro functions."
msgstr ""

#: src/code/eval.lisp
msgid ""
"If form is a macro (or symbol macro), expands it once.  Returns two values,\n"
"   the expanded form and a T-or-NIL flag indicating whether the form was, "
"in\n"
"   fact, a macro.  Env is the lexical environment to expand in, which "
"defaults\n"
"   to the null environment."
msgstr ""

#: src/code/eval.lisp
msgid ""
"Repetitively call MACROEXPAND-1 until the form can no longer be expanded.\n"
"   Returns the final resultant form, and T if it was expanded.  ENV is the\n"
"   lexical environment to expand in, or NIL (the default) for the null\n"
"   environment."
msgstr ""

#: src/code/eval.lisp
msgid ""
"If NAME names a compiler-macro, returns the expansion function,\n"
"   else returns NIL.  Note: if the name is shadowed in ENV by a local\n"
"   definition, or declared NOTINLINE, NIL is returned.  Can be\n"
"   set with SETF."
msgstr ""

#: src/code/eval.lisp
msgid ""
"If FORM is a function call for which a compiler-macro has been defined,\n"
"   invoke the expander function using *macroexpand-hook* and return the\n"
"   results and T.  Otherwise, return the original form and NIL."
msgstr ""

#: src/code/eval.lisp
msgid ""
"Repetitively call COMPILER-MACROEXPAND-1 until the form can no longer be\n"
"   expanded.  ENV is the lexical environment to expand in, or NIL (the\n"
"   default) for the null environment."
msgstr ""

#: src/code/eval.lisp
msgid ""
"True of any Lisp object that has a constant value: types that eval to\n"
"  themselves, keywords, constants, and list whose car is QUOTE."
msgstr ""

#: src/code/eval.lisp
msgid ""
"Applies FUNCTION to a list of arguments produced by evaluating ARGS in\n"
"  the manner of LIST*.  That is, a list is made of the values of all but "
"the\n"
"  last argument, appended to the value of the last argument, which must be "
"a\n"
"  list."
msgstr ""

#: src/code/eval.lisp
msgid "Calls Function with the given Arguments."
msgstr ""

#: src/code/eval.lisp
msgid "Returns all of its arguments, in order, as values."
msgstr ""

#: src/code/eval.lisp
msgid "Returns all of the elements of List, in order, as values."
msgstr ""

#: src/code/signal.lisp
msgid "A list of unix signal structures."
msgstr ""

#: src/code/signal.lisp
msgid "~S is not a valid signal name or number."
msgstr ""

#: src/code/signal.lisp
msgid ""
"Return the name of the signal as a string.  Signal should be a valid\n"
"  signal number or a keyword of the standard UNIX signal name."
msgstr ""

#: src/code/signal.lisp
msgid ""
"Return a string describing signal.  Signal should be a valid signal\n"
"  number or a keyword of the standard UNIX signal name."
msgstr ""

#: src/code/signal.lisp
msgid ""
"Return the number of the given signal.  Signal should be a valid\n"
"  signal number or a keyword of the standard UNIX signal name."
msgstr ""

#: src/code/signal.lisp
msgid "Check"
msgstr ""

#: src/code/signal.lisp
msgid "Hangup"
msgstr ""

#: src/code/signal.lisp
msgid "Interrupt"
msgstr ""

#: src/code/signal.lisp
msgid "Quit"
msgstr ""

#: src/code/signal.lisp
msgid "Illegal instruction"
msgstr ""

#: src/code/signal.lisp
msgid "Trace trap"
msgstr ""

#: src/code/signal.lisp
msgid "Iot instruction"
msgstr ""

#: src/code/signal.lisp
msgid "C abort()"
msgstr ""

#: src/code/signal.lisp
msgid "Floating point exception"
msgstr ""

#: src/code/signal.lisp
msgid "Kill"
msgstr ""

#: src/code/signal.lisp
msgid "Bus error"
msgstr ""

#: src/code/signal.lisp
msgid "Segmentation violation"
msgstr ""

#: src/code/signal.lisp
msgid "Write on a pipe with no one to read it"
msgstr ""

#: src/code/signal.lisp
msgid "Alarm clock"
msgstr ""

#: src/code/signal.lisp
msgid "Software termination signal"
msgstr ""

#: src/code/signal.lisp
msgid "Urgent condition present on socket"
msgstr ""

#: src/code/signal.lisp
msgid "Stop"
msgstr ""

#: src/code/signal.lisp
msgid "Stop signal generated from keyboard"
msgstr ""

#: src/code/signal.lisp
msgid "Continue after stop"
msgstr ""

#: src/code/signal.lisp
msgid "Child status has changed"
msgstr ""

#: src/code/signal.lisp
msgid "Background read attempted from control terminal"
msgstr ""

#: src/code/signal.lisp
msgid "Background write attempted to control terminal"
msgstr ""

#: src/code/signal.lisp
msgid "I/O is possible on a descriptor"
msgstr ""

#: src/code/signal.lisp
msgid "Cpu time limit exceeded"
msgstr ""

#: src/code/signal.lisp
msgid "File size limit exceeded"
msgstr ""

#: src/code/signal.lisp
msgid "Virtual time alarm"
msgstr ""

#: src/code/signal.lisp
msgid "Profiling timer alarm"
msgstr ""

#: src/code/signal.lisp
msgid "Window size change"
msgstr ""

#: src/code/signal.lisp
msgid "User defined signal 1"
msgstr ""

#: src/code/signal.lisp
msgid "User defined signal 2"
msgstr ""

#: src/code/signal.lisp
msgid "Returns a mask given a set of signals."
msgstr ""

#: src/code/signal.lisp
msgid ""
"Unix-kill sends the signal signal to the process with process \n"
"   id pid.  Signal should be a valid signal number or a keyword of the\n"
"   standard UNIX signal name."
msgstr ""

#: src/code/signal.lisp
msgid ""
"Unix-killpg sends the signal signal to the all the process in process\n"
"  group PGRP.  Signal should be a valid signal number or a keyword of\n"
"  the standard UNIX signal name."
msgstr ""

#: src/code/signal.lisp
msgid ""
"Unix-sigblock cause the signals specified in mask to be\n"
"   added to the set of signals currently being blocked from\n"
"   delivery.  The macro sigmask is provided to create masks."
msgstr ""

#: src/code/signal.lisp
msgid ""
"Unix-sigpause sets the set of masked signals to its argument\n"
"   and then waits for a signal to arrive, restoring the previous\n"
"   mask upon its return."
msgstr ""

#: src/code/signal.lisp
msgid ""
"Unix-sigsetmask sets the current set of masked signals (those\n"
"   being blocked from delivery) to the argument.  The macro sigmask\n"
"   can be used to create the mask.  The previous value of the signal\n"
"   mask is returned."
msgstr ""

#: src/code/signal.lisp
msgid "Enable all the default signals that Lisp knows how to deal with."
msgstr ""

#: src/code/signal.lisp
msgid "Execute BODY in a context impervious to interrupts."
msgstr ""

#: src/code/signal.lisp
msgid ""
"Allow interrupts while executing BODY.  As interrupts are normally allowed,\n"
"  this is only useful inside a WITHOUT-INTERRUPTS."
msgstr ""

#: src/code/signal.lisp
msgid ""
"With-enabled-interrupts ({(interrupt function)}*) {form}*\n"
"   Establish function as a handler for the Unix signal interrupt which\n"
"   should be a number between 1 and 31 inclusive."
msgstr ""

#: src/code/interr.lisp
msgid "Unknown error:~{ ~S~})"
msgstr ""

#: src/code/interr.lisp
msgid "Invalid number of arguments: ~S"
msgstr ""

#: src/code/interr.lisp
msgid "Attempt to use VALUES-LIST on a dotted-list:~%  ~S"
msgstr ""

#: src/code/interr.lisp
msgid "Attempt to RETURN-FROM a block or GO to a tag that no longer exists"
msgstr ""

#: src/code/interr.lisp
msgid "Attempt to THROW to a tag that does not exist: ~S"
msgstr ""

#: src/code/interr.lisp
msgid "Function with declared result type NIL returned:~%  ~S"
msgstr ""

#: src/code/interr.lisp
msgid "Invalid array index, ~D for ~S.  Array has no elements."
msgstr ""

#: src/code/interr.lisp
msgid ""
"Invalid array index, ~D for ~S.  Should have greater than or equal to 0."
msgstr ""

#: src/code/interr.lisp
msgid "Invalid array index, ~D for ~S.  Should have been less than ~D"
msgstr ""

#: src/code/interr.lisp
msgid "Undefined foreign symbol: ~S"
msgstr ""

#: src/code/interr.lisp
msgid ""
"The maximum number of nested errors allowed.  Internal errors are\n"
"   double-counted."
msgstr ""

#: src/code/interr.lisp
msgid "The current number of nested errors."
msgstr ""

#: src/code/interr.lisp
msgid "Unknown internal error, ~D?  args=~S"
msgstr ""

#: src/code/interr.lisp
msgid "Internal error ~D: ~A.  args=~S"
msgstr ""

#: src/code/interr.lisp
msgid ""
"~2&~@<A control stack overflow has occurred:~%~\n"
"            the program has entered the yellow control stack guard zone.~%~\n"
"            Please note that you will be returned to the Top-Level if "
"you~%~\n"
"            enter the red control stack guard zone while debugging.~@:>~2%"
msgstr ""

#: src/code/interr.lisp
msgid ""
"~2&~@<Fatal control stack overflow.  You have entered~%~\n"
"           the red control stack guard zone while debugging.~%~\n"
"           Returning to Top-Level.~@:>~2%"
msgstr ""

#: src/code/interr.lisp
msgid ""
"~2&~@<Imminent dynamic space overflow has occurred:~%~\n"
"            Only a small amount of dynamic space is available now.~%~\n"
"            Please note that you will be returned to the Top-Level "
"without~%~\n"
"            warning if you run out of space while debugging.~@:>~%"
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"All debug-conditions inherit from this type.  These are serious conditions\n"
"    that must be handled, but they are not programmer errors."
msgstr ""

#: src/code/debug-int.lisp
msgid "There is absolutely no debugging information available."
msgstr ""

#: src/code/debug-int.lisp
msgid "No debugging information available."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"The system could not return values from a frame with debug-function since\n"
"    it lacked information about returning values."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"~&Cannot return values from ~:[frame~;~:*~S~] since ~\n"
"			the debug information lacks details about returning ~\n"
"			values here."
msgstr ""

#: src/code/debug-int.lisp
msgid "The debug-function has no debug-block information."
msgstr ""

#: src/code/debug-int.lisp
msgid "~&~S has no debug-block information."
msgstr ""

#: src/code/debug-int.lisp
msgid "The debug-function has no debug-variable information."
msgstr ""

#: src/code/debug-int.lisp
msgid "~&~S has no debug-variable information."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"The debug-function has no lambda-list since argument debug-variables are\n"
"    unavailable."
msgstr ""

#: src/code/debug-int.lisp
msgid "~&~S has no lambda-list information available."
msgstr ""

#: src/code/debug-int.lisp
msgid "~&~S has :invalid or :unknown value in ~S."
msgstr ""

#: src/code/debug-int.lisp
msgid "~&~S names more than one valid variable in ~S."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"All programmer errors from using the interface for building debugging\n"
"    tools inherit from this type."
msgstr ""

#: src/code/debug-int.lisp
msgid "~&Unhandled debug-condition:~%~A"
msgstr ""

#: src/code/debug-int.lisp
msgid "~&Invalid use of an unknown code-location -- ~S."
msgstr ""

#: src/code/debug-int.lisp
msgid "~&~S not in ~S."
msgstr ""

#: src/code/debug-int.lisp
msgid "Invalid control stack pointer."
msgstr ""

#: src/code/debug-int.lisp
msgid "~&Form was preprocessed for ~S,~% but called on ~S:~%  ~S"
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the name of the debug-variable.  The name is the name of the symbol\n"
"   used as an identifier when writing the code."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the package name of the debug-variable.  This is the package name "
"of\n"
"   the symbol used as an identifier when writing the code."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the integer that makes debug-variable's name and package name "
"unique\n"
"   with respect to other debug-variable's in the same function."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the frame immediately above frame on the stack.  When frame is\n"
"   the top of the stack, this returns nil."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the debug-function for the function whose call frame represents."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the code-location where the frame's debug-function will continue\n"
"   running when program execution returns to this frame.  If someone\n"
"   interrupted this frame, the result could be an unknown code-location."
msgstr ""

#: src/code/debug-int.lisp
msgid "#<Compiled-Frame ~S~:[~;, interrupted~]>"
msgstr ""

#: src/code/debug-int.lisp
msgid "#<~A-Debug-Function ~S>"
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the list of possible code-locations where execution may continue\n"
"   when the basic-block represented by debug-block completes its execution."
msgstr ""

#: src/code/debug-int.lisp
msgid "Returns whether debug-block represents elsewhere code."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the breakpoint's function the system calls when execution encounters"
"\n"
"   the breakpoint, and it is active.  This is SETF'able."
msgstr ""

#: src/code/debug-int.lisp
msgid "Returns the breakpoint's what specification."
msgstr ""

#: src/code/debug-int.lisp
msgid "Returns the breakpoint's kind specification."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the debug-function representing information about the function\n"
"   corresponding to the code-location."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the number of top-level forms processed by the compiler before\n"
"   compiling this source.  If this source is uncompiled, this is zero.  "
"This\n"
"   may be zero even if the source is compiled since the first form in the "
"first\n"
"   file compiled in one compilation, for example, must have a root number "
"of\n"
"   zero -- the compiler saw no other top-level forms before it."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns an indication of the type of source.  The following are the possible"
"\n"
"   values:\n"
"      :file    from a file (obtained by COMPILE-FILE if compiled).\n"
"      :lisp    from Lisp (obtained by COMPILE if compiled).\n"
"      :stream  from a non-file stream."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the actual source in some sense represented by debug-source, which\n"
"   is related to DEBUG-SOURCE-FROM:\n"
"      :file    the pathname of the file.\n"
"      :lisp    a lambda-expression.\n"
"      :stream  some descriptive string that's otherwise useless."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the universal time someone created the source.  This may be nil if\n"
"   it is unavailable."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the time someone compiled the source.  This is nil if the source\n"
"   is uncompiled."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"This function returns the file position of each top-level form as an array\n"
"   if debug-source is from a :file.  If DEBUG-SOURCE-FROM is :lisp or "
":stream,\n"
"   this returns nil."
msgstr ""

#: src/code/debug-int.lisp
msgid "Returns whether object is a debug-source."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the top frame of the control stack as it was before calling this\n"
"   function."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Flush all of the frames above FRAME, and renumber all the frames below\n"
"   FRAME."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the frame immediately below frame on the stack.  When frame is\n"
"   the bottom of the stack, this returns nil."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"When set, the debugger foregoes making interpreted-frames, so you can\n"
"   debug the functions that manifest the interpreter."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Zero or more than one ~A variable in ~\n"
"			   EVAL::INTERNAL-APPLY-LOOP?"
msgstr ""

#: src/code/debug-int.lisp
msgid "Return a string describing the foreign function near ADDRESS"
msgstr ""

#: src/code/debug-int.lisp
msgid "Foreign function call land"
msgstr ""

#: src/code/debug-int.lisp
msgid "Return t if COMPONENT contains code from assembly routines."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Return the name of the assembly routine at offset PC in COMPONENT.\n"
"The result is a symbol or nil if the routine cannot be found."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns an a-list mapping catch tags to code-locations.  These are\n"
"   code-locations at which execution would continue with frame as the top\n"
"   frame if someone threw to the corresponding tag."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Executes the forms in a context with block-var bound to each debug-block in\n"
"   debug-function successively.  Result is an optional form to execute for\n"
"   return values, and DO-DEBUG-FUNCTION-BLOCKS returns nil if there is no\n"
"   result form.  This signals a no-debug-blocks condition when the\n"
"   debug-function lacks debug-block information."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Executes body in a context with var bound to each debug-variable in\n"
"   debug-function.  This returns the value of executing result (defaults to\n"
"   nil).  This may iterate over only some of debug-function's variables or "
"none\n"
"   depending on debug policy; for example, possibly the compilation only\n"
"   preserved argument information."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the Common Lisp function associated with the debug-function.  This\n"
"   returns nil if the function is unavailable or is non-existent as a user\n"
"   callable function object."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the name of the function represented by debug-function.  This may\n"
"   be a string or a cons; do not assume it is a symbol."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns a debug-function that represents debug information for function."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the kind of the function which is one of :optional, :external,\n"
"   :top-level, :cleanup, nil."
msgstr ""

#: src/code/debug-int.lisp
msgid "Returns whether there is any variable information for debug-function."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns a list of debug-variables in debug-function having the same name\n"
"   and package as symbol.  If symbol is uninterned, then this returns a "
"list of\n"
"   debug-variables without package names and with the same name as symbol.  "
"The\n"
"   result of this function is limited to the availability of variable\n"
"   information in debug-function; for example, possibly debug-function only\n"
"   knows about its arguments."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns a list of debug-variables in debug-function whose names contain\n"
"    name-prefix-string as an intial substring.  The result of this function "
"is\n"
"    limited to the availability of variable information in debug-function; "
"for\n"
"    example, possibly debug-function only knows about its arguments."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns a list representing the lambda-list for debug-function.  The list\n"
"   has the following structure:\n"
"      (required-var1 required-var2\n"
"       ...\n"
"       (:optional var3 suppliedp-var4)\n"
"       (:optional var5)\n"
"       ...\n"
"       (:rest var6) (:rest var7)\n"
"       ...\n"
"       (:keyword keyword-symbol var8 suppliedp-var9)\n"
"       (:keyword keyword-symbol var10)\n"
"       ...\n"
"      )\n"
"   Each VARi is a debug-variable; however it may be the symbol :deleted it\n"
"   is unreferenced in debug-function.  This signals a lambda-list-unavaliabl"
"e\n"
"   condition when there is no argument list information."
msgstr ""

#: src/code/debug-int.lisp
msgid "Malformed arguments description."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns whether basic-code-location is unknown.  It returns nil when the\n"
"   code-location is known."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the debug-block containing code-location if it is available.  Some\n"
"   debug policies inhibit debug-block information, and if none is available,"
"\n"
"   then this signals a no-debug-blocks condition."
msgstr ""

#: src/code/debug-int.lisp
msgid "Returns the code-location's debug-source."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the number of top-level forms before the one containing\n"
"   code-location as seen by the compiler in some compilation unit.  A\n"
"   compilation unit is not necessarily a single file, see the section on\n"
"   debug-sources."
msgstr ""

#: src/code/debug-int.lisp
msgid "Unknown code location?  It should be known."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the number of the form corresponding to code-location.  The form\n"
"   number is derived by a walking the subforms of a top-level form in\n"
"   depth-first order."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Return the kind of CODE-LOCATION, one of:\n"
"     :interpreted, :unknown-return, :known-return, :internal-error,\n"
"     :non-local-exit, :block-start, :call-site, :single-value-return,\n"
"     :non-local-entry"
msgstr ""

#: src/code/debug-int.lisp
msgid "Returns whether obj1 and obj2 are the same place in the code."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Executes forms in a context with code-var bound to each code-location in\n"
"   debug-block.  This returns the value of executing result (defaults to "
"nil)."
msgstr ""

#: src/code/debug-int.lisp
msgid "??? Can't get name of debug-block's function."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the symbol from interning DEBUG-VARIABLE-NAME in the package named\n"
"   by DEBUG-VARIABLE-PACKAGE."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the value stored for debug-variable in frame.  If the value is not\n"
"   :valid, then this signals an invalid-value error."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns the value stored for debug-variable in frame.  The value may be\n"
"   invalid.  This is SETF'able."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Returns three values reflecting the validity of debug-variable's value\n"
"   at basic-code-location:\n"
"      :valid    The value is known to be available.\n"
"      :invalid  The value is known to be unavailable.\n"
"      :unknown  The value's availability is unknown."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"This returns a table mapping form numbers to source-paths.  A source-path\n"
"   indicates a descent into the top-level-form form, going directly to the\n"
"   subform corressponding to the form number."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Form is a top-level form, and path is a source-path into it.  This returns\n"
"   the form indicated by the source-path.  Context is the number of enclosin"
"g\n"
"   forms to return instead of directly returning the source-path form.  "
"When\n"
"   context is non-zero, the form returned contains a marker, #:****HERE****,"
"\n"
"   immediately before the form indicated by path."
msgstr ""

#: src/code/debug.lisp src/code/debug-int.lisp
msgid "Source path no longer exists."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Return a function of one argument that evaluates form in the lexical\n"
"   context of the basic-code-location loc.  PREPROCESS-FOR-EVAL signals a\n"
"   no-debug-variables condition when the loc's debug-function has no\n"
"   debug-variable information available.  The returned function takes the "
"frame\n"
"   to get values from as its argument, and it returns the values of form.\n"
"   The returned function signals the following conditions: invalid-value,\n"
"   ambiguous-variable-name, and frame-function-mismatch"
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Evaluate Form in the lexical context of Frame's current code location,\n"
"   returning the results of the evaluation."
msgstr ""

#: src/code/debug-int.lisp
msgid "Find and return the debug catch tag for a given frame, if it exists."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Evaluate Form in the lexical context of Frame's current code location,\n"
"   returning from the current frame the results of the evaluation."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"This creates and returns a breakpoint.  When program execution encounters\n"
"   the breakpoint, the system calls hook-function.  Hook-function takes the\n"
"   current frame for the function in which the program is running and the\n"
"   breakpoint object.\n"
"      What and kind determine where in a function the system invokes\n"
"   hook-function.  What is either a code-location or a debug-function.  "
"Kind is\n"
"   one of :code-location, :function-start, or :function-end.  Since the "
"starts\n"
"   and ends of functions may not have code-locations representing them,\n"
"   designate these places by supplying what as a debug-function and kind\n"
"   indicating the :function-start or :function-end.  When what is a\n"
"   debug-function and kind is :function-end, then hook-function must take "
"two\n"
"   additional arguments, a list of values returned by the function and a\n"
"   function-end-cookie.\n"
"      Info is information supplied by and used by the user.\n"
"      Function-end-cookie is a function.  To implement :function-end "
"breakpoints,\n"
"   the system uses starter breakpoints to establish the :function-end "
"breakpoint\n"
"   for each invocation of the function.  Upon each entry, the system "
"creates a\n"
"   unique cookie to identify the invocation, and when the user supplies a\n"
"   function for this argument, the system invokes it on the frame and the\n"
"   cookie.  The system later invokes the :function-end breakpoint hook on "
"the\n"
"   same cookie.  The user may save the cookie for comparison in the hook\n"
"   function.\n"
"      This signals an error if what is an unknown code-location."
msgstr ""

#: src/code/debug-int.lisp
msgid "Cannot make a breakpoint at an unknown code location -- ~S."
msgstr ""

#: src/code/debug-int.lisp
msgid "Breakpoints in interpreted code are currently unsupported."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
":FUNCTION-END breakpoints are currently unsupported ~\n"
"		       for the known return convention."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
":function-end breakpoints are currently unsupported ~\n"
"	     for interpreted-debug-functions."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"This takes a function-end-cookie and a frame, and it returns whether the\n"
"   cookie is still valid.  A cookie becomes invalid when the frame that\n"
"   established the cookie has exited.  Sometimes cookie holders are unaware\n"
"   of cookie invalidation because their :function-end breakpoint hooks didn'"
"t\n"
"   run due to THROW'ing.  This takes a frame as an efficiency hack since "
"the\n"
"   user probably has a frame object in hand when using this routine, and it\n"
"   saves repeated parsing of the stack and consing when asking whether a\n"
"   series of cookies is valid."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"This causes the system to invoke the breakpoint's hook-function until the\n"
"   next call to DEACTIVATE-BREAKPOINT or DELETE-BREAKPOINT.  The system "
"invokes\n"
"   breakpoint hook functions in the opposite order that you activate them."
msgstr ""

#: src/code/debug-int.lisp
msgid "Cannot activate a deleted breakpoint -- ~S."
msgstr ""

#: src/code/debug-int.lisp
msgid "I don't know how you made this, but they're unsupported -- ~S"
msgstr ""

#: src/code/debug-int.lisp
msgid "This stops the system from invoking the breakpoint's hook-function."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"This returns the user maintained info associated with breakpoint.  This\n"
"   is SETF'able."
msgstr ""

#: src/code/debug-int.lisp
msgid "This returns whether breakpoint is currently active."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"This frees system storage and removes computational overhead associated "
"with\n"
"   breakpoint.  After calling this, breakpoint is completely impotent and "
"can\n"
"   never become active again."
msgstr ""

#: src/code/debug-int.lisp
msgid "Unknown breakpoint in ~S at offset ~S."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Make a bogus LRA object that signals a breakpoint trap when returned to.  "
"If\n"
"   the breakpoint trap handler returns, REAL-LRA is returned to.  Three "
"values\n"
"   are returned: the bogus LRA object, the code component it is part of, "
"and\n"
"   the PC offset for the trap instruction."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"The editor calls this remotely in the slave to set breakpoints.  Package is\n"
"   the string name of a package or nil, and name-str is a string representin"
"g a\n"
"   function name (for example, \"foo\" or \"(setf foo)\").  After finding\n"
"   package, this READs name-str with *package* bound appropriately.  Path "
"is\n"
"   either a modified source-path or a symbol (:function-start or\n"
"   :function-end).  If it is a modified source-path, it has no top-level-for"
"m\n"
"   offset or form-number component, and it is in descent order from the "
"root of\n"
"   the top-level form."
msgstr ""

#: src/code/debug-int.lisp
msgid "Editor installed breakpoint."
msgstr ""

#: src/code/debug-int.lisp
msgid "We don't currently support breakpoints in interpreted code."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"~%Cannot set breakpoints for editor when source file no ~\n"
"		    longer exists:~%  ~A."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"~%While setting a breakpoint for the editor, noticed ~\n"
"			source file has been modified since compilation:~%  ~A~@\n"
"			Using form offset instead of character position.~%"
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"Cannot set breakpoints for editor when ~\n"
"				   there is no start positions map."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"The editor calls this in the slave with a remote-object representing a\n"
"   code-location to set a breakpoint."
msgstr ""

#: src/code/debug-int.lisp
msgid "The editor calls this remotely in the slave to delete a breakpoint."
msgstr ""

#: src/code/debug-int.lisp
msgid ""
"This returns a code-location before the body of a function and after all\n"
"   the arguments are in place.  If this cannot determine that location due "
"to\n"
"   a lack of debug information, it returns nil."
msgstr ""

#: src/code/debug-int.lisp
msgid "~S code location at ~D"
msgstr ""

#: src/code/debug.lisp
msgid ""
"*PRINT-LEVEL* is bound to this value when debug prints a function call.  If\n"
"  null, use *PRINT-LEVEL*"
msgstr ""

#: src/code/debug.lisp
msgid ""
"*PRINT-LENGTH* is bound to this value when debug prints a function call.  "
"If\n"
"  null, use *PRINT-LENGTH*."
msgstr ""

#: src/code/debug.lisp
msgid ""
"default value for the verbose argument to print-frame-call.  If set to >= 2,"
" source will be printed for all frames"
msgstr ""

#: src/code/debug.lisp
msgid "This is T while in the debugger."
msgstr ""

#: src/code/debug.lisp
msgid "Pushes and pops/exits inside the debugger change this."
msgstr ""

#: src/code/debug.lisp
msgid ""
"If this is bound before the debugger is invoked, it is used as the stack\n"
"   top by the debugger."
msgstr ""

#: src/code/debug.lisp
msgid ""
"This is a function of no arguments that prints the debugger prompt\n"
"   on *debug-io*."
msgstr ""

#: src/code/debug.lisp
msgid ""
"When true, the LIST-LOCATIONS command only displays block start locations.\n"
"   Otherwise, all locations are displayed."
msgstr ""

#: src/code/debug.lisp
msgid "If true, list the code location type in the LIST-LOCATIONS command."
msgstr ""

#: src/code/debug.lisp
msgid "~%Unknown location: using block start.~%"
msgstr ""

#: src/code/debug.lisp
msgid "~&~S: ~S in ~S"
msgstr ""

#: src/code/debug.lisp
msgid "~&~S: FUNCTION-START in ~S"
msgstr ""

#: src/code/debug.lisp
msgid "~&~S: FUNCTION-END in ~S"
msgstr ""

#: src/code/debug.lisp
msgid "~%Return values: ~S"
msgstr ""

#: src/code/debug.lisp
msgid "~&*Step (to a breakpoint)*"
msgstr ""

#: src/code/debug.lisp
msgid "*Step*"
msgstr ""

#: src/code/debug.lisp
msgid "~&*Breakpoint hit*"
msgstr ""

#: src/code/debug.lisp
msgid "Error in main-hook-function: unknown breakpoint"
msgstr ""

#: src/code/debug.lisp
msgid "Cannot step, in elsewhere code~%"
msgstr ""

#: src/code/debug.lisp
msgid ""
"Currently only compiled code can be stepped.~%~\n"
"                Trying to compile the passed form resulted in ~\n"
"                the following error:~%  ~A"
msgstr ""

#: src/code/debug.lisp
msgid "~2&Stepping the form~%  ~S~%"
msgstr ""

#: src/code/debug.lisp
msgid "~&using the debugger.  Type HELP for help.~2%"
msgstr ""

#: src/code/debug.lisp
msgid ""
"STEP implements a debugging paradigm wherein the programmer is allowed\n"
"   to step through the evaluation of a form.  We use the debugger's stepping"
"\n"
"   facility to step through an anonymous function containing only form.\n"
"\n"
"   Currently the stepping facility only supports stepping compiled code,\n"
"   so step will try to compile the resultant anonymous function.  If this\n"
"   fails, e.g. because it closes over a non-null lexical environment, an\n"
"   error is signalled."
msgstr ""

#: src/code/debug.lisp
msgid ""
"Show a listing of the call stack going down from the current frame.  In the\n"
"   debugger, the current frame is indicated by the prompt.  Count is how "
"many\n"
"   frames to show."
msgstr ""

#: src/code/debug.lisp
msgid "unavaliable-rest-arg"
msgstr ""

#: src/code/debug.lisp
msgid "lambda-list-unavailable"
msgstr ""

#: src/code/debug.lisp
msgid "error printing object {~X}"
msgstr ""

#: src/code/debug.lisp
msgid "unused-arg"
msgstr ""

#: src/code/debug.lisp
msgid "unavailable-arg"
msgstr ""

#: src/code/debug.lisp
msgid "~%Source: "
msgstr ""

#: src/code/debug.lisp
msgid "Error finding source: ~A"
msgstr ""

#: src/code/debug.lisp
msgid "Unable to display error condition~@[: ~A~]"
msgstr ""

#: src/code/debug.lisp
msgid ""
"This is either nil or a function of two arguments, a condition and the "
"value\n"
"   of *debugger-hook*.  This function can either handle the condition or "
"return\n"
"   which causes the standard debugger to execute.  The system passes the "
"value\n"
"   of this variable to the function because it binds *debugger-hook* to nil\n"
"   around the invocation."
msgstr ""

#: src/code/debug.lisp
msgid "~2&~A~%   [Condition of type ~S]~2&"
msgstr ""

#: src/code/debug.lisp
msgid "The CMU Common Lisp debugger.  Type h for help."
msgstr ""

#: src/code/debug.lisp
msgid "~&Restarts:~%"
msgstr ""

#: src/code/debug.lisp
msgid "~2&Debug  (type H for help)~2%"
msgstr ""

#: src/code/debug.lisp
msgid ""
"When set, avoid calling INVOKE-DEBUGGER recursively when errors occur while\n"
"   executing in the debugger.  The 'flush' command toggles this."
msgstr ""

#: src/code/debug.lisp
msgid ""
"When non-NIL, becomes the system *READTABLE* in the debugger\n"
"   read-eval-print loop"
msgstr ""

#: src/code/debug.lisp
msgid "When non-NIL, print the current frame when entering the debugger."
msgstr ""

#: src/code/debug.lisp
msgid "Unknown stream-command -- ~S."
msgstr ""

#: src/code/debug.lisp
msgid "Ambiguous debugger command: ~S."
msgstr ""

#: src/code/debug.lisp
msgid "~&Your command, ~S, is ambiguous:~%"
msgstr ""

#: src/code/debug.lisp
msgid "Return to debug level ~D."
msgstr ""

#: src/code/debug.lisp
msgid "~&Error flushed ..."
msgstr ""

#: src/code/debug.lisp
msgid ""
"When set (the default), evaluations in the debugger's command loop occur\n"
"   relative to the current frame's environment without the need of debugger\n"
"   forms that explicitly control this kind of evaluation."
msgstr ""

#: src/code/debug.lisp
msgid "Setting * to NIL -- was unbound marker."
msgstr ""

#: src/code/debug.lisp
msgid ""
"Returns a variable's value if possible.  Name is a simple-string or symbol.\n"
"   If it is a simple-string, it is an initial substring of the variable's "
"name.\n"
"   If name is a symbol, it has the same name and package as the variable "
"whose\n"
"   value this function returns.  If the symbol is uninterned, then the "
"variable\n"
"   has the same name as the symbol, but it has no package.\n"
"\n"
"   If name is the initial substring of variables with different names, then\n"
"   this return no values after displaying the ambiguous names.  If name\n"
"   determines multiple variables with the same name, then you must use the\n"
"   optional id argument to specify which one you want.  If you left id\n"
"   unspecified, then this returns no values after displaying the distinguish"
"ing\n"
"   id values.\n"
"\n"
"   The result of this function is limited to the availability of variable\n"
"   information.  This is SETF'able."
msgstr ""

#: src/code/debug.lisp
msgid "No known valid variables match ~S."
msgstr ""

#: src/code/debug.lisp
msgid "Specification ambiguous:~%~{   ~A~%~}"
msgstr ""

#: src/code/debug.lisp
msgid "Invalid variable ID, ~D, should have been one of ~S."
msgstr ""

#: src/code/debug.lisp
msgid "Specify variable ID to disambiguate ~S.  Use one of ~S."
msgstr ""

#: src/code/debug.lisp
msgid ""
"Returns the n'th argument's value if possible.  Argument zero is the first\n"
"   argument in a frame's default printed representation.  Count keyword/valu"
"e\n"
"   pairs as separate arguments."
msgstr ""

#: src/code/debug.lisp
msgid "Unused arguments have no values."
msgstr ""

#: src/code/debug.lisp
msgid "Invalid argument value."
msgstr ""

#: src/code/debug.lisp
msgid "No argument values are available."
msgstr ""

#: src/code/debug.lisp
msgid "Unused rest-arg before n'th argument."
msgstr ""

#: src/code/debug.lisp
msgid "Argument specification out of range -- ~S."
msgstr ""

#: src/code/debug.lisp
msgid "Invalid rest-arg before n'th argument."
msgstr ""

#: src/code/debug.lisp
msgid "Unknown debug command name -- ~S"
msgstr ""

#: src/code/debug.lisp
msgid "Invoking debugger command while outside the debugger."
msgstr ""

#: src/code/debug.lisp
msgid "~&Top of stack."
msgstr ""

#: src/code/debug.lisp
msgid "~&Bottom of stack."
msgstr ""

#: src/code/debug.lisp
msgid "You are here."
msgstr ""

#: src/code/debug.lisp
msgid "Bottom of stack encountered."
msgstr ""

#: src/code/debug.lisp
msgid "Top of stack encountered."
msgstr ""

#: src/code/debug.lisp
msgid "Frame number: "
msgstr ""

#: src/code/debug.lisp
msgid ""
"~@<can't find a tag for this frame ~\n"
"                   ~2I~_(hint: try increasing the DEBUG optimization "
"quality ~\n"
"                   and recompiling)~:@>"
msgstr ""

#: src/code/debug.lisp
msgid "debug-return: "
msgstr ""

#: src/code/debug.lisp
msgid "No restart named continue."
msgstr ""

#: src/code/debug.lisp
msgid "Restart: "
msgstr ""

#: src/code/debug.lisp
msgid "No such restart."
msgstr ""

#: src/code/debug.lisp
msgid "~S is invalid as a restart name.~%"
msgstr ""

#: src/code/debug.lisp
msgid ""
"This controls how many lines the debugger's help command prints before\n"
"   printing a prompting line to continue with output."
msgstr ""

#: src/code/debug.lisp
msgid "~%[RETURN FOR MORE, Q TO QUIT HELP TEXT]: "
msgstr ""

#: src/code/debug.lisp
msgid ""
"No local variables ~@[starting with ~A ~]~\n"
"	               in function."
msgstr ""

#: src/code/debug.lisp
msgid ""
"All variables ~@[starting with ~A ~]currently ~\n"
"	               have invalid values."
msgstr ""

#: src/code/debug.lisp
msgid "No variable information available."
msgstr ""

#: src/code/debug.lisp
msgid "Source file no longer exists:~%  ~A."
msgstr ""

#: src/code/debug.lisp
msgid "~%; File: ~A~%"
msgstr ""

#: src/code/debug.lisp
msgid ""
"~%; File has been modified since compilation:~%;   ~A~@\n"
"		 ; Using form offset instead of character position.~%"
msgstr ""

#: src/code/debug.lisp
msgid "No start positions map."
msgstr ""

#: src/code/debug.lisp
msgid "Couldn't continue."
msgstr ""

#: src/code/debug.lisp
msgid "::FUNCTION-START "
msgstr ""

#: src/code/debug.lisp
msgid " *Active*"
msgstr ""

#: src/code/debug.lisp
msgid " *Continue here*"
msgstr ""

#: src/code/debug.lisp
msgid "~&::FUNCTION-END *Active* "
msgstr ""

#: src/code/debug.lisp
msgid "Note: previous breakpoint removed.~%"
msgstr ""

#: src/code/debug.lisp
msgid "~&Added."
msgstr ""

#: src/code/debug.lisp
msgid "Location number, :start, or :end: "
msgstr ""

#: src/code/debug.lisp
msgid "Breakpoint ~S removed.~%"
msgstr ""

#: src/code/debug.lisp
msgid "Breakpoint doesn't exist."
msgstr ""

#: src/code/debug.lisp
msgid "All breakpoints deleted.~%"
msgstr ""

#: src/code/debug.lisp
msgid "Errors now flushed."
msgstr ""

#: src/code/debug.lisp
msgid "Errors now create nested debug levels."
msgstr ""

#: src/code/debug.lisp
msgid "Can't figure out the function for this frame."
msgstr ""

#: src/code/debug.lisp
msgid ""
"The debugger's EDIT-SOURCE command only works in slave Lisps ~\n"
"	    connected to a Hemlock editor."
msgstr ""

#: src/code/query.lisp
msgid ""
"Y-OR-N-P prints the message, if any, and reads characters from *QUERY-IO*\n"
"   until the user enters y or Y as an affirmative, or either n or N as a\n"
"   negative answer.  It ignores preceding whitespace and asks again if you\n"
"   enter any other characters."
msgstr ""

#: src/code/query.lisp
msgid "Type \"y\" for yes or \"n\" for no. "
msgstr ""

#: src/code/query.lisp
msgid ""
"YES-OR-NO-P is similar to Y-OR-N-P, except that it clears the \n"
"   input buffer, beeps, and uses READ-LINE to get the strings \n"
"   YES or NO."
msgstr ""

#: src/code/query.lisp
msgid "Type \"yes\" for yes or \"no\" for no. "
msgstr ""

#: src/code/rand-mt19937.lisp
msgid ""
"Generate an random state vector from the given SEED.  The seed can be\n"
"  either an integer or a vector of (unsigned-byte 32)"
msgstr ""

#: src/code/rand-mt19937.lisp
msgid ""
"Make a random state object.  If STATE is not supplied, return a copy\n"
"  of the default random state.  If STATE is a random state, then return a\n"
"  copy of it.  If STATE is T then return a random state generated from\n"
"  the universal time or /dev/urandom if available."
msgstr ""

#: src/code/rand-mt19937.lisp
msgid "Argument is not a RANDOM-STATE, T or NIL: ~S"
msgstr ""

#: src/code/rand-mt19937.lisp
msgid ""
"Generate a uniformly distributed pseudo-random number between zero\n"
"  and Arg.  State, if supplied, is the random state to use."
msgstr ""

#: src/code/rand-mt19937.lisp
msgid "Argument is not a positive integer or a positive float: ~S"
msgstr ""

#: src/code/ntrace.lisp
msgid ""
"This is bound to the returned values when evaluating :BREAK-AFTER and\n"
"   :PRINT-AFTER forms."
msgstr ""

#: src/code/ntrace.lisp
msgid ""
"If the trace indentation exceeds this value, then indentation restarts at\n"
"   0."
msgstr ""

#: src/code/ntrace.lisp
msgid "The default value for the :ENCAPSULATE option to trace."
msgstr ""

#: src/code/ntrace.lisp
msgid ""
"List of package names.  Encapsulate functions from these packages\n"
"   by default.  This should at least include the packages of functions\n"
"   used by TRACE, directly or indirectly."
msgstr ""

#: src/code/ntrace.lisp
msgid "Can't trace special form ~S."
msgstr ""

#: src/code/ntrace.lisp
msgid "Breaking ~A traced call to ~S:"
msgstr ""

#: src/code/ntrace.lisp
msgid "~S returned"
msgstr ""

#: src/code/ntrace.lisp
msgid "Function ~S already TRACE'd, retracing it."
msgstr ""

#: src/code/ntrace.lisp
msgid "~S name is not a defined global function: ~S"
msgstr ""

#: src/code/ntrace.lisp
msgid "Can't use encapsulation to trace anonymous function ~S."
msgstr ""

#: src/code/ntrace.lisp
msgid "Can't use encapsulation to trace local flet/labels function ~S."
msgstr ""

#: src/code/ntrace.lisp
msgid "Tracing shared code for ~S:~%  ~S"
msgstr ""

#: src/code/ntrace.lisp
msgid "Missing argument to ~S TRACE option."
msgstr ""

#: src/code/ntrace.lisp
msgid "Unknown TRACE option: ~S"
msgstr ""

#: src/code/ntrace.lisp
msgid ""
"TRACE {Option Global-Value}* {Name {Option Value}*}*\n"
"   TRACE is a debugging tool that prints information when specified function"
"s\n"
"   are called.  In its simplest form:\n"
"       (trace Name-1 Name-2 ...)\n"
"\n"
"   CLOS methods can be traced by specifying a name of the form\n"
"   (METHOD {Qualifier}* ({Specializer}*)).\n"
"\n"
"   Labels and Flet functions can be traced by specifying a name of the form\n"
"   (LABELS <lfun> <fun>) or (FLET <lfun> <fun>) where <lfun> is the Labels/F"
"let\n"
"   function in <fun>.\n"
"\n"
"   TRACE causes a printout on *TRACE-OUTPUT* each time that one of the "
"named\n"
"   functions is entered or returns (the Names are not evaluated.)  The "
"output\n"
"   is indented according to the number of pending traced calls, and this "
"trace\n"
"   depth is printed at the beginning of each line of output.\n"
"\n"
"   Options allow modification of the default behavior.  Each option is a "
"pair\n"
"   of an option keyword and a value form.  Options may be interspersed with\n"
"   function names.  Options only affect tracing of the function whose name "
"they\n"
"   appear immediately after.  Global options are specified before the first\n"
"   name, and affect all functions traced by a given use of TRACE.\n"
"\n"
"   The following options are defined:\n"
"\n"
"   :CONDITION Form\n"
"   :CONDITION-AFTER Form\n"
"   :CONDITION-ALL Form\n"
"       If :CONDITION is specified, then TRACE does nothing unless Form\n"
"       evaluates to true at the time of the call.  :CONDITION-AFTER is\n"
"       similar, but suppresses the initial printout, and is tested when the\n"
"       function returns.  :CONDITION-ALL tries both before and after.\n"
"\n"
"   :WHEREIN Names\n"
"       If specified, Names is a function name or list of names.  TRACE does\n"
"       nothing unless a call to one of those functions encloses the call to\n"
"       this function (i.e. it would appear in a backtrace.)  Anonymous\n"
"       functions have string names like \"DEFUN FOO\".\n"
"   :WHEREIN-ONLY Names\n"
"       Like :WHEREIN, but only if the immediate caller is one of Names,\n"
"       instead of being any where in a backtrace.\n"
"\n"
"   :BREAK Form\n"
"   :BREAK-AFTER Form\n"
"   :BREAK-ALL Form\n"
"       If specified, and Form evaluates to true, then the debugger is "
"invoked\n"
"       at the start of the function, at the end of the function, or both,\n"
"       according to the respective option.\n"
"\n"
"   :PRINT Form\n"
"   :PRINT-AFTER Form\n"
"   :PRINT-ALL Form\n"
"       In addition to the usual printout, the result of evaluating FORM is\n"
"       printed at the start of the function, at the end of the function, or\n"
"       both, according to the respective option.  Multiple print options "
"cause\n"
"       multiple values to be printed.\n"
"\n"
"   :FUNCTION Function-Form\n"
"       This is a not really an option, but rather another way of specifying\n"
"       what function to trace.  The Function-Form is evaluated immediately,\n"
"       and the resulting function is traced.\n"
"\n"
"   :METHODS Function-Form\n"
"       This is a not really an option, but rather a way of specifying\n"
"       that all methods of a generic functions should be traced.  The\n"
"       Function-Form is evaluated immediately, and the methods of the "
"resulting\n"
"       generic function are traced.\n"
"\n"
"   :ENCAPSULATE {:DEFAULT | T | NIL}\n"
"       If T, the tracing is done via encapsulation (redefining the function\n"
"       name) rather than by modifying the function.  :DEFAULT is the "
"default,\n"
"       and means to use encapsulation for interpreted functions and funcalla"
"ble\n"
"       instances, breakpoints otherwise.  When encapsulation is used, forms "
"are\n"
"       *not* evaluated in the function's lexical environment, but DEBUG:ARG "
"can\n"
"       still be used.\n"
"\n"
"   :CONDITION, :BREAK and :PRINT forms are evaluated in the lexical environm"
"ent\n"
"   of the called function; DEBUG:VAR and DEBUG:ARG can be used.  The -AFTER "
"and\n"
"   -ALL forms are evaluated in the null environment."
msgstr ""

#: src/code/ntrace.lisp
msgid "Function is not TRACE'd -- ~S."
msgstr ""

#: src/code/ntrace.lisp
msgid ""
"Removes tracing from the specified functions.  With no args, untraces all\n"
"   functions."
msgstr ""

#: src/code/profile.lisp
msgid "List of functions that are currently being timed."
msgstr ""

#: src/code/profile.lisp
msgid "A list of profiled functions which weren't called."
msgstr ""

#: src/code/profile.lisp
msgid ""
"If the number of profiled functions that were not called is less than\n"
"this, the functions are listed.  If NIL, then always list the functions."
msgstr ""

#: src/code/profile.lisp
msgid "dfixnum became negative ~a/~a - ~a/~a(~a/~a)"
msgstr ""

#: src/code/profile.lisp
msgid "dfixnum became too big ~a/~a + ~a/~a"
msgstr ""

#: src/code/profile.lisp
msgid ""
"Ensure that a profile fwrapper for functions with NREQ required\n"
"   arguments and optional arguments according to OPTIONALS-P exists.\n"
"   Return the name of that fwrapper."
msgstr ""

#: src/code/profile.lisp
msgid "Return the profile FWRAPPER object on function NAME, if any."
msgstr ""

#: src/code/profile.lisp
msgid ""
"Return the PROFILE-INFO for function NAME.\n"
"   Signal an error if NAME is not profiled."
msgstr ""

#: src/code/profile.lisp
msgid ""
"PROFILE Name*\n"
"   Wraps profiling code around the named functions.  As in TRACE, the names "
"are\n"
"   not evaluated.  If a function is already profiled, then unprofile and\n"
"   reprofile (useful to notice function redefinition.)  If a name is "
"undefined,\n"
"   then we give a warning and ignore it.\n"
"\n"
"   CLOS methods can be profiled by specifying names of the form\n"
"   (METHOD <name> <qualifier>* (<specializer>*)), like in TRACE.\n"
"\n"
"   :METHODS Function-Form is a way of specifying that all methods of a\n"
"   generic functions should be profiled.  The Function-Form is\n"
"   evaluated immediately, and the methods of the resulting generic\n"
"   function are profiled.\n"
"\n"
"   If :CALLERS T appears, subsequent names have counts of the most\n"
"   common calling functions recorded.\n"
"\n"
"   See also UNPROFILE, REPORT-TIME and RESET-TIME."
msgstr ""

#: src/code/profile.lisp
msgid ""
"PROFILE-ALL\n"
"\n"
" Wraps profiling code around all functions in PACKAGE, which defaults\n"
" to *PACKAGE*. If a function is already profiled, then unprofile and\n"
" reprofile (useful to notice function redefinition.)  If a name is\n"
" undefined, then we give a warning and ignore it.  If CALLERS-P is T\n"
" names have counts of the most common calling functions recorded.\n"
"\n"
" When called with arguments :METHODS T, profile all methods of all\n"
" generic function having names in the given package.  Generic functions\n"
" themselves, that is, their dispatch functions, are left alone.\n"
"\n"
" See also UNPROFILE, REPORT-TIME and RESET-TIME. "
msgstr ""

#: src/code/profile.lisp
msgid ""
"Unwraps the profiling code around the named functions.  Names defaults to\n"
"  the list of all currently profiled functions."
msgstr ""

#: src/code/profile.lisp
msgid ""
"Resets the time counter for the named functions.  Names defaults to the "
"list\n"
"  of all currently profiled functions."
msgstr ""

#: src/code/profile.lisp
msgid ""
"Reports the time spent in the named functions.  Names defaults to the list\n"
"  of all currently profiled functions."
msgstr ""

#: src/code/profile.lisp
msgid ""
"Reports the time spent in the named functions.  Names defaults to the list\n"
"  of all currently profiled functions.  Uses printfunction."
msgstr ""

#: src/code/sort.lisp
msgid ""
"Destructively sorts sequence.  Predicate should returns non-Nil if\n"
"   Arg1 is to precede Arg2."
msgstr ""

#: src/code/sort.lisp
msgid "~S is not a sequence."
msgstr ""

#: src/code/sort.lisp
msgid ""
"The sequences Sequence1 and Sequence2 are destructively merged into\n"
"   a sequence of type Result-Type using the Predicate to order the "
"elements."
msgstr ""

#: src/code/time.lisp
msgid ""
"The number of internal time units that fit into a second.  See\n"
"  Get-Internal-Real-Time and Get-Internal-Run-Time."
msgstr ""

#: src/code/time.lisp
msgid ""
"Return the real time in the internal time format.  This is useful for\n"
"  finding elapsed time.  See Internal-Time-Units-Per-Second."
msgstr ""

#: src/code/time.lisp
msgid ""
"Return the run time in the internal time format.  This is useful for\n"
"  finding CPU usage."
msgstr ""

#: src/code/time.lisp
msgid ""
"Returns a single integer for the current time of\n"
"   day in universal time format."
msgstr ""

#: src/code/time.lisp
msgid ""
"Returns nine values specifying the current time as follows:\n"
"   second, minute, hour, date, month, year, day of week (0 = Monday), T\n"
"   (daylight savings times) or NIL (standard time), and timezone."
msgstr ""

#: src/code/time.lisp
msgid ""
"Converts a universal-time to decoded time format returning the following\n"
"   nine values: second, minute, hour, date, month, year, day of week (0 =\n"
"   Monday), T (daylight savings time) or NIL (standard time), and timezone.\n"
"   Completely ignores daylight-savings-time when time-zone is supplied."
msgstr ""

#: src/code/time.lisp
msgid ""
"The time values specified in decoded format are converted to \n"
"   universal time, which is returned."
msgstr ""

#: src/code/time.lisp
msgid "Evaluates the Form and prints timing information on *Trace-Output*."
msgstr ""

#: src/code/time.lisp
msgid ""
"TIME form in a non-null environment, forced to interpret.~@\n"
"	       Compiling entire form will produce more accurate times."
msgstr ""

#: src/code/time.lisp
msgid ""
"Evaluation took:~%  ~\n"
"		     ~S seconds of real time~%  ~\n"
"		     ~S seconds of user run time~%  ~\n"
"		     ~S seconds of system run time~%  "
msgstr ""

#: src/code/time.lisp
msgid ""
"~:D ~A cycle~%  ~\n"
"		     ~@[[Run times include ~S seconds GC run time]~%  ~]"
msgid_plural ""
"~:D ~A cycles~%  ~\n"
"		     ~@[[Run times include ~S seconds GC run time]~%  ~]"
msgstr[0] ""

#: src/code/time.lisp
msgid "~S page fault and~%  "
msgid_plural "~S page faults and~%  "
msgstr[0] ""

#: src/code/time.lisp
msgid "~:D byte consed.~%"
msgid_plural "~:D bytes consed.~%"
msgstr[0] ""

#: src/code/weak.lisp
msgid "Allocates and returns a weak pointer which points to OBJECT."
msgstr ""

#: src/code/weak.lisp
msgid ""
"If WEAK-POINTER is valid, returns the value of WEAK-POINTER and T.\n"
"   If the referent of WEAK-POINTER has been garbage collected, returns\n"
"   the values NIL and NIL."
msgstr ""

#: src/code/weak.lisp
msgid "Updates WEAK-POINTER to point to a new object."
msgstr ""

#: src/code/final.lisp
msgid ""
"Arrange for FUNCTION to be called when there are no more references to\n"
"   OBJECT.  FUNCTION takes no arguments."
msgstr ""

#: src/code/final.lisp
msgid "Cancel any finalization registers for OBJECT."
msgstr ""

#: src/code/describe.lisp
msgid "Depth of recursive descriptions allowed."
msgstr ""

#: src/code/describe.lisp
msgid ""
"If non-nil, descriptions may provide interpretations of information and\n"
"  pointers to additional information.  Normally nil."
msgstr ""

#: src/code/describe.lisp
msgid ""
"*print-level* gets bound to this inside describe.  If null, use\n"
"  *print-level*"
msgstr ""

#: src/code/describe.lisp
msgid ""
"*print-length* gets bound to this inside describe.  If null, use\n"
"  *print-length*."
msgstr ""

#: src/code/describe.lisp
msgid "Number of spaces that sets off each line of a recursive description."
msgstr ""

#: src/code/describe.lisp
msgid "Used to tell whether we are doing a recursive describe."
msgstr ""

#: src/code/describe.lisp
msgid "Used to implement recursive description cutoff.  Don't touch."
msgstr ""

#: src/code/describe.lisp
msgid "An output stream used by Describe for indenting and stuff."
msgstr ""

#: src/code/describe.lisp
msgid ""
"List of all objects describe within the current top-level call to describe."
msgstr ""

#: src/code/describe.lisp
msgid "The last object passed to describe."
msgstr ""

#: src/code/describe.lisp
msgid "Prints a description of the object X."
msgstr ""

#: src/code/describe.lisp
msgid "*describe-level* should be a nonnegative integer - ~A."
msgstr ""

#: src/code/describe.lisp
msgid "~&~S is a ~S."
msgstr ""

#: src/code/describe.lisp
msgid "~&Its code is #x~4,'0x."
msgstr ""

#: src/code/describe.lisp
msgid "~&Its name is ~A."
msgstr ""

#: src/code/describe.lisp
msgid "~&It is a ~:[high (leading)~;low (trailing)~] surrogate character."
msgstr ""

#: src/code/describe.lisp
msgid "~&~S is a ~(~A~) of type ~A."
msgstr ""

#: src/code/describe.lisp
msgid "~&~S is a ~:[~;displaced ~]vector of length ~D."
msgstr ""

#: src/code/describe.lisp
msgid "~&It has a fill pointer, currently ~d"
msgstr ""

#: src/code/describe.lisp
msgid "~&It has no fill pointer."
msgstr ""

#: src/code/describe.lisp
msgid "~&~S is ~:[an~;a displaced~] array of rank ~A"
msgstr ""

#: src/code/describe.lisp
msgid "~%Its dimensions are ~S."
msgstr ""

#: src/code/describe.lisp
msgid "~&Its element type is specialized to ~S."
msgstr ""

#: src/code/describe.lisp
msgid "~&It is adjustable."
msgstr ""

#: src/code/describe.lisp
msgid "~&It is static."
msgstr ""

#: src/code/describe.lisp
msgid "~&It is a prime number."
msgstr ""

#: src/code/describe.lisp
msgid "~&It is a composite number."
msgstr ""

#: src/code/describe.lisp
msgid "~&Its components are ~S and ~S."
msgstr ""

#: src/code/describe.lisp
msgid "~&~S is an ~A hash table."
msgstr ""

#: src/code/describe.lisp
msgid "~&Its size is ~D buckets."
msgstr ""

#: src/code/describe.lisp
msgid "~&Its rehash-size is ~S."
msgstr ""

#: src/code/describe.lisp
msgid "~&Its rehash-threshold is ~S."
msgstr ""

#: src/pcl/env.lisp src/code/describe.lisp
msgid "~&It currently holds ~d entries."
msgstr ""

#: src/code/describe.lisp
msgid "~&It is weak ~A table."
msgstr ""

#: src/code/describe.lisp
msgid "~&~d symbols total: ~d internal and ~d external."
msgstr ""

#: src/code/describe.lisp
msgid "~&~@(~A documentation:~)~&  ~A"
msgstr ""

#: src/code/describe.lisp
msgid "~&Its ~(~A~) argument types are:~%  ~S"
msgstr ""

#: src/code/describe.lisp
msgid "~&Its result type is:~%  ~S"
msgstr ""

#: src/code/describe.lisp
msgid ""
"~&It is currently declared ~(~A~);~\n"
"		 ~:[no~;~] expansion is available."
msgstr ""

#: src/code/describe.lisp
msgid "~&~@(~@[~A ~]arguments:~%~)"
msgstr ""

#: src/code/describe.lisp
msgid "  There are no arguments."
msgstr ""

#: src/code/describe.lisp
msgid "~&Its closure environment is:"
msgstr ""

#: src/code/describe.lisp
msgid "~&Its definition is:~%  ~S"
msgstr ""

#: src/code/describe.lisp
msgid "~&On ~A it was compiled from:"
msgstr ""

#: src/code/describe.lisp
msgid "~&~A~%  Created: "
msgstr ""

#: src/code/describe.lisp
msgid "~&  Comment: ~A"
msgstr ""

#: src/code/describe.lisp
msgid "  There is no argument information available."
msgstr ""

#: src/code/describe.lisp
msgid "Macro-function: ~S"
msgstr ""

#: src/code/describe.lisp
msgid "Function: ~S"
msgstr ""

#: src/code/describe.lisp
msgid "~S is a function."
msgstr ""

#: src/code/describe.lisp
msgid "~&It is an unknown type of function."
msgstr ""

#: src/code/describe.lisp
msgid "~&~A is an ~A symbol in the ~A package."
msgstr ""

#: src/code/describe.lisp
msgid "~&~A is an uninterned symbol."
msgstr ""

#: src/code/describe.lisp
msgid "~&~@<It is an alien at #x~8,'0X of type ~3I~:_~S.~:>~%"
msgstr ""

#: src/code/describe.lisp
msgid "~@<Its current value is ~3I~:_~S.~:>"
msgstr ""

#: src/code/describe.lisp
msgid "~&It is a ~A with expansion: ~S."
msgstr ""

#: src/code/describe.lisp
msgid "~&It is a ~A; its value is ~S."
msgstr ""

#: src/code/describe.lisp
msgid "~&It is a ~A; no current value."
msgstr ""

#: src/code/describe.lisp
msgid "~&Its declared type is ~S."
msgstr ""

#: src/code/describe.lisp
msgid "Special form"
msgstr ""

#: src/code/describe.lisp
msgid "Structure"
msgstr ""

#: src/code/describe.lisp
msgid "Type"
msgstr ""

#: src/code/describe.lisp
msgid "Setf macro"
msgstr ""

#: src/code/describe.lisp
msgid "~&Documentation on the ~(~A~):~%~A"
msgstr ""

#: src/code/describe.lisp
msgid "~&It names a class ~A."
msgstr ""

#: src/code/describe.lisp
msgid "~&It names a PCL class ~A."
msgstr ""

#: src/code/describe.lisp
msgid "~&It names a type specifier."
msgstr ""

#: src/code/describe.lisp
msgid "~&Its ~S property is ~S."
msgstr ""

#: src/code/describe.lisp
msgid "~&It is defined in:~&~A"
msgstr ""

#: src/code/tty-inspect.lisp
msgid "~%That slot is unbound.~%"
msgstr ""

#: src/code/tty-inspect.lisp
msgid "~%This object contains nothing to inspect.~%~%"
msgstr ""

#: src/code/tty-inspect.lisp
msgid "~%Enter a VALID number (~:[0-~D~;0~]).~%~%"
msgstr ""

#: src/code/tty-inspect.lisp
msgid "~%Bottom of Stack.~%"
msgstr ""

#: src/code/tty-inspect.lisp
msgid "~%Returning to INSPECTOR.~%"
msgstr ""

#: src/code/tty-inspect.lisp
msgid "TTY-Inspector Help:"
msgstr ""

#: src/code/tty-inspect.lisp
msgid "  R           -  recompute current object."
msgstr ""

#: src/code/tty-inspect.lisp
msgid "  D           -  redisplay current object."
msgstr ""

#: src/code/tty-inspect.lisp
msgid "  U           -  Move upward through the object stack."
msgstr ""

#: src/code/tty-inspect.lisp
msgid "  <number>    -  Inspect this slot."
msgstr ""

#: src/code/tty-inspect.lisp
msgid "  Q, E        -  Quit TTY-INSPECTOR."
msgstr ""

#: src/code/tty-inspect.lisp
msgid "  ?, H, Help  -  Show this help."
msgstr ""

#: src/code/tty-inspect.lisp
msgid "Unbound"
msgstr ""

#: src/code/tty-inspect.lisp
msgid "~s is a symbol.~%"
msgstr ""

#: src/code/tty-inspect.lisp
msgid "Value"
msgstr ""

#: src/code/tty-inspect.lisp
msgid "Function"
msgstr ""

#: src/code/tty-inspect.lisp
msgid "Plist"
msgstr ""

#: src/code/tty-inspect.lisp
msgid "Package"
msgstr ""

#: src/code/tty-inspect.lisp
msgid "~s is an instance of ~s.~%"
msgstr ""

#: src/code/tty-inspect.lisp
msgid "- (slot is unbound)"
msgstr ""

#: src/code/tty-inspect.lisp
msgid "~s is a ~(~A~).~%"
msgstr ""

#: src/code/tty-inspect.lisp
msgid "Function ~s.~@[~%Argument List: ~a~]."
msgstr ""

#: src/code/tty-inspect.lisp
msgid "Object is a ~:[~;displaced ~]vector of length ~d.~%"
msgstr ""

#: src/code/tty-inspect.lisp
msgid "Object is a LIST of length ~d.~%"
msgstr ""

#: src/code/tty-inspect.lisp
msgid "Object is a CONS.~%"
msgstr ""

#: src/code/tty-inspect.lisp
msgid ""
"Object is ~:[a displaced~;an~] array of ~a.~%~\n"
"                       Its dimensions are ~s.~%"
msgstr ""

#: src/code/tty-inspect.lisp
msgid "Object is an atom.~%"
msgstr ""

#: src/code/format-time.lisp
msgid ""
"Format-Universal-Time formats a string containing the time and date\n"
"   given by universal-time in a common manner.  The destination is any\n"
"   destination which can be accepted by the Format function.  The\n"
"   timezone keyword is an integer specifying hours west of Greenwich.\n"
"   The style keyword can be :short (numeric date), :long (months and\n"
"   weekdays expressed as words), :abbreviated (like :long but words\n"
"   are abbreviated), :rfc1123 (conforming to RFC 1123), :government\n"
"   (of the form \"XX Mon XX XX:XX:XX\"), or :iso8601 (conforming to\n"
"   ISO 8601), which is the recommended way of printing date and time.\n"
"   The keyword date-first, if nil, will print the time first instead of\n"
"   the date (the default).  The print- keywords, if nil, inhibit the\n"
"   printing of the obvious part of the time/date."
msgstr ""

#: src/code/format-time.lisp
msgid "~A: Not a valid format destination."
msgstr ""

#: src/code/format-time.lisp
msgid "~A: Universal-Time should be an integer."
msgstr ""

#: src/code/format-time.lisp
msgid "~A: Timezone should be a rational between -24 and 24."
msgstr ""

#: src/code/format-time.lisp
msgid "~A: Timezone is not a second (1/3600) multiple."
msgstr ""

#: src/code/format-time.lisp
msgid "~A: Unrecognized :style keyword value."
msgstr ""

#: src/code/format-time.lisp
msgid ""
"Format-Decoded-Time formats a string containing decoded-time\n"
"   expressed in a humanly-readable manner.  The destination is any\n"
"   destination which can be accepted by the Format function.  The\n"
"   timezone keyword is an integer specifying hours west of Greenwich.\n"
"   The style keyword can be :short (numeric date), :long (months and\n"
"   weekdays expressed as words), or :abbreviated (like :long but words are\n"
"   abbreviated).  The keyword date-first, if nil, will cause the time\n"
"   to be printed first instead of the date (the default).  The print-\n"
"   keywords, if nil, inhibit the printing of certain semi-obvious\n"
"   parts of the string."
msgstr ""

#: src/code/format-time.lisp
msgid "~A: Seconds should be an integer between 0 and 59."
msgstr ""

#: src/code/format-time.lisp
msgid "~A: Minutes should be an integer between 0 and 59."
msgstr ""

#: src/code/format-time.lisp
msgid "~A: Hours should be an integer between 0 and 23."
msgstr ""

#: src/code/format-time.lisp
msgid "~A: Day should be an integer between 1 and 31."
msgstr ""

#: src/code/format-time.lisp
msgid "~A: Month should be an integer between 1 and 12."
msgstr ""

#: src/code/format-time.lisp
msgid "~A: Hours should be an non-negative integer."
msgstr ""

#: src/code/format-time.lisp
msgid "~A: Timezone should be an integer between 0 and 32."
msgstr ""

#: src/code/parse-time.lisp
msgid ""
"If t, an error will be signalled if parse-time is unable\n"
"   to determine the time/date format of the string."
msgstr ""

#: src/code/parse-time.lisp
msgid "\"~A\" is not a recognized word or abbreviation."
msgstr ""

#: src/code/parse-time.lisp
msgid ""
"Can't parse time/date string.~%>>> ~A~\n"
"				   ~%~VT^-- Bogus character encountered here."
msgstr ""

#: src/code/parse-time.lisp
msgid "Unrecognized symbol: ~A"
msgstr ""

#: src/code/parse-time.lisp
msgid "~D is not an AM hour, dummy."
msgstr ""

#: src/code/parse-time.lisp
msgid "~A isn't AM/PM - this shouldn't happen."
msgstr ""

#: src/code/parse-time.lisp
msgid "Invalid number of days (~D) for month ~D in ~D"
msgstr ""

#: src/code/parse-time.lisp
msgid "Ignore."
msgstr ""

#: src/code/parse-time.lisp
msgid "Specified day (~@(~A~)) doesn't match actual day (~@(~A~))"
msgstr ""

#: src/code/parse-time.lisp
msgid "Unrecognized symbol in form list: ~A."
msgstr ""

#: src/code/parse-time.lisp
msgid ""
"Tries very hard to make sense out of the argument time-string and\n"
"   returns a single integer representing the universal time if\n"
"   successful.  If not, it returns nil.  If the :error-on-mismatch\n"
"   keyword is true, parse-time will signal an error instead of\n"
"   returning nil.  Default values for each part of the time/date\n"
"   can be specified by the appropriate :default- keyword.  These\n"
"   keywords can be given a numeric value or the keyword :current\n"
"   to set them to the current value.  The default-default values\n"
"   are 00:00:00 on the current date, current time-zone."
msgstr ""

#: src/code/parse-time.lisp
msgid "\"~A\" is not a recognized time/date format."
msgstr ""

#: src/code/run-program.lisp
msgid "List of process structures for all active processes."
msgstr ""

#: src/code/run-program.lisp
msgid ""
"Return the current status of process.  The result is one of\n"
"  :running,:stopped, :continued, :exited, :signaled."
msgstr ""

#: src/code/run-program.lisp
msgid "Wait for PROC to quit running for some reason.  Returns PROC."
msgstr ""

#: src/code/run-program.lisp
msgid "PID of child process."
msgstr ""

#: src/code/run-program.lisp
msgid ""
"Exit code for the process if it is :exited; the termination signal\n"
"  if it is :signaled; 0 if it is :stopped.  It is undefined in all\n"
"  other cases."
msgstr ""

#: src/code/run-program.lisp
msgid "Non-NIL if the process was terminated and a core image was dumped."
msgstr ""

#: src/code/run-program.lisp
msgid ""
"The two-way stream connected to the child's Unix pty connection or NIL."
msgstr ""

#: src/code/run-program.lisp
msgid "Stream to child's input or NIL."
msgstr ""

#: src/code/run-program.lisp
msgid "Stream from child's output or NIL."
msgstr ""

#: src/code/run-program.lisp
msgid "Stream from child's error output or NIL."
msgstr ""

#: src/code/run-program.lisp
msgid ""
"The function to be called whenever process's changes status. This\n"
"  function takes the process as a required argument.  This is\n"
"  setf'able."
msgstr ""

#: src/code/run-program.lisp
msgid ""
"Returns annotations supplibed by users; it is setf'able. This is\n"
"  available for users to associcate information with the process\n"
"  without having to build a-lists or hash tables of process\n"
"  structures."
msgstr ""

#: src/code/run-program.lisp
msgid "TIOCPGRP ioctl failed: ~S"
msgstr ""

#: src/code/run-program.lisp
msgid ""
"Hand SIGNAL to PROC.  If whom is :pid, use the kill Unix system call.  If\n"
"   whom is :process-group, use the killpg Unix system call.  If whom is\n"
"   :pty-process-group deliver the signal to whichever process group is "
"currently\n"
"   in the foreground."
msgstr ""

#: src/code/run-program.lisp
msgid "Returns T if the process is still alive, NIL otherwise."
msgstr ""

#: src/code/run-program.lisp
msgid ""
"Close all streams connected to PROC and stop maintaining the status slot."
msgstr ""

#: src/code/run-program.lisp
msgid ""
"List of file descriptors to close when RUN-PROGRAM exits due to an error."
msgstr ""

#: src/code/run-program.lisp
msgid ""
"List of file descriptors to close when RUN-PROGRAM returns in the parent."
msgstr ""

#: src/code/run-program.lisp
msgid "List of handlers installed by RUN-PROGRAM."
msgstr ""

#: src/code/run-program.lisp
msgid "Returns the master fd, the slave fd, and the name of the tty"
msgstr ""

#: src/code/run-program.lisp
msgid "Could not find a pty."
msgstr ""

#: src/code/run-program.lisp
msgid "Could not UNIX:UNIX-DUP ~D: ~A"
msgstr ""

#: src/code/run-program.lisp
msgid ""
"RUN-PROGRAM creates a new process and runs the unix program in the\n"
"   file specified by the simple-string PROGRAM.  ARGS are the standard\n"
"   arguments that can be passed to a Unix program, for no arguments\n"
"   use NIL (which means just the name of the program is passed as arg 0).\n"
"\n"
"   RUN-PROGRAM will either return NIL or a PROCESS structure.  See the CMU\n"
"   Common Lisp Users Manual for details about the PROCESS structure.\n"
"\n"
"   The keyword arguments have the following meanings:\n"
"     :env -\n"
"        An A-LIST mapping keyword environment variables to\n"
"	simple-string values.  This is the shell environment for\n"
"	Program.  Defaults to *environment-list*.\n"
"     :wait -\n"
"        If non-NIL (default), wait until the created process finishes.  If\n"
"        NIL, continue running Lisp until the program finishes.\n"
"     :pty -\n"
"        Either T, NIL, or a stream.  Unless NIL, the subprocess is establish"
"ed\n"
"	under a PTY.  If :pty is a stream, all output to this pty is sent to\n"
"	this stream, otherwise the PROCESS-PTY slot is filled in with a stream\n"
"	connected to pty that can read output and write input.\n"
"     :input -\n"
"        Either T, NIL, a pathname, a stream, or :STREAM.  If T, the standard"
"\n"
"	input for the current process is inherited.  If NIL, /dev/null\n"
"	is used.  If a pathname, the file so specified is used.  If a stream,\n"
"	all the input is read from that stream and send to the subprocess.  If\n"
"	:STREAM, the PROCESS-INPUT slot is filled in with a stream that sends \n"
"	its output to the process. Defaults to NIL.\n"
"     :if-input-does-not-exist (when :input is the name of a file) -\n"
"        can be one of:\n"
"           :error - generate an error.\n"
"           :create - create an empty file.\n"
"           nil (default) - return nil from run-program.\n"
"     :output -\n"
"        Either T, NIL, a pathname, a stream, or :STREAM.  If T, the standard"
"\n"
"	output for the current process is inherited.  If NIL, /dev/null\n"
"	is used.  If a pathname, the file so specified is used.  If a stream,\n"
"	all the output from the process is written to this stream. If\n"
"	:STREAM, the PROCESS-OUTPUT slot is filled in with a stream that can\n"
"	be read to get the output. Defaults to NIL.\n"
"     :if-output-exists (when :output is the name of a file) -\n"
"        can be one of:\n"
"           :error (default) - generates an error if the file already "
"exists.\n"
"           :supersede - output from the program supersedes the file.\n"
"           :append - output from the program is appended to the file.\n"
"           nil - run-program returns nil without doing anything.\n"
"     :error and :if-error-exists - \n"
"        Same as :output and :if-output-exists, except that :error can also "
"be\n"
"	specified as :output in which case all error output is routed to the\n"
"	same place as normal output.\n"
"     :status-hook -\n"
"        This is a function the system calls whenever the status of the\n"
"        process changes.  The function takes the process as an argument.\n"
"     :external-format -\n"
"        This is the external-format used for communication with the subproce"
"ss.\n"
"     :element-type -\n"
"        When a stream is created for :input or :output, the stream\n"
"        uses this element-type instead of the default 'BASE-CHAR type.\n"
""
msgstr ""

#: src/code/run-program.lisp
msgid "All args to program must be simple strings -- ~S."
msgstr ""

#: src/code/run-program.lisp
msgid "Could not fork child process: ~A"
msgstr ""

#: src/code/run-program.lisp
msgid "Could not select on sub-process: ~A"
msgstr ""

#: src/code/run-program.lisp
msgid "Could not read input from sub-process: ~A"
msgstr ""

#: src/code/run-program.lisp
msgid "Could not open \"/dev/null\": ~A"
msgstr ""

#: src/code/run-program.lisp
msgid "Could not create pipe: ~A"
msgstr ""

#: src/code/run-program.lisp
msgid "Direction must be either :INPUT or :OUTPUT, not ~S"
msgstr ""

#: src/code/run-program.lisp
msgid "Could not duplicate file descriptor: ~A"
msgstr ""

#: src/code/run-program.lisp
msgid "Could not open a temporary file in /tmp"
msgstr ""

#: src/code/run-program.lisp
msgid "Invalid option to run-program: ~S"
msgstr ""

#: src/code/loop.lisp
msgid ""
"If not NIL, this must be a list of two things:\n"
"a LET-like macro, and a SETQ-like macro, which perform LOOP-style destructur"
"ing."
msgstr ""

#: src/code/loop.lisp
msgid "LOOP-BODY called with non-synched before- and after-loop lists."
msgstr ""

#: src/code/loop.lisp
msgid "~?~%Current LOOP context:~{ ~S~}."
msgstr ""

#: src/code/loop.lisp
msgid "LOOP couldn't verify that ~S is a subtype of the required type ~S."
msgstr ""

#: src/code/loop.lisp
msgid "Specified data type ~S is not a subtype of ~S."
msgstr ""

#: src/code/loop.lisp
msgid ""
"Causes the iteration to terminate \"normally\", the same as implicit\n"
"termination by an iteration driving clause, or by use of WHILE or\n"
"UNTIL -- the epilogue code (if any) will be run, and any implicitly\n"
"collected result will be returned as the value of the LOOP."
msgstr ""

#: src/code/loop.lisp
msgid "~S found where LOOP keyword expected."
msgstr ""

#: src/code/loop.lisp
msgid "Secondary clause misplaced at top level in LOOP macro: ~S ~S ~S ..."
msgstr ""

#: src/code/loop.lisp
msgid "~S is an unknown keyword in LOOP macro."
msgstr ""

#: src/code/loop.lisp
msgid "LOOP source code ran out when another token was expected."
msgstr ""

#: src/code/loop.lisp
msgid "Compound form expected, but found ~A."
msgstr ""

#: src/code/loop.lisp
msgid "LOOP code ran out where a form was expected."
msgstr ""

#: src/code/loop.lisp
msgid ""
"LOOP clause is providing a value for the iteration,~@\n"
"	        however one was already established by a ~S clause."
msgstr ""

#: src/code/loop.lisp
msgid ""
"~:[This LOOP~;The LOOP ~:*~S~] clause is not permitted inside a "
"conditional."
msgstr ""

#: src/code/loop.lisp
msgid "This LOOP clause is not permitted with anonymous collectors."
msgstr ""

#: src/code/loop.lisp
msgid ""
"This anonymous collection LOOP clause is not permitted with aggregate "
"booleans."
msgstr ""

#: src/code/loop.lisp
msgid ""
"~S found where a LOOP keyword, LOOP type keyword, or LOOP type pattern "
"expected."
msgstr ""

#: src/code/loop.lisp
msgid "~S found where a LOOP keyword or LOOP type keyword expected."
msgstr ""

#: src/code/loop.lisp
msgid "Destructuring type pattern ~S contains unrecognized type keyword ~S."
msgstr ""

#: src/code/loop.lisp
msgid "Destructuring type pattern ~S doesn't match variable pattern ~S."
msgstr ""

#: src/code/loop.lisp
msgid "Duplicated LOOP iteration variable ~S."
msgstr ""

#: src/code/loop.lisp
msgid "Duplicated variable ~S in LOOP parallel binding."
msgstr ""

#: src/code/loop.lisp
msgid "Bad variable ~S somewhere in LOOP."
msgstr ""

#: src/code/loop.lisp
msgid "Variable ~S has already been used"
msgstr ""

#: src/code/loop.lisp
msgid "Invalid LOOP variable passed in: ~S."
msgstr ""

#: src/code/loop.lisp
msgid "~S found where keyword expected getting LOOP clause after ~S."
msgstr ""

#: src/code/loop.lisp
msgid "~S does not introduce a LOOP clause that can follow ~S."
msgstr ""

#: src/code/loop.lisp
msgid "~S is an invalid name for your LOOP."
msgstr ""

#: src/code/loop.lisp
msgid "The NAMED ~S clause occurs too late."
msgstr ""

#: src/code/loop.lisp
msgid "You may only use one NAMED clause in your loop: NAMED ~S ... NAMED ~S."
msgstr ""

#: src/code/loop.lisp
msgid "Value accumulation recipient name, ~S, is not a symbol."
msgstr ""

#: src/code/loop.lisp
msgid "Variable ~S cannot be used in INTO clause"
msgstr ""

#: src/code/loop.lisp
msgid ""
"Incompatible kinds of LOOP value accumulation specified for collecting~@\n"
"		    ~:[as the value of the LOOP~;~:*INTO ~S~]: ~S and ~S."
msgstr ""

#: src/code/loop.lisp
msgid ""
"Unequal datatypes specified in different LOOP value accumulations~@\n"
"		   into ~S: ~S and ~S."
msgstr ""

#: src/code/loop.lisp
msgid "Iteration in LOOP follows body code."
msgstr ""

#: src/code/loop.lisp
msgid "~S is an unknown keyword in FOR or AS clause in LOOP."
msgstr ""

#: src/code/loop.lisp
msgid "Use of QUOTE around stepping function in LOOP will be left verbatim."
msgstr ""

#: src/code/loop.lisp
msgid "~S found where ITS or EACH expected in LOOP iteration path syntax."
msgstr ""

#: src/code/loop.lisp
msgid "Unrecognizable LOOP iteration path syntax.  Missing EACH or THE?"
msgstr ""

#: src/code/loop.lisp
msgid "~S found where a LOOP iteration path name was expected."
msgstr ""

#: src/code/loop.lisp
msgid "~S is not the name of a LOOP iteration path."
msgstr ""

#: src/code/loop.lisp
msgid "\"Inclusive\" iteration is not possible with the ~S LOOP iteration path."
msgstr ""

#: src/code/loop.lisp
msgid "Unused USING variables: ~S."
msgstr ""

#: src/code/loop.lisp
msgid ""
"Value passed back by LOOP iteration path function for path ~S has invalid "
"length."
msgstr ""

#: src/code/loop.lisp
msgid "A ~S prepositional phrase occurs multiply for some LOOP clause."
msgstr ""

#: src/code/loop.lisp
msgid "Preposition ~S used when some other preposition has subsumed it."
msgstr ""

#: src/code/loop.lisp
msgid ""
"The variable substitution for ~S occurs twice in a USING phrase,~@\n"
"		        with ~S and ~S."
msgstr ""

#: src/code/loop.lisp
msgid ""
"~S invalid preposition in sequencing or sequence path.~@\n"
"	       Invalid prepositions specified in iteration path descriptor or "
"something?"
msgstr ""

#: src/code/loop.lisp
msgid "Conflicting stepping directions in LOOP sequencing path"
msgstr ""

#: src/code/loop.lisp
msgid "Missing OF or IN phrase in sequence path"
msgstr ""

#: src/code/loop.lisp
msgid "Don't know where to start stepping."
msgstr ""

#: src/code/loop.lisp
msgid "Too many prepositions!"
msgstr ""

#: src/code/loop.lisp
msgid "Missing OF or IN in ~S iteration path."
msgstr ""

#: src/code/loop.lisp
msgid "Unknown preposition ~S"
msgstr ""

#: src/code/loop.lisp
msgid "Destructuring is not valid for package symbol iteration."
msgstr ""

#: src/code/loop.lisp
msgid "Destructuring is not valid for string codepoint iteration."
msgstr ""

#: src/code/loop.lisp
msgid "Destructuring is not valid for string glyph iteration."
msgstr ""

#: src/code/stream-vector-io.lisp
msgid "endian-swap ~a is illegal for element-type of vector ~a"
msgstr ""

#: src/code/stream-vector-io.lisp
msgid ""
"Read from Stream into Vector.  The Start and End indices of Vector\n"
"  is in octets, and must be an multiple of the octets per element of\n"
"  the vector element.  The keyword argument :Endian-Swap specifies any\n"
"  endian swapping to be done. "
msgstr ""

#: src/code/stream-vector-io.lisp
msgid "Wrong vector type ~a for read-vector on stream ~a."
msgstr ""

#: src/code/stream-vector-io.lisp
msgid ""
"Write Vector to Stream.  The Start and End indices of Vector is in\n"
"  octets, and must be an multiple of the octets per element of the\n"
"  vector element.  The keyword argument :Endian-Swap specifies any\n"
"  endian swapping to be done. "
msgstr ""

#: src/code/foreign.lisp
msgid "Could not create temporary file ~S: ~A"
msgstr ""

#: src/code/foreign.lisp
msgid "Make sure the header starts with the ELF magic value."
msgstr ""

#: src/code/foreign.lisp
msgid "Return the `osabi' field in the padding of the ELF file."
msgstr ""

#: src/code/foreign.lisp
msgid "Given a file type number, determine whether the file is executable."
msgstr ""

#: src/code/foreign.lisp
msgid "Make sure the header starts with the mach-o magic value."
msgstr ""

#: src/code/foreign.lisp
msgid ""
"Parse symbol table file created by load-foreign script.  Modified\n"
"to skip undefined symbols which don't have an address."
msgstr ""

#: src/code/foreign.lisp
msgid ""
"Load-foreign loads a list of C object files into a running Lisp.  The files\n"
"  argument should be a single file or a list of files.  The files may be\n"
"  specified as namestrings or as pathnames.  The libraries argument should "
"be a\n"
"  list of library files as would be specified to ld.  They will be searched "
"in\n"
"  the order given.  The default is just \"-lc\", i.e., the C library.  The\n"
"  base-file argument is used to specify a file to use as the starting place "
"for\n"
"  defined symbols.  The default is the C start up code for Lisp.  The env\n"
"  argument is the Unix environment variable definitions for the invocation "
"of\n"
"  the linker.  The default is the environment passed to Lisp."
msgstr ""

#: src/code/foreign.lisp
msgid "Lazy function call binding"
msgstr ""

#: src/code/foreign.lisp
msgid "Immediate function call binding"
msgstr ""

#: src/code/foreign.lisp
msgid "Mask of binding time value"
msgstr ""

#: src/code/foreign.lisp
msgid ""
"If set the symbols of the loaded object and its dependencies are\n"
"   made visible as if the object were linked directly into the program"
msgstr ""

#: src/code/foreign.lisp
msgid ""
"Load C object files into the running Lisp. The FILES argument\n"
"should be a single file or a list of files. The files may be specified\n"
"as namestrings or as pathnames. The LIBRARIES argument should be a\n"
"list of library files as would be specified to ld. They will be\n"
"searched in the order given. The default is just \"-lc\", i.e., the C\n"
"library. The BASE-FILE argument is used to specify a file to use as\n"
"the starting place for defined symbols. The default is the C start up\n"
"code for Lisp. The ENV argument is the Unix environment variable\n"
"definitions for the invocation of the linker. The default is the\n"
"environment passed to Lisp."
msgstr ""

#: src/code/foreign.lisp
msgid "Can't open global symbol table: ~S"
msgstr ""

#: src/code/foreign.lisp
msgid "Can't open object ~S: ~S"
msgstr ""

#: src/code/foreign.lisp
msgid "LOAD-OBJECT-FILE: Unresolved symbols in file ~S: ~S"
msgstr ""

#: src/code/foreign.lisp
msgid "Couldn't open library ~S: ~S"
msgstr ""

#: src/code/foreign.lisp
msgid "Reloaded library ~S~%"
msgstr ""

#: src/code/foreign.lisp
msgid "Ignore library and continue"
msgstr ""

#: src/code/foreign.lisp
msgid "Try reloading again"
msgstr ""

#: src/code/foreign.lisp
msgid "Choose new library path"
msgstr ""

#: src/code/foreign.lisp
msgid "Enter new library path: "
msgstr ""

#: src/code/foreign.lisp
msgid ";;; Opening as shared library ~A ...~%"
msgstr ""

#: src/code/foreign.lisp
msgid ";;; Done.~%"
msgstr ""

#: src/code/foreign.lisp
msgid ";;; Trying as object file ~A...~%"
msgstr ""

#: src/code/foreign.lisp
msgid ";;; Running ~A...~%"
msgstr ""

#: src/code/foreign.lisp
msgid "Could not run ~A"
msgstr ""

#: src/code/foreign.lisp
msgid "~A failed:~%~A"
msgstr ""

#: src/code/foreign.lisp
msgid "File does not exist: ~A."
msgstr ""

#: src/code/internet.lisp
msgid "AList of socket kinds and protocol values."
msgstr ""

#: src/code/internet.lisp
msgid "Internet protocol :DATA-GRAM is deprecated. Using :DATAGRAM"
msgstr ""

#: src/code/internet.lisp
msgid "Invalid kind (~S) for internet domain sockets."
msgstr ""

#: src/code/internet.lisp
msgid ""
"Return a host-entry for the given host. The host may be an address\n"
"  string or an IP address in host order."
msgstr ""

#: src/code/internet.lisp
msgid "Error creating socket: ~A"
msgstr ""

#: src/code/internet.lisp
msgid "Error connecting socket to [~A]: ~A"
msgstr ""

#: src/code/internet.lisp
msgid "Error binding socket to path ~a: ~a"
msgstr ""

#: src/code/internet.lisp
msgid "Error listening to socket: ~A"
msgstr ""

#: src/code/internet.lisp
msgid "Error accepting a connection: ~A"
msgstr ""

#: src/code/internet.lisp
msgid "bind Socket to (local) Host and Port"
msgstr ""

#: src/code/internet.lisp
msgid "Error binding socket to port ~A: ~A"
msgstr ""

#: src/code/internet.lisp
msgid "Unknown host: ~S."
msgstr ""

#: src/code/internet.lisp
msgid "The host may be an address string or an IP address in host order."
msgstr ""

#: src/code/internet.lisp
msgid "Error connecting socket to [~A:~A]: ~A"
msgstr ""

#: src/code/internet.lisp
msgid "Get an integer value socket option."
msgstr ""

#: src/code/internet.lisp
msgid "Set an integer value socket option."
msgstr ""

#: src/code/internet.lisp
msgid "Error ~S setting socket option on socket ~D."
msgstr ""

#: src/code/internet.lisp
msgid "Error closing socket: ~A"
msgstr ""

#: src/code/internet.lisp
msgid "Return the peer host address and port in host order."
msgstr ""

#: src/code/internet.lisp
msgid "Error ~s getting peer host and port on FD ~d."
msgstr ""

#: src/code/internet.lisp
msgid "Error ~s getting socket host and port on FD ~d."
msgstr ""

#: src/code/internet.lisp
msgid "Ignore it"
msgstr ""

#: src/code/internet.lisp
msgid "Error recving oob data on ~A: ~A"
msgstr ""

#: src/code/internet.lisp
msgid "No oob handler defined for ~S on ~A"
msgstr ""

#: src/code/internet.lisp
msgid "Got a SIGURG, but couldn't find any out-of-band data."
msgstr ""

#: src/code/internet.lisp
msgid "Arrange to funcall HANDLER when CHAR shows up out-of-band on FD."
msgstr ""

#: src/code/internet.lisp
msgid "Remove any handlers for CHAR on FD."
msgstr ""

#: src/code/internet.lisp
msgid "Remove all handlers for FD."
msgstr ""

#: src/code/internet.lisp
msgid "Error sending ~S OOB to across ~A: ~A"
msgstr ""

#: src/code/internet.lisp
msgid ""
"A packaging of the unix recvfrom call.  Returns three values:\n"
"bytecount, source address as integer, and source port.  bytecount\n"
"can of course be negative, to indicate faults."
msgstr ""

#: src/code/internet.lisp
msgid "A packaging of the unix sendto call.  Return value like sendto"
msgstr ""

#: src/code/internet.lisp
msgid ""
"A packaging of the unix shutdown call.  An error is signaled if shutdown "
"fails."
msgstr ""

#: src/code/internet.lisp
msgid "Error on shutdown of socket: ~A"
msgstr ""

#: src/code/internet.lisp
msgid ""
"Return a network stream.  HOST may be an address string or an integer\n"
"IP address."
msgstr ""

#: src/code/internet.lisp
msgid "Unknown host format: ~S."
msgstr ""

#: src/code/internet.lisp
msgid "network connection to ~A"
msgstr ""

#: src/code/internet.lisp
msgid "network connection from ~D.~D.~D.~D:~D"
msgstr ""

#: src/code/wire.lisp
msgid "The wire the form we are currently evaluating came across."
msgstr ""

#: src/code/wire.lisp
msgid "Unique identifier for this host."
msgstr ""

#: src/code/wire.lisp
msgid "Unique identifier for this process."
msgstr ""

#: src/code/wire.lisp
msgid "Hash table mapping local objects to the corresponding remote id."
msgstr ""

#: src/code/wire.lisp
msgid "Hash table mapping remote id's to the curresponding local object."
msgstr ""

#: src/code/wire.lisp
msgid "Next available id for remote objects."
msgstr ""

#: src/code/wire.lisp
msgid "There is a problem with ~A."
msgstr ""

#: src/code/wire.lisp
msgid "Received EOF on ~A."
msgstr ""

#: src/code/wire.lisp
msgid "Error ~A ~A: ~A."
msgstr ""

#: src/code/wire.lisp
msgid "Returns T iff the given remote object is defined locally."
msgstr ""

#: src/code/wire.lisp
msgid ""
"Returns T iff the two objects refer to the same (eq) object in the same\n"
"  process."
msgstr ""

#: src/code/wire.lisp
msgid ""
"Return the associated value for the given remote object. It is an error if\n"
"  the remote object was not created in this process or if\n"
"  FORGET-REMOTE-TRANSLATION has been called on this remote object."
msgstr ""

#: src/code/wire.lisp
msgid "~S is defined is a different process."
msgstr ""

#: src/code/wire.lisp
msgid "Use the value of NIL"
msgstr ""

#: src/code/wire.lisp
msgid "No value for ~S -- FORGET-REMOTE-TRANSLATION was called to early."
msgstr ""

#: src/code/wire.lisp
msgid "Convert the given local object to a remote object."
msgstr ""

#: src/code/wire.lisp
msgid ""
"Forget the translation from the given local to the corresponding remote\n"
"object. Passing that remote object to remote-object-value will new return "
"NIL."
msgstr ""

#: src/code/wire.lisp
msgid ""
"Return T iff anything is in the input buffer or available on the socket."
msgstr ""

#: src/code/wire.lisp
msgid "listening to"
msgstr ""

#: src/code/wire.lisp
msgid ""
"Read data off the socket, filling the input buffer. The buffer is cleared\n"
"first. If fill-input-buffer returns, it is guarenteed that there will be at\n"
"least one byte in the input buffer. If EOF was reached, as wire-eof error\n"
"is signaled."
msgstr ""

#: src/code/wire.lisp
msgid "reading"
msgstr ""

#: src/code/wire.lisp
msgid "Return the next byte from the wire."
msgstr ""

#: src/code/wire.lisp
msgid ""
"Read a number off the wire. Numbers are 4 bytes in network order.\n"
"The optional argument controls weather or not the number should be considere"
"d\n"
"signed (defaults to T)."
msgstr ""

#: src/code/wire.lisp
msgid ""
"Reads an arbitrary integer sent by WIRE-OUTPUT-BIGNUM from the wire and\n"
"   return it."
msgstr ""

#: src/code/wire.lisp
msgid "Reads a string from the wire. The first four bytes spec the size."
msgstr ""

#: src/code/wire.lisp
msgid "Reads the next object from the wire and returns it."
msgstr ""

#: src/code/wire.lisp
msgid ""
"Attempt to read symbol, ~A, of wire into non-existent ~\n"
"		       package, ~A."
msgstr ""

#: src/code/wire.lisp
msgid ""
"Send any info still in the output buffer down the wire and clear it. "
"Nothing\n"
"harmfull will happen if called when the output buffer is empty."
msgstr ""

#: src/code/wire.lisp
msgid "writing"
msgstr ""

#: src/code/wire.lisp
msgid "Not everything wrote."
msgstr ""

#: src/code/wire.lisp
msgid "Output the given (8-bit) byte on the wire."
msgstr ""

#: src/code/wire.lisp
msgid "Output the given (32-bit) number on the wire."
msgstr ""

#: src/code/wire.lisp
msgid ""
"Outputs an arbitrary integer, but less effeciently than WIRE-OUTPUT-NUMBER."
msgstr ""

#: src/code/wire.lisp
msgid ""
"Output the given string. First output the length using WIRE-OUTPUT-NUMBER,\n"
"then output the bytes."
msgstr ""

#: src/code/wire.lisp
msgid ""
"Output the given object on the given wire. If cache-it is T, enter this\n"
"object in the cache for future reference."
msgstr ""

#: src/code/wire.lisp
msgid "Error: Cannot output objects of type ~s across a wire."
msgstr ""

#: src/code/wire.lisp
msgid "Send the function and args down the wire as a funcall."
msgstr ""

#: src/code/remote.lisp
msgid "AList of wire . remote-wait structs"
msgstr ""

#: src/code/remote.lisp
msgid ""
"Evaluates the given forms remotly. No values are returned, as the remote\n"
"evaluation is asyncronus."
msgstr ""

#: src/code/remote.lisp
msgid ""
"Bind VARS to the multiple values of FORM (which is executed remotely). The\n"
"forms in BODY are only executed if the remote function returned (as apposed\n"
"to aborting due to a throw)."
msgstr ""

#: src/code/remote.lisp
msgid ""
"Execute the single form remotly. The value of the form is returned.\n"
"  The optional form on-server-unwind is only evaluated if the server "
"unwinds\n"
"  instead of returning."
msgstr ""

#: src/code/remote.lisp
msgid ""
"Create a request server on the given port.  Whenever anyone connects to it,\n"
"   call the given function with the newly created wire and the address of "
"the\n"
"   connector.  If the function returns NIL, the connection is destroyed;\n"
"   otherwise, it is accepted.  This returns a manifestation of the server "
"that\n"
"   DESTROY-REQUEST-SERVER accepts to kill the request server."
msgstr ""

#: src/code/remote.lisp
msgid "Quit accepting connections to the given request server."
msgstr ""

#: src/code/remote.lisp
msgid ""
"Connect to a remote request server addressed with the given host and port\n"
"   pair.  This returns the created wire."
msgstr ""

#: src/code/defstruct.lisp
msgid ""
"Controls compiling DEFSTRUCT :print-function and :print-method\n"
"   options according to ANSI spec. MUST be NIL to compile CMUCL & PCL"
msgstr ""

#: src/code/defstruct.lisp
msgid "Allocate a new instance with LENGTH data slots."
msgstr ""

#: src/code/defstruct.lisp
msgid "Given an instance, return its length."
msgstr ""

#: src/code/defstruct.lisp
msgid "Return the value from the INDEXth slot of INSTANCE.  This is SETFable."
msgstr ""

#: src/code/defstruct.lisp
msgid "Set the INDEXth slot of INSTANCE to NEW-VALUE."
msgstr ""

#: src/code/defstruct.lisp
msgid "Class not yet defined or was undefined: ~S"
msgstr ""

#: src/code/defstruct.lisp
msgid "Class is not a structure class: ~S"
msgstr ""

#: src/code/defstruct.lisp
msgid ""
"DEFSTRUCT {Name | (Name Option*)} {Slot | (Slot [Default] {Key Value}*)}\n"
"   Define the structure type Name.  Instances are created by MAKE-<name>, "
"which\n"
"   takes keyword arguments allowing initial slot values to the specified.\n"
"   A SETF'able function <name>-<slot> is defined for each slot to read&write"
"\n"
"   slot values.  <name>-p is a type predicate.\n"
"\n"
"   Popular DEFSTRUCT options (see manual for others):\n"
"\n"
"   (:CONSTRUCTOR Name)\n"
"   (:PREDICATE Name)\n"
"       Specify an alternate name for the constructor or predicate.\n"
"\n"
"   (:CONSTRUCTOR Name Lambda-List)\n"
"       Explicitly specify the name and arguments to create a BOA constructor"
"\n"
"       (which is more efficient when keyword syntax isn't necessary.)\n"
"\n"
"   (:INCLUDE Supertype Slot-Spec*)\n"
"       Make this type a subtype of the structure type Supertype.  The "
"optional\n"
"       Slot-Specs override inherited slot options.\n"
"\n"
"   Slot options:\n"
"\n"
"   :TYPE Type-Spec\n"
"       Asserts that the value of this slot is always of the specified type.\n"
"\n"
"   :READ-ONLY {T | NIL}\n"
"       If true, no setter function is defined for this slot."
msgstr ""

#: src/code/defstruct.lisp
msgid "defining structure ~A"
msgstr ""

#: src/code/defstruct.lisp
msgid "Disable package's definition lock then continue"
msgstr ""

#: src/code/defstruct.lisp
msgid "Defstruct already names a declaration: ~S."
msgstr ""

#: src/code/defstruct.lisp
msgid "Can't have more than one :INCLUDE option."
msgstr ""

#: src/code/defstruct.lisp
msgid "~S is a bad :TYPE for Defstruct."
msgstr ""

#: src/code/defstruct.lisp
msgid "The Defstruct option :NAMED takes no arguments."
msgstr ""

#: src/code/defstruct.lisp
msgid "Unknown DEFSTRUCT option~%  ~S"
msgstr ""

#: src/code/defstruct.lisp
msgid "Unrecognized DEFSTRUCT option: ~S"
msgstr ""

#: src/code/defstruct.lisp
msgid "Can't specify :OFFSET unless :TYPE is specified."
msgstr ""

#: src/code/defstruct.lisp
msgid "Silly to specify :PRINT-FUNCTION with :TYPE."
msgstr ""

#: src/code/defstruct.lisp
msgid "Silly to specify :MAKE-LOAD-FORM-FUN with :TYPE."
msgstr ""

#: src/code/defstruct.lisp
msgid "Duplicate slot name ~S."
msgstr ""

#: src/code/defstruct.lisp
msgid "Slot ~S must be read-only in subtype ~S."
msgstr ""

#: src/code/defstruct.lisp
msgid ""
"Keyword slot name indicates probable syntax ~\n"
"		      error in DEFSTRUCT -- ~S."
msgstr ""

#: src/code/defstruct.lisp
msgid ":TYPE option mismatch between structures ~S and ~S."
msgstr ""

#: src/code/defstruct.lisp
msgid ":TYPE'd defstruct ~S not found for inclusion."
msgstr ""

#: src/code/defstruct.lisp
msgid "(:CONSTRUCTOR NIL) combined with other :CONSTRUCTORs."
msgstr ""

#: src/code/defstruct.lisp
msgid ""
"~@<Non-overwritten accessor ~S does not access ~\n"
"                        slot with name ~S (accessing an inherited slot ~\n"
"                        instead).~:@>"
msgstr ""

#: src/code/defstruct.lisp
msgid "Obsolete structure accessor function called."
msgstr ""

#: src/code/defstruct.lisp
msgid "Structure for accessor ~S is not a ~S:~% ~S"
msgstr ""

#: src/code/defstruct.lisp
msgid "Structure for setter ~S is not a ~S:~% ~S"
msgstr ""

#: src/code/defstruct.lisp
msgid "New-Value for setter ~S is not a ~S:~% ~S."
msgstr ""

#: src/code/defstruct.lisp
msgid "Structure for copier is not a ~S:~% ~S"
msgstr ""

#: src/code/defstruct.lisp
msgid "Shouldn't happen!  Some strange thing in LAYOUT-INFO:~\n"
"		    ~%  ~S"
msgstr ""

#: src/code/defstruct.lisp
msgid ""
"Incompatibly redefining slots of structure class ~S~@\n"
"	  Make sure any uses of affected accessors are recompiled:~@\n"
"	  ~@[  These slots were moved to new positions:~%    ~S~%~]~\n"
"	  ~@[  These slots have new incompatible types:~%    ~S~%~]~\n"
"	  ~@[  These slots were deleted:~%    ~S~%~]"
msgstr ""

#: src/code/defstruct.lisp
msgid "Redefining class ~S incompatibly with the current ~\n"
"		definition."
msgstr ""

#: src/code/defstruct.lisp
msgid "Invalidate already loaded code and instances, use new definition."
msgstr ""

#: src/code/defstruct.lisp
msgid "Previously loaded ~S accessors will no longer work."
msgstr ""

#: src/code/defstruct.lisp
msgid ""
"Any old ~S instances will be in a bad way.~@\n"
"	       I hope you know what you're doing..."
msgstr ""

#: src/code/defstruct.lisp
msgid "Removing old subclasses of ~S:~%  ~S"
msgstr ""

#: src/code/defstruct.lisp
msgid "Return a copy of Structure with the same (EQL) slot values."
msgstr ""

#: src/code/defstruct.lisp
msgid "Copying an obsolete structure:~%  ~S"
msgstr ""

#: src/code/defstruct.lisp
msgid "Structures of type ~S cannot be dumped as constants."
msgstr ""

#: src/code/defmacro.lisp
msgid "A list of tests that do argument counting at expansion time."
msgstr ""

#: src/code/defmacro.lisp
msgid "Let bindings that are done to make lambda-list parsing possible."
msgstr ""

#: src/code/defmacro.lisp
msgid "Let bindings that the user has explicitly supplied."
msgstr ""

#: src/code/defmacro.lisp
msgid "Unsupplied optional and keyword arguments get this value defaultly."
msgstr ""

#: src/code/defmacro.lisp
msgid ""
"Returns as multiple-values a parsed body, any local-declarations that\n"
"   should be made where this body is inserted, and a doc-string if there is\n"
"   one."
msgstr ""

#: src/code/defmacro.lisp
msgid "&Whole must appear first in ~S lambda-list."
msgstr ""

#: src/code/defmacro.lisp
msgid "&environment not valid with ~S."
msgstr ""

#: src/code/defmacro.lisp
msgid "&environment only valid at top level of lambda-list."
msgstr ""

#: src/code/defmacro.lisp
msgid "Invalid ~a"
msgstr ""

#: src/code/defmacro.lisp
msgid "Ignore extra noise."
msgstr ""

#: src/code/defmacro.lisp
msgid ""
"More than variable, initform, and suppliedp ~\n"
"			    in &optional binding - ~S"
msgstr ""

#: src/code/defmacro.lisp
msgid "Non-symbol in lambda-list - ~S."
msgstr ""

#: src/code/defmacro.lisp
msgid "Illegal optional variable name: ~S"
msgstr ""

#: src/code/defmacro.lisp
msgid ""
"Takes a non-keyword symbol, symbol, and returns the corresponding keyword."
msgstr ""

#: src/code/defmacro.lisp
msgid "Illegal or ill-formed ~A argument in ~A~@[ ~S~]."
msgstr ""

#: src/code/defmacro.lisp
msgid "Error while parsing arguments to ~A in ~S:~%"
msgstr ""

#: src/code/defmacro.lisp
msgid "Error while parsing arguments to ~A ~S:~%"
msgstr ""

#: src/code/defmacro.lisp
msgid "Bogus sublist:~%  ~S~%to satisfy lambda-list:~%  ~:S~%"
msgstr ""

#: src/code/defmacro.lisp
msgid ""
"Invalid number of elements in:~%  ~:S~%~\n"
"	     to satisfy lambda-list:~%  ~:S~%"
msgstr ""

#: src/code/defmacro.lisp
msgid "Expected at least ~D"
msgstr ""

#: src/code/defmacro.lisp
msgid "Expected exactly ~D"
msgstr ""

#: src/code/defmacro.lisp
msgid "Expected between ~D and ~D"
msgstr ""

#: src/code/defmacro.lisp
msgid ", but got ~D."
msgstr ""

#: src/compiler/globaldb.lisp
msgid "Define-Info-Class Class\n"
"  Define a new class of global information."
msgstr ""

#: src/compiler/globaldb.lisp
msgid ""
"Define-Info-Type Class Type default Type-Spec\n"
"  Define a new type of global information for Class.  Type is the symbol "
"name\n"
"  of the type, Default is the value for that type when it hasn't been set, "
"and\n"
"  Type-Spec is a type-specifier which values of the type must satisfy.  The\n"
"  default expression is evaluated each time the information is needed, with\n"
"  Name bound to the name for which the information is being looked up.  If "
"the\n"
"  default evaluates to something with the second value true, then the "
"second\n"
"  value of Info will also be true."
msgstr ""

#: src/compiler/globaldb.lisp
msgid "Type not defined yet."
msgstr ""

#: src/compiler/globaldb.lisp
msgid "~S is not a defined info class."
msgstr ""

#: src/compiler/globaldb.lisp
msgid "~S is not a defined info type."
msgstr ""

#: src/compiler/globaldb.lisp
msgid "Out of INFO type numbers!"
msgstr ""

#: src/compiler/globaldb.lisp
msgid "Redefine it."
msgstr ""

#: src/compiler/globaldb.lisp
msgid "Changing type number for ~A ~A."
msgstr ""

#: src/compiler/globaldb.lisp
msgid "Go for it."
msgstr ""

#: src/compiler/globaldb.lisp
msgid "Reusing type number for ~A ~A."
msgstr ""

#: src/compiler/globaldb.lisp
msgid ""
"Return the information of the specified Type and Class for Name.\n"
"   The second value is true if there is any such information recorded.  If\n"
"   there is no information, the first value is the default and the second "
"value\n"
"   is NIL."
msgstr ""

#: src/compiler/globaldb.lisp
msgid "Set the global information for Name."
msgstr ""

#: src/compiler/globaldb.lisp
msgid ""
"DO-INFO (Env &Key Name Class Type Value) Form*\n"
"  Iterate over all the values stored in the Info-Env Env.  Name is bound to\n"
"  the entry's name, Class and Type are bound to the class and type\n"
"  (represented as strings), and Value is bound to the entry's value."
msgstr ""

#: src/compiler/globaldb.lisp
msgid ""
"Return a new compact info environment that holds the same information as\n"
"  Env."
msgstr ""

#: src/compiler/knownfun.lisp src/compiler/globaldb.lisp
msgid "No info environment?"
msgstr ""

#: src/compiler/knownfun.lisp src/compiler/globaldb.lisp
msgid "Cannot modify this environment: ~S."
msgstr ""

#: src/compiler/globaldb.lisp
msgid "0 is not a legal INFO name."
msgstr ""

#: src/compiler/globaldb.lisp
msgid ""
"Clear the information of the specified Type and Class for Name in the\n"
"  current environment, allowing any inherited info to become visible.  We\n"
"  return true if there was any info."
msgstr ""

#: src/code/macros.lisp
msgid ""
"This function is to parse the declarations and doc-string out of the body "
"of\n"
"  a defun-like form.  Body is the list of stuff which is to be parsed.\n"
"  Environment is ignored.  If Doc-String-Allowed is true, then a doc string\n"
"  will be parsed out of the body and returned.  If it is false then a "
"string\n"
"  will terminate the search for declarations.  Three values are returned: "
"the\n"
"  tail of Body after the declarations and doc strings, a list of declare "
"forms,\n"
"  and the doc-string, or NIL if none."
msgstr ""

#: src/code/macros.lisp
msgid "defining macro ~A"
msgstr ""

#: src/code/macros.lisp
msgid "Disable the package's definition-lock then continue"
msgstr ""

#: src/code/macros.lisp
msgid "Define a compiler-macro for NAME."
msgstr ""

#: src/code/macros.lisp
msgid "~S is not a valid function name."
msgstr ""

#: src/compiler/ir1tran.lisp src/code/macros.lisp
msgid "Symbol macro name is not a symbol: ~S."
msgstr ""

#: src/code/macros.lisp
msgid "Symbol macro name already declared special: ~S."
msgstr ""

#: src/code/macros.lisp
msgid "Symbol macro name already declared constant: ~S."
msgstr ""

#: src/code/macros.lisp
msgid "Syntax like DEFMACRO, but defines a new type."
msgstr ""

#: src/code/macros.lisp
msgid "~S -- Type name not a symbol."
msgstr ""

#: src/code/macros.lisp
msgid "defining type ~A"
msgstr ""

#: src/code/macros.lisp
msgid "Disable package's definition-lock then continue"
msgstr ""

#: src/code/macros.lisp
msgid "Deftype already names a declaration: ~S."
msgstr ""

#: src/code/macros.lisp
msgid "Illegal to redefine standard type: ~S."
msgstr ""

#: src/code/macros.lisp
msgid "Redefining class ~S to be a DEFTYPE."
msgstr ""

#: src/code/macros.lisp
msgid ""
"Syntax like DEFMACRO, but creates a Setf-Expansion generator.  The body\n"
"  must be a form that returns the five magical values."
msgstr ""

#: src/code/macros.lisp
msgid "~S -- Access-function name not a symbol in DEFINE-SETF-EXPANDER."
msgstr ""

#: src/code/macros.lisp
msgid "Obsolete, use define-setf-expander."
msgstr ""

#: src/code/macros.lisp
msgid ""
"Defining setf macro for destruct slot accessor; redefining as ~\n"
"	        a normal function:~%  ~S"
msgstr ""

#: src/code/macros.lisp
msgid "Defining setf macro for ~S, but ~S is fbound."
msgstr ""

#: src/code/macros.lisp
msgid "Bind the variables in LAMBDA-LIST to the contents of ARG-LIST."
msgstr ""

#: src/code/macros.lisp
msgid ""
"For defining global constants at top level.  The DEFCONSTANT says that the\n"
"  value is constant and may be compiled into code.  If the variable already "
"has\n"
"  a value, and this is not equal to the init, an error is signalled.  The "
"third\n"
"  argument is an optional documentation string for the variable."
msgstr ""

#: src/code/macros.lisp
msgid "Go ahead and change the value."
msgstr ""

#: src/code/macros.lisp
msgid "Constant ~S being redefined."
msgstr ""

#: src/code/macros.lisp
msgid ""
"For defining global variables at top level.  Declares the variable\n"
"  SPECIAL and, optionally, initializes it.  If the variable already has a\n"
"  value, the old value is not clobbered.  The third argument is an optional\n"
"  documentation string for the variable."
msgstr ""

#: src/code/macros.lisp
msgid ""
"Defines a parameter that is not normally changed by the program,\n"
"  but that may be changed without causing an error.  Declares the\n"
"  variable special and sets its value to VAL.  The third argument is\n"
"  an optional documentation string for the parameter."
msgstr ""

#: src/code/macros.lisp
msgid ""
"First arg is a predicate.  If it is non-null, the rest of the forms are\n"
"  evaluated as a PROGN."
msgstr ""

#: src/code/macros.lisp
msgid ""
"First arg is a predicate.  If it is null, the rest of the forms are\n"
"  evaluated as a PROGN."
msgstr ""

#: src/code/macros.lisp
msgid "Cond clause should be a non-empty list: ~S."
msgstr ""

#: src/code/macros.lisp
msgid "Varlist is not a list of symbols: ~S."
msgstr ""

#: src/code/macros.lisp
msgid ""
"Evaluates FORM and returns the Nth value (zero based).  This involves no\n"
"  consing when N is a trivial constant integer."
msgstr ""

#: src/code/macros.lisp
msgid ""
"Returns five values needed by the SETF machinery: a list of temporary\n"
"   variables, a list of values with which to fill them, a list of temporarie"
"s\n"
"   for the new values, the setting function, and the accessing function."
msgstr ""

#: src/code/macros.lisp
msgid "Obsolete: use GET-SETF-EXPANSION."
msgstr ""

#: src/code/macros.lisp
msgid "Obsolete: use GET-SETF-EXPANSION and handle multiple store values."
msgstr ""

#: src/code/macros.lisp
msgid ""
"GET-SETF-METHOD used for a form with multiple store ~\n"
"	      variables:~%  ~S"
msgstr ""

#: src/code/macros.lisp
msgid ""
"Associates a SETF update function or macro with the specified access\n"
"  function or macro.  The format is complex.  See the manual for\n"
"  details."
msgstr ""

#: src/code/macros.lisp
msgid "Ill-formed DEFSETF for ~S."
msgstr ""

#: src/code/macros.lisp
msgid ""
"Takes pairs of arguments like SETQ.  The first is a place and the second\n"
"  is the value that is supposed to go into that place.  Returns the last\n"
"  value.  The place argument may be any of the access forms for which SETF\n"
"  knows a corresponding setting form."
msgstr ""

#: src/code/macros.lisp
msgid "Odd number of args to SETF."
msgstr ""

#: src/code/macros.lisp
msgid ""
"This is to SETF as PSETQ is to SETQ.  Args are alternating place\n"
"  expressions and values to go into those places.  All of the subforms and\n"
"  values are determined, left to right, and only then are the locations\n"
"  updated.  Returns NIL."
msgstr ""

#: src/code/macros.lisp
msgid "Odd number of args to PSETF."
msgstr ""

#: src/code/macros.lisp
msgid ""
"One or more SETF-style place expressions, followed by a single\n"
"   value expression.  Evaluates all of the expressions in turn, then\n"
"   assigns the value of each expression to the place on its left,\n"
"   returning the value of the leftmost."
msgstr ""

#: src/code/macros.lisp
msgid ""
"Takes any number of SETF-style place expressions.  Evaluates all of the\n"
"   expressions in turn, then assigns to each place the value of the form to\n"
"   its right.  The rightmost form gets the value of the leftmost.\n"
"   Returns NIL."
msgstr ""

#: src/code/macros.lisp
msgid "Creates a new read-modify-write macro like PUSH or INCF."
msgstr ""

#: src/code/macros.lisp
msgid "Non-symbol &rest arg in definition of ~S."
msgstr ""

#: src/code/macros.lisp
msgid "Illegal stuff after &rest arg in Define-Modify-Macro."
msgstr ""

#: src/code/macros.lisp
msgid "~S not allowed in Define-Modify-Macro lambda list."
msgstr ""

#: src/code/macros.lisp
msgid "Illegal stuff in lambda list of Define-Modify-Macro."
msgstr ""

#: src/code/macros.lisp
msgid ""
"Takes an object and a location holding a list.  Conses the object onto\n"
"  the list, returning the modified list.  OBJ is evaluated before PLACE."
msgstr ""

#: src/code/macros.lisp
msgid ""
"Takes an object and a location holding a list.  If the object is already\n"
"  in the list, does nothing.  Else, conses the object onto the list.  "
"Returns\n"
"  NIL.  If there is a :TEST keyword, this is used for the comparison."
msgstr ""

#: src/code/macros.lisp
msgid ""
"The argument is a location holding a list.  Pops one item off the front\n"
"  of the list and returns it."
msgstr ""

#: src/code/macros.lisp
msgid ""
"The first argument is some location holding a number. This number is\n"
"  incremented by the second argument, DELTA, which defaults to 1."
msgstr ""

#: src/code/macros.lisp
msgid ""
"The first argument is some location holding a number. This number is\n"
"  decremented by the second argument, DELTA, which defaults to 1."
msgstr ""

#: src/code/macros.lisp
msgid ""
"Place may be any place expression acceptable to SETF, and is expected\n"
"  to hold a property list or ().  This list is destructively altered to\n"
"  remove the property specified by the indicator.  Returns T if such a\n"
"  property was present, NIL if not."
msgstr ""

#: src/code/macros.lisp
msgid "Setf of Apply is only defined for function args like #'symbol."
msgstr ""

#: src/code/macros.lisp
msgid ""
"The first argument is a byte specifier.  The second is any place form\n"
"  acceptable to SETF.  Replaces the specified byte of the number in this\n"
"  place with bits from the low-order end of the new value."
msgstr ""

#: src/code/macros.lisp
msgid ""
"The first argument is a byte specifier.  The second is any place form\n"
"  acceptable to SETF.  Replaces the specified byte of the number in this "
"place\n"
"  with bits from the corresponding position in the new value."
msgstr ""

#: src/code/macros.lisp
msgid "~S -- Bad clause in ~S."
msgstr ""

#: src/code/macros.lisp
msgid ""
"~<~A is a key designator only in the final otherwise-clause. ~\n"
"                                              Use (~A) to use it as a "
"normal-clause or move the clause to the ~\n"
"                                              correct position.~:@>"
msgstr ""

#: src/code/macros.lisp
msgid "Bad style to use ~S in ~S"
msgstr ""

#: src/code/macros.lisp
msgid "Supply a new value for ~S."
msgstr ""

#: src/code/macros.lisp
msgid ""
"CASE Keyform {({(Key*) | Key} Form*)}*\n"
"  Evaluates the Forms in the first clause with a Key EQL to the value\n"
"  of Keyform.  If a singleton key is T or Otherwise then the clause is\n"
"  a default clause."
msgstr ""

#: src/code/macros.lisp
msgid ""
"CCASE Keyform {({(Key*) | Key} Form*)}*\n"
"  Evaluates the Forms in the first clause with a Key EQL to the value of\n"
"  Keyform.  If none of the keys matches then a correctable error is\n"
"  signalled."
msgstr ""

#: src/code/macros.lisp
msgid ""
"ECASE Keyform {({(Key*) | Key} Form*)}*\n"
"  Evaluates the Forms in the first clause with a Key EQL to the value of\n"
"  Keyform.  If none of the keys matches then an error is signalled."
msgstr ""

#: src/code/macros.lisp
msgid ""
"TYPECASE Keyform {(Type Form*)}*\n"
"  Evaluates the Forms in the first clause for which TYPEP of Keyform\n"
"  and Type is true.  If a singleton key is T or Otherwise then the\n"
"  clause is a default clause."
msgstr ""

#: src/code/macros.lisp
msgid ""
"CTYPECASE Keyform {(Type Form*)}*\n"
"  Evaluates the Forms in the first clause for which TYPEP of Keyform and "
"Type\n"
"  is true.  If no form is satisfied then a correctable error is signalled."
msgstr ""

#: src/code/macros.lisp
msgid ""
"ETYPECASE Keyform {(Type Form*)}*\n"
"  Evaluates the Forms in the first clause for which TYPEP of Keyform and "
"Type\n"
"  is true.  If no form is satisfied then an error is signalled."
msgstr ""

#: src/code/macros.lisp
msgid ""
"Signals an error if the value of test-form is nil.  Continuing from this\n"
"   error using the CONTINUE restart will allow the user to alter the value "
"of\n"
"   some locations known to SETF, starting over with test-form.  Returns "
"nil."
msgstr ""

#: src/code/macros.lisp
msgid "The assertion ~S failed."
msgstr ""

#: src/code/macros.lisp
msgid "Retry assertion"
msgstr ""

#: src/code/macros.lisp
msgid " with new value for ~{~S~^, ~}."
msgid_plural " with new values for ~{~S~^, ~}."
msgstr[0] ""

#: src/code/macros.lisp
msgid "The old value of ~S is ~S.~\n"
"		  ~%Do you want to supply a new value? "
msgstr ""

#: src/code/macros.lisp
msgid "~&Type a form to be evaluated:~%"
msgstr ""

#: src/code/macros.lisp
msgid ""
"Signals an error of type type-error if the contents of place are not of the\n"
"   specified type.  If an error is signaled, this can only return if\n"
"   STORE-VALUE is invoked.  It will store into place and start over."
msgstr ""

#: src/code/macros.lisp
msgid "Supply a new value of ~S."
msgstr ""

#: src/code/macros.lisp
msgid "The value of ~S is ~S, which is not ~A."
msgstr ""

#: src/code/macros.lisp
msgid "The value of ~S is ~S, which is not of type ~S."
msgstr ""

#: src/code/macros.lisp
msgid ""
"The file whose name is Filespec is opened using the Open-args and\n"
"  bound to the variable Var. If the call to open is unsuccessful, the\n"
"  forms are not evaluated.  The Forms are executed, and when they\n"
"  terminate, normally or otherwise, the file is closed."
msgstr ""

#: src/code/macros.lisp
msgid ""
"The form stream should evaluate to a stream.  VAR is bound\n"
"   to the stream and the forms are evaluated as an implicit\n"
"   progn.  The stream is closed upon exit."
msgstr ""

#: src/code/macros.lisp
msgid ""
"Binds the Var to an input stream that returns characters from String and\n"
"  executes the body.  See manual for details."
msgstr ""

#: src/code/macros.lisp
msgid ""
"If STRING is specified, it must be a string with a fill pointer;\n"
"   the output is incrementally appended to the string (as if by use of\n"
"   VECTOR-PUSH-EXTEND)."
msgstr ""

#: src/code/macros.lisp
msgid ""
"DO ({(Var [Init] [Step])}*) (Test Exit-Form*) Declaration* Form*\n"
"  Iteration construct.  Each Var is initialized in parallel to the value of "
"the\n"
"  specified Init form.  On subsequent iterations, the Vars are assigned the\n"
"  value of the Step form (if any) in paralell.  The Test is evaluated "
"before\n"
"  each evaluation of the body Forms.  When the Test is true, the Exit-Forms\n"
"  are evaluated as a PROGN, with the result being the value of the DO.  A "
"block\n"
"  named NIL is established around the entire expansion, allowing RETURN to "
"be\n"
"  used as an laternate exit mechanism."
msgstr ""

#: src/code/macros.lisp
msgid ""
"DO* ({(Var [Init] [Step])}*) (Test Exit-Form*) Declaration* Form*\n"
"  Iteration construct.  Each Var is initialized sequentially (like LET*) to "
"the\n"
"  value of the specified Init form.  On subsequent iterations, the Vars are\n"
"  sequentially assigned the value of the Step form (if any).  The Test is\n"
"  evaluated before each evaluation of the body Forms.  When the Test is "
"true,\n"
"  the Exit-Forms are evaluated as a PROGN, with the result being the value\n"
"  of the DO.  A block named NIL is established around the entire expansion,\n"
"  allowing RETURN to be used as an laternate exit mechanism."
msgstr ""

#: src/code/macros.lisp
msgid ""
"PSETQ {var value}*\n"
"   Set the variables to the values, like SETQ, except that assignments\n"
"   happen in parallel, i.e. no assignments take place until all the\n"
"   forms have been evaluated."
msgstr ""

#: src/code/macros.lisp
msgid "variable ~S in PSETQ is not a SYMBOL"
msgstr ""

#: src/code/macros.lisp
msgid "Unknown declaration context: ~S."
msgstr ""

#: src/code/macros.lisp
msgid ""
"Context declaration spec should have context and at ~\n"
"	  least one DECLARE form:~%  ~S"
msgstr ""

#: src/code/macros.lisp
msgid ""
"WITH-COMPILATION-UNIT ({Key Value}*) Form*\n"
"  This form affects compilations that take place within its dynamic extent. "
" It\n"
"  is intended to be wrapped around the compilation of all files in the same\n"
"  system.  These keywords are defined:\n"
"    :OVERRIDE Boolean-Form\n"
"        One of the effects of this form is to delay undefined warnings \n"
"        until the end of the form, instead of giving them at the end of "
"each\n"
"        compilation.  If OVERRIDE is NIL (the default), then the outermost\n"
"        WITH-COMPILATION-UNIT form grabs the undefined warnings.  Specifying"
"\n"
"        OVERRIDE true causes that form to grab any enclosed warnings, even "
"if\n"
"        it is enclosed by another WITH-COMPILATION-UNIT.\n"
"    :OPTIMIZE Decl-Form\n"
"        Decl-Form should evaluate to an OPTIMIZE declaration specifier.  "
"This\n"
"        declaration changes the `global' policy for compilations within the\n"
"        body.\n"
"    :OPTIMIZE-INTERFACE Decl-Form\n"
"        Like OPTIMIZE, except that it specifies the value of the CMU "
"extension\n"
"        OPTIMIZE-INTERFACE policy (which controls argument type and syntax\n"
"        checking.)\n"
"    :CONTEXT-DECLARATIONS List-of-Context-Decls-Form\n"
"        This is a CMU extension which allows compilation to be controlled\n"
"        by pattern matching on the context in which a definition appears.  "
"The\n"
"        argument should evaluate to a list of lists of the form:\n"
"            (Context-Spec Declare-Form+)\n"
"        In the indicated context, the specified declare forms are inserted "
"at\n"
"        the head of each definition.  The declare forms for all contexts "
"that\n"
"	match are appended together, with earlier declarations getting\n"
"	predecence over later ones.  A simple example:\n"
"            :context-declarations\n"
"            '((:external (declare (optimize (safety 2)))))\n"
"        This will cause all functions that are named by external symbols to "
"be\n"
"        compiled with SAFETY 2.  The full syntax of context specs is:\n"
"	:INTERNAL, :EXTERNAL\n"
"	    True if the symbols is internal (external) in its home package.\n"
"	:UNINTERNED\n"
"	    True if the symbol has no home package.\n"
"	:ANONYMOUS\n"
"	    True if the function doesn't have any interesting name (not\n"
"	    DEFMACRO, DEFUN, LABELS or FLET).\n"
"	:MACRO, :FUNCTION\n"
"	    :MACRO is a global (DEFMACRO) macro.  :FUNCTION is anything else.\n"
"	:LOCAL, :GLOBAL\n"
"	    :LOCAL is a LABELS or FLET.  :GLOBAL is anything else.\n"
"	(:OR Context-Spec*)\n"
"	    True in any specified context.\n"
"	(:AND Context-Spec*)\n"
"	    True only when all specs are true.\n"
"	(:NOT Context-Spec)\n"
"	    True when the spec is false.\n"
"        (:MEMBER Name*)\n"
"	    True when the name is one of these names (EQUAL test.)\n"
"	(:MATCH Pattern*)\n"
"	    True when any of the patterns is a substring of the name.  The name\n"
"	    is wrapped with $'s, so $FOO matches names beginning with FOO,\n"
"	    etc."
msgstr ""

#: src/code/macros.lisp
msgid "Odd number of key/value pairs: ~S."
msgstr ""

#: src/code/macros.lisp
msgid "Ignoring unknown option: ~S."
msgstr ""

#: src/code/intl.lisp
msgid ""
"The message-lookup domain used by INTL:GETTEXT and INTL:NGETTEXT.\n"
"  Use (INTL:TEXTDOMAIN \"whatever\") in each source file to set this."
msgstr ""

#: src/code/intl.lisp
msgid "Encountered illegal token: ="
msgstr ""

#: src/code/intl.lisp
msgid "Encountered illegal token: ~C"
msgstr ""

#: src/code/intl.lisp
msgid "Expected : in ?: construct"
msgstr ""

#: src/code/intl.lisp
msgid "Expected close-paren."
msgstr ""

#: src/code/intl.lisp
msgid "Unexpected token: ~S."
msgstr ""

#: src/code/intl.lisp
msgid "Expecting end of expression.  ~S."
msgstr ""

#: src/code/intl.lisp
msgid ""
"Look up STRING in the current message domain and return its translation."
msgstr ""

#: src/code/intl.lisp
msgid ""
"Look up the singular or plural form of a message in the current domain."
msgstr ""

#: src/code/intl.lisp
msgid ""
"Look up STRING in the specified message domain and return its translation."
msgstr ""

#: src/code/intl.lisp
msgid ""
"Look up the singular or plural form of a message in the specified domain."
msgstr ""

#: src/code/intl.lisp
msgid "_@ is a reserved reader macro prefix."
msgstr ""

#: src/code/intl.lisp
msgid "~&Dumping ~D messages for domain ~S~%"
msgstr ""

#: src/code/unicode.lisp
msgid ""
"Given a string, returns a new string that is a copy of it with\n"
"  all lower case alphabetic characters converted to uppercase using\n"
"  full case conversion."
msgstr ""

#: src/code/unicode.lisp
msgid ""
"Given a string, returns a new string that is a copy of it with\n"
"  all lower case alphabetic characters converted to uppercase.  Casing\n"
"  is :simple or :full for simple or full case conversion,\n"
"  respectively."
msgstr ""

#: src/code/unicode.lisp
msgid ""
"Given a string, returns a new string that is a copy of it with\n"
"  all uppercase alphabetic characters converted to lowercase using\n"
"  full case conversion.."
msgstr ""

#: src/code/unicode.lisp
msgid ""
"Given a string, returns a new string that is a copy of it with all\n"
"  uppercase alphabetic characters converted to lowercase.  Casing is\n"
"  :simple or :full for simple or full case conversion, respectively."
msgstr ""

#: src/code/unicode.lisp
msgid ""
"Given a string, S, and a starting index, return the index of the\n"
"  next character that is not part of the word containing the character\n"
"  at the index, or the length of S if the word containing the\n"
"  character extends to the end of S.  If the index is negative or\n"
"  valid index into S, the returned value will be strictly greater than\n"
"  the index."
msgstr ""

#: src/code/unicode.lisp
msgid ""
"Capitalize String using the Unicode word-break algorithm to find\n"
"  the words in String.  The beginning is capitalized depending on the\n"
"  value of Casing"
msgstr ""

#: src/code/unicode.lisp
msgid ""
"Capitalize String using the Common Lisp word-break algorithm to find\n"
"  the words in String.  The beginning is capitalized depending on the\n"
"  value of Casing"
msgstr ""

#: src/code/unicode.lisp
msgid ""
"Given a string, returns a copy of the string with the first\n"
"  character of each ``word'' converted to upper-case, and remaining\n"
"  chars in the word converted to lower case. Casing is :simple, :full\n"
"  or :title for simple, full or title case conversion, respectively.  If\n"
"  Unicode-Word-Break is non-Nil, then the Unicode word-breaking\n"
"  algorithm is used to determine the word boundaries.  Otherwise, A\n"
"  ``word'' is defined to be a string of case-modifiable characters\n"
"  delimited by non-case-modifiable chars.  "
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Policy Node Condition*\n"
"  Test whether some conditions apply to the current compiler policy for "
"Node.\n"
"  Each condition is a predicate form which accesses the policy values by\n"
"  referring to them as the variables SPEED, SPACE, SAFETY, CSPEED, BREVITY "
"and\n"
"  DEBUG.  The results of all the conditions are combined with AND and "
"returned\n"
"  as the result.\n"
"\n"
"  Node is a form which is evaluated to obtain the node which the policy is "
"for.\n"
"  If Node is NIL, then we use the current policy as defined by *default-cook"
"ie*\n"
"  and *current-cookie*.  This option is only well defined during IR1\n"
"  conversion."
msgstr ""

#: src/compiler/macros.lisp
msgid "Can't funcall the SYMBOL-FUNCTION of special forms."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Def-IR1-Translator Name (Lambda-List Start-Var Cont-Var {Key Value}*)\n"
"                      [Doc-String] Form*\n"
"  Define a function that converts a Special-Form or other magical thing "
"into\n"
"  IR1.  Lambda-List is a defmacro style lambda list.  Start-Var and Cont-Var"
"\n"
"  are bound to the start and result continuations for the resulting IR1.\n"
"  This keyword is defined:\n"
"      Kind\n"
"          The function kind to associate with Name (default :special-form)."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Def-Source-Transform Name Lambda-List Form*\n"
"  Define a macro-like source-to-source transformation for the function "
"Name.\n"
"  A source transform may \"pass\" by returning a non-nil second value.  If "
"the\n"
"  transform passes, then the form is converted as a normal function call.  "
"If\n"
"  the supplied arguments are not compatible with the specified lambda-list,\n"
"  then the transform automatically passes.\n"
"  \n"
"  Source-Transforms may only be defined for functions.  Source transformatio"
"n\n"
"  is not attempted if the function is declared Notinline.  Source transforms"
"\n"
"  should not examine their arguments.  If it matters how the function is "
"used,\n"
"  then Deftransform should be used to define an IR1 transformation.\n"
"  \n"
"  If the desirability of the transformation depends on the current Optimize\n"
"  parameters, then the Policy macro should be used to determine when to "
"pass."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Def-Primitive-Translator Name Lambda-List Form*\n"
"  Define a function that converts a use of (%PRIMITIVE Name ...) into Lisp\n"
"  code.  Lambda-List is a defmacro style lambda list."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Deftransform Name (Lambda-List [Arg-Types] [Result-Type] {Key Value}*)\n"
"               Declaration* [Doc-String] Form*\n"
"  Define an IR1 transformation for Name.  An IR1 transformation computes a\n"
"  lambda that replaces the function variable reference for the call.  A\n"
"  transform may pass (decide not to transform the call) by calling the Give-"
"Up\n"
"  function.  Lambda-List both determines how the current call is parsed and\n"
"  specifies the Lambda-List for the resulting lambda.\n"
"\n"
"  We parse the call and bind each of the lambda-list variables to the\n"
"  continuation which represents the value of the argument.  When parsing "
"the\n"
"  call, we ignore the defaults, and always bind the variables for unsupplied"
"\n"
"  arguments to NIL.  If a required argument is missing, an unknown keyword "
"is\n"
"  supplied, or an argument keyword is not a constant, then the transform\n"
"  automatically passes.  The Declarations apply to the bindings made by\n"
"  Deftransform at transformation time, rather than to the variables of the\n"
"  resulting lambda.  Bound-but-not-referenced warnings are suppressed for "
"the\n"
"  lambda-list variables.  The Doc-String is used when printing efficiency "
"notes\n"
"  about the defined transform.\n"
"\n"
"  Normally, the body evaluates to a form which becomes the body of an\n"
"  automatically constructed lambda.  We make Lambda-List the lambda-list "
"for\n"
"  the lambda, and automatically insert declarations of the argument and "
"result\n"
"  types.  If the second value of the body is non-null, then it is a list of\n"
"  declarations which are to be inserted at the head of the lambda.  Automati"
"c\n"
"  lambda generation may be inhibited by explicitly returning a lambda from "
"the\n"
"  body.\n"
"\n"
"  The Arg-Types and Result-Type are used to create a function type which "
"the\n"
"  call must satisfy before transformation is attempted.  The function type\n"
"  specifier is constructed by wrapping (FUNCTION ...) around these values, "
"so\n"
"  the lack of a restriction may be specified by omitting the argument or\n"
"  supplying *.  The argument syntax specified in the Arg-Types need not be "
"the\n"
"  same as that in the Lambda-List, but the transform will never happen if\n"
"  the syntaxes can't be satisfied simultaneously.  If there is an existing\n"
"  transform for the same function that has the same type, then it is "
"replaced\n"
"  with the new definition.\n"
"\n"
"  These are the legal keyword options:\n"
"    :Result - A variable which is bound to the result continuation.\n"
"    :Node   - A variable which is bound to the combination node for the "
"call.\n"
"    :Policy - A form which is supplied to the Policy macro to determine "
"whether\n"
"              this transformation is appropriate.  If the result is false, "
"then\n"
"              the transform automatically passes.\n"
"    :Eval-Name\n"
"    	    - The name and argument/result types are actually forms to be\n"
"              evaluated.  Useful for getting closures that transform "
"similar\n"
"              functions.\n"
"    :Defun-Only\n"
"            - Don't actually instantiate a transform, instead just DEFUN\n"
"              Name with the specified transform definition function.  This "
"may\n"
"              be later instantiated with %Deftransform.\n"
"    :Important\n"
"            - If supplied and non-NIL, note this transform as ``important,''"
"\n"
"              which means effeciency notes will be generated when this\n"
"              transform fails even if brevity=speed (but not if brevity>spee"
"d)\n"
"    :When {:Native | :Byte | :Both}\n"
"            - Indicates whether this transform applies to native code,\n"
"              byte-code or both (default :native.)"
msgstr ""

#: src/compiler/macros.lisp
msgid "Can't specify both DEFUN-ONLY and EVAL-NAME."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Defknown Name Arg-Types Result-Type [Attributes] {Key Value}* \n"
"  Declare the function Name to be a known function.  We construct a type\n"
"  specifier for the function by wrapping (FUNCTION ...) around the Arg-Types"
"\n"
"  and Result-Type.  Attributes is a an unevaluated list of the boolean\n"
"  attributes that the function has.  These attributes are meaningful here:\n"
"      call\n"
"         May call functions that are passed as arguments.  In order to "
"determine\n"
"         what other effects are present, we must find the effects of all "
"arguments\n"
"         that may be functions.\n"
"        \n"
"      unsafe\n"
"         May incorporate arguments in the result or somehow pass them "
"upward.\n"
"        \n"
"      unwind\n"
"         May fail to return during correct execution.  Errors are O.K.\n"
"        \n"
"      any\n"
"         The (default) worst case.  Includes all the other bad things, plus "
"any\n"
"         other possible bad thing.\n"
"        \n"
"      foldable\n"
"         May be constant-folded.  The function has no side effects, but may "
"be\n"
"         affected by side effects on the arguments.  e.g. SVREF, MAPC.\n"
"        \n"
"      flushable\n"
"         May be eliminated if value is unused.  The function has no side "
"effects\n"
"         except possibly CONS.  If a function is defined to signal errors, "
"then\n"
"         it is not flushable even if it is movable or foldable.\n"
"        \n"
"      movable\n"
"         May be moved with impunity.  Has no side effects except possibly "
"CONS,\n"
"         and is affected only by its arguments.\n"
"\n"
"      predicate\n"
"          A true predicate likely to be open-coded.  This is a hint to IR1\n"
"	  conversion that it should ensure calls always appear as an IF test.\n"
"	  Not usually specified to Defknown, since this is implementation\n"
"	  dependent, and is usually automatically set by the Define-VOP\n"
"	  :Conditional option.\n"
"\n"
"  Name may also be a list of names, in which case the same information is "
"given\n"
"  to all the names.  The keywords specify the initial values for various\n"
"  optimizers that the function might have."
msgstr ""

#: src/compiler/macros.lisp
msgid "Function cannot have both good and bad attributes: ~S"
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Defoptimizer (Function Kind) (Lambda-List [Node-Var] Var*)\n"
"                Declaration* Form*\n"
"  Define some Kind of optimizer for the named Function.  Function must be a\n"
"  known function.  Lambda-List is used to parse the arguments to the\n"
"  combination as in Deftransform.  If the argument syntax is invalid or "
"there\n"
"  are non-constant keys, then we simply return NIL.\n"
"\n"
"  The function is DEFUN'ed as Function-Kind-OPTIMIZER.  Possible kinds are\n"
"  DERIVE-TYPE, OPTIMIZER, LTN-ANNOTATE and IR2-CONVERT.  If a symbol is\n"
"  specified instead of a (Function Kind) list, then we just do a DEFUN with "
"the\n"
"  symbol as its name, and don't do anything with the definition.  This is\n"
"  useful for creating optimizers to be passed by name to DEFKNOWN.\n"
"\n"
"  If supplied, Node-Var is bound to the combination node being optimized.  "
"If\n"
"  additional Vars are supplied, then they are used as the rest of the "
"optimizer\n"
"  function's lambda-list.  LTN-ANNOTATE methods are passed an additional "
"POLICY\n"
"  argument, and IR2-CONVERT methods are passed an additional IR2-BLOCK\n"
"  argument."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Do-Blocks (Block-Var Component [Ends] [Result-Form]) {Declaration}* {Form}*\n"
"  Iterate over the blocks in a component, binding Block-Var to each block "
"in\n"
"  turn.  The value of Ends determines whether to iterate over dummy head "
"and\n"
"  tail blocks:\n"
"    NIL   -- Skip Head and Tail (the default)\n"
"    :Head -- Do head but skip tail\n"
"    :Tail -- Do tail but skip head\n"
"    :Both -- Do both head and tail\n"
"\n"
"  If supplied, Result-Form is the value to return."
msgstr ""

#: src/compiler/macros.lisp
msgid "Losing Ends value: ~S."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Do-Blocks-Backwards (Block-Var Component [Ends] [Result-Form]) {Declaration}"
"* {Form}*\n"
"  Like Do-Blocks, only iterate over the blocks in reverse order."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Do-Uses (Node-Var Continuation [Result]) {Declaration}* {Form}*\n"
"  Iterate over the uses of Continuation, binding Node to each one succesivel"
"y."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Do-Nodes (Node-Var Cont-Var Block {Key Value}*) {Declaration}* {Form}*\n"
"  Iterate over the nodes in Block, binding Node-Var to the each node and\n"
"  Cont-Var to the node's Cont.  The only keyword option is Restart-P, which\n"
"  causes iteration to be restarted when a node is deleted out from under us "
"(if\n"
"  not supplied, this is an error.)"
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Do-Nodes-Backwards (Node-Var Cont-Var Block) {Declaration}* {Form}*\n"
"  Like Do-Nodes, only iterates in reverse order."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"With-IR1-Environment Node Form*\n"
"  Bind the IR1 context variables so that IR1 conversion can be done after "
"the\n"
"  main conversion pass has finished."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"LEXENV-FIND Name Slot {Key Value}*\n"
"  Look up Name in the lexical environment namespace designated by Slot,\n"
"  returning the <value, T>, or <NIL, NIL> if no entry.  The :TEST keyword\n"
"  may be used to determine the name equality predicate."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"If true, defprinter print functions print each slot on a separate line."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Defprinter Name Slot-Desc*\n"
"  Define some kind of reasonable defstruct structure-print function.  Name\n"
"  is the name of the structure.  We define a function %PRINT-name which\n"
"  prints the slots in the structure in the way described by the Slot-Descs.\n"
"  Each Slot-Desc can be a slot name, indicating that the slot should simply\n"
"  be printed.  A Slot-Desc may also be a list of a slot name and other "
"stuff.\n"
"  The other stuff is composed of keywords followed by expressions.  The\n"
"  expressions are evaluated with the variable which is the slot name bound\n"
"  to the value of the slot.  These keywords are defined:\n"
"  \n"
"  :PRIN1    Print the value of the expression instead of the slot value.\n"
"  :PRINC    Like :PRIN1, only princ the value\n"
"  :TEST     Only print something if the test is true.\n"
"  \n"
"  If no printing thing is specified then the slot value is printed as "
"PRIN1.\n"
"  \n"
"  The structure being printed is bound to Structure and the stream is bound "
"to\n"
"  Stream."
msgstr ""

#: src/compiler/macros.lisp
msgid "Losing Defprinter option: ~S."
msgstr ""

#: src/compiler/macros.lisp
msgid "Unknown attribute name: ~S."
msgstr ""

#: src/compiler/knownfun.lisp src/compiler/new-assem.lisp
#: src/compiler/vmdef.lisp src/compiler/node.lisp src/compiler/macros.lisp
msgid ""
"Automagically generated boolean attribute test function.  See\n"
"	    Def-Boolean-Attribute."
msgstr ""

#: src/compiler/knownfun.lisp src/compiler/new-assem.lisp
#: src/compiler/vmdef.lisp src/compiler/node.lisp src/compiler/macros.lisp
msgid ""
"Automagically generated boolean attribute setter.  See\n"
"	    Def-Boolean-Attribute."
msgstr ""

#: src/compiler/knownfun.lisp src/compiler/new-assem.lisp
#: src/compiler/vmdef.lisp src/compiler/node.lisp src/compiler/macros.lisp
msgid ""
"Automagically generated boolean attribute creation function.  See\n"
"	    Def-Boolean-Attribute."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Def-Boolean-Attribute Name Attribute-Name*\n"
"  Define a new class of boolean attributes, with the attributes havin the\n"
"  specified Attribute-Names.  Name is the name of the class, which is used "
"to\n"
"  generate some macros to manipulate sets of the attributes: \n"
"\n"
"    NAME-attributep attributes attribute-name*\n"
"      Return true if one of the named attributes is present, false otherwise"
".\n"
"      When set with SETF, updates the place Attributes setting or clearing "
"the\n"
"      specified attributes.\n"
"\n"
"    NAME-attributes attribute-name*\n"
"      Return a set of the named attributes."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Returns the union of all the sets of boolean attributes which are its\n"
"  arguments."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Returns the intersection of all the sets of boolean attributes which are "
"its\n"
"  arguments."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Returns true if the attributes present in Attr1 are indentical to those in\n"
"  Attr2."
msgstr ""

#: src/compiler/macros.lisp
msgid "~S is not the name of an event."
msgstr ""

#: src/compiler/macros.lisp
msgid "Return the number of times that Event has happened."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Return the function that is called when Event happens.  If this is null,\n"
"  there is no action.  The function is passed the node to which the event\n"
"  happened, or NIL if there is no relevant node.  This may be set with "
"SETF."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Return the non-negative integer which represents the level of significance\n"
"  of the event Name.  This is used to determine whether to print a message "
"when\n"
"  the event happens.  This may be set with SETF."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Defevent Name Description\n"
"  Define a new kind of event.  Name is a symbol which names the event and\n"
"  Description is a string which describes the event.  Level (default 0) is "
"the\n"
"  level of significance associated with this event; it is used to determine\n"
"  whether to print a Note when the event happens."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"This variable is a non-negative integer specifying the lowest level of\n"
"  event that will print a Note when it occurs."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Event Name Node\n"
"  Note that the event with the specified Name has happened.  Node is "
"evaluated\n"
"  to determine the node to which the event happened."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Print a listing of events and their counts, sorted by the count.  Events\n"
"  that happened fewer than Min-Count times will not be printed.  Stream is "
"the\n"
"  stream to write to."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Find Element in a null-terminated List linked by the accessor function\n"
"  Next.  Key, Test and Test-Not are the same as for generic sequence\n"
"  functions."
msgstr ""

#: src/compiler/debug.lisp src/compiler/pack.lisp src/compiler/represent.lisp
#: src/compiler/copyprop.lisp src/compiler/life.lisp src/compiler/macros.lisp
msgid "Silly to supply both :Test and :Test-Not."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Return the position of Element (or NIL if absent) in a null-terminated List\n"
"  linked by the accessor function Next.  Key, Test and Test-Not are the "
"same as\n"
"  for generic sequence functions."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Map Function over the elements in a null-terminated List linked by the\n"
"  accessor function Next, returning a list of the results."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Deletef-In Next Place Item\n"
"  Delete Item from a null-terminated list linked by the accessor function "
"Next\n"
"  that is stored in Place.  Item must appear exactly once in the list."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Push Item onto a list linked by the accessor function Next that is stored "
"in\n"
"  Place."
msgstr ""

#: src/compiler/macros.lisp
msgid "Redefining modular version ~S of ~S for width ~S."
msgstr ""

#: src/compiler/macros.lisp
msgid ""
"Lambda list keyword ~S is not supported for ~\n"
"              modular function lambda lists."
msgstr ""

#: src/compiler/generic/vm-macs.lisp
msgid "No more slots can follow a :rest-p slot."
msgstr ""

#: src/compiler/generic/vm-macs.lisp
msgid "Number of slots used by each ~S~\n"
"				  ~@[~* including the header~]."
msgstr ""

#: src/compiler/backend.lisp
msgid "Machine specific support routine ~S ~\n"
"				  undefined for ~S"
msgstr ""

#: src/compiler/backend.lisp
msgid "Unknown VM support routine: ~A"
msgstr ""

#: src/compiler/backend.lisp
msgid "The backend for the machine we are running on. Do not change this."
msgstr ""

#: src/compiler/backend.lisp
msgid "The backend we are attempting to compile."
msgstr ""

#: src/compiler/backend.lisp
msgid "The backend we are using to compile with."
msgstr ""

#: src/compiler/backend.lisp
msgid "Compute the *FEATURES* list to use with BACKEND."
msgstr ""

#: src/compiler/backend.lisp
msgid ""
"Same as EXT:FEATUREP, except use the features found in *TARGET-BACKEND*."
msgstr ""

#: src/compiler/backend.lisp
msgid "Same as EXT:FEATUREP, except use the features found in *BACKEND*."
msgstr ""

#: src/compiler/backend.lisp
msgid ""
"Same as EXT:FEATUREP, except use the features found in *NATIVE-BACKEND*."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid "Number of bits at the low end of a pointer used for type information."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid "Mask to extract the low tag bits from a pointer."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid ""
"Exclusive upper bound on the value of the low tag bits from a\n"
"  pointer."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid "Number of bits used in the header word of a data block for typeing."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid "Mask to extract the type from a header word."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid "most-positive-fixnum in the target architecture."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid "most-negative-fixnum in the target architecture."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each CONS."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each RATIO including the header."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each SINGLE-FLOAT including the header."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each DOUBLE-FLOAT including the header."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each COMPLEX including the header."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each FDEFN including the header."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each VALUE-CELL including the header."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each SAP including the header."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each WEAK-POINTER including the header."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each SCAVENGER-HOOK including the header."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each BINDING."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each UNWIND-BLOCK."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each CATCH-BLOCK."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each SYMBOL including the header."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid ""
"Number of slots used by each COMPLEX-SINGLE-FLOAT including the header."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid ""
"Number of slots used by each COMPLEX-DOUBLE-FLOAT including the header."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid "Number of slots used by each DOUBLE-DOUBLE-FLOAT including the header."
msgstr ""

#: src/compiler/generic/objdef.lisp
msgid ""
"Number of slots used by each COMPLEX-DOUBLE-DOUBLE-FLOAT including the "
"header."
msgstr ""

#: src/compiler/generic/interr.lisp
msgid "Unknown internal error: ~S"
msgstr ""

#: src/compiler/bit-util.lisp
msgid "local-tn-limit not a vm:word-bits multiple."
msgstr ""

#: src/compiler/pack.lisp src/compiler/life.lisp src/compiler/bit-util.lisp
msgid ""
"Argument and/or result bit arrays not the same length:~\n"
"			 ~%  ~S~%  ~S  ~%  ~S"
msgstr ""

#: src/compiler/ctype.lisp
msgid "Function called with ~R argument, but wants exactly ~R."
msgid_plural "Function called with ~R arguments, but wants exactly ~R."
msgstr[0] ""

#: src/compiler/ctype.lisp
msgid "Function called with ~R argument, but wants at least ~R."
msgid_plural "Function called with ~R arguments, but wants at least ~R."
msgstr[0] ""

#: src/compiler/ctype.lisp
msgid "Function called with ~R argument, but wants at most ~R."
msgid_plural "Function called with ~R arguments, but wants at most ~R."
msgstr[0] ""

#: src/compiler/ctype.lisp
msgid "Function has an odd number of arguments in the keyword portion."
msgstr ""

#: src/compiler/ctype.lisp
msgid "Can't tell whether the result is a ~S."
msgstr ""

#: src/compiler/ctype.lisp
msgid "The result is a ~S, not a ~S."
msgstr ""

#: src/compiler/ctype.lisp
msgid "Can't tell whether the ~:R argument is a ~S."
msgstr ""

#: src/compiler/ctype.lisp
msgid "The ~:R argument is a ~S, not a ~S."
msgstr ""

#: src/compiler/ctype.lisp
msgid "The ~:R argument never returns a value."
msgstr ""

#: src/compiler/ctype.lisp
msgid "The ~:R argument is not a constant."
msgstr ""

#: src/compiler/ctype.lisp
msgid ""
"Can't tell whether the ~:R argument is a ~\n"
"		             constant ~S:~%  ~S"
msgstr ""

#: src/compiler/ctype.lisp
msgid "The ~:R argument is not a constant ~S:~%  ~S"
msgstr ""

#: src/compiler/ctype.lisp
msgid "The ~:R argument (in keyword position) is not a constant."
msgstr ""

#: src/compiler/ctype.lisp
msgid "The value of ~S is not a constant"
msgstr ""

#: src/compiler/ctype.lisp
msgid "~S is not a known argument keyword."
msgstr ""

#: src/compiler/ctype.lisp
msgid "Function previously called with ~R argument, but wants at least ~R."
msgid_plural ""
"Function previously called with ~R arguments, but wants at least ~R."
msgstr[0] ""

#: src/compiler/ctype.lisp
msgid "Function previously called with ~R argument, but wants at most ~R."
msgid_plural ""
"Function previously called with ~R arguments, but wants at most ~R."
msgstr[0] ""

#: src/compiler/ctype.lisp
msgid ""
"Function previously called with an odd number of arguments in ~\n"
"	      the keyword portion."
msgstr ""

#: src/compiler/ctype.lisp
msgid "Can't tell whether previous ~? argument type ~S is a ~S."
msgstr ""

#: src/compiler/ctype.lisp
msgid "~:(~?~) argument should be a ~S but was a ~S in a previous call."
msgstr ""

#: src/compiler/ctype.lisp
msgid "Function previously called with unknown argument keyword ~S."
msgstr ""

#: src/compiler/ctype.lisp
msgid ""
"Definition's declared type for variable ~A:~%  ~S~@\n"
"		   conflicts with this type from ~A:~%  ~S"
msgstr ""

#. updated to allow better translations.
#: src/compiler/ctype.lisp
msgid "Definition has ~R ~A arg, but ~A has ~R."
msgid_plural "Definition has ~R ~A args, but ~A has ~R."
msgstr[0] ""

#: src/compiler/ctype.lisp
msgid "fixed"
msgstr ""

#: src/compiler/ctype.lisp
msgid "optional"
msgstr ""

#: src/compiler/ctype.lisp
msgid "Definition ~:[doesn't have~;has~] ~A, but ~\n"
"		~A ~:[doesn't~;does~]."
msgstr ""

#: src/compiler/ctype.lisp
msgid "keyword args"
msgstr ""

#: src/compiler/ctype.lisp
msgid "rest args"
msgstr ""

#: src/compiler/ctype.lisp
msgid "Defining a ~S keyword not present in ~A."
msgstr ""

#: src/compiler/ctype.lisp
msgid "Definition lacks the ~S keyword present in ~A."
msgstr ""

#: src/compiler/ctype.lisp
msgid "Definition has no ~A, but the ~A did."
msgstr ""

#: src/compiler/ctype.lisp
msgid "optional args"
msgstr ""

#: src/compiler/ctype.lisp
msgid "rest arg"
msgstr ""

#: src/compiler/ctype.lisp
msgid "Definition has ~R arg, but the ~A has ~R."
msgid_plural "Definition has ~R args, but the ~A has ~R."
msgstr[0] ""

#: src/compiler/ctype.lisp
msgid ""
"The result type from ~A:~%  ~S~@\n"
"	   conflicts with the definition's result type assertion:~%  ~S"
msgstr ""

#: src/compiler/ctype.lisp
msgid ""
"Assignment to argument: ~S~%  ~\n"
"			       prevents use of assertion from function ~\n"
"			       type ~A:~%  ~S~%"
msgstr ""

#: src/compiler/ctype.lisp
msgid "previous declaration"
msgstr ""

#: src/compiler/vmdef.lisp
msgid "~S is not a defined template."
msgstr ""

#: src/compiler/vmdef.lisp
msgid "~S is not a defined storage class."
msgstr ""

#: src/compiler/vmdef.lisp
msgid "~S is not a defined storage base."
msgstr ""

#: src/compiler/meta-vmdef.lisp src/compiler/vmdef.lisp
msgid "~S is not a defined primitive type."
msgstr ""

#: src/compiler/vmdef.lisp
msgid ""
"NOTE-THIS-LOCATION VOP Kind\n"
"  Note that the current code location is an interesting (to the debugger)\n"
"  location of the specified Kind.  VOP is the VOP responsible for this "
"code.\n"
"  This VOP must specify some non-null :SAVE-P value (perhaps :COMPUTE-ONLY) "
"so\n"
"  that the live set is computed."
msgstr ""

#: src/compiler/vmdef.lisp
msgid ""
"NOTE-NEXT-INSTRUCTION VOP Kind\n"
"   Similar to NOTE-THIS-LOCATION, except the use the location of the next\n"
"   instruction for the code location, wherever the scheduler decided to put\n"
"   it."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"Define-Storage-Base Name Kind {Key Value}*\n"
"  Define a storage base having the specified Name.  Kind may be :Finite,\n"
"  :Unbounded or :Non-Packed.  The following keywords are legal:\n"
"\n"
"  :Size <Size>\n"
"      Specify the number of locations in a :Finite SB or the initial size "
"of a\n"
"      :Unbounded SB."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Size specification meaningless in a ~S SB."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Size not specified in a ~S SB."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"Define-Storage-Class Name Number Storage-Base {Key Value}*\n"
"  Define a storage class Name that uses the named Storage-Base.  Number is "
"a\n"
"  small, non-negative integer that is used as an alias.  The following\n"
"  keywords are defined:\n"
"\n"
"  :Element-Size Size\n"
"      The size of objects in this SC in whatever units the SB uses.  This\n"
"      defaults to 1.\n"
"\n"
"  :Alignment Size\n"
"      The alignment restrictions for this SC.  TNs will only be allocated "
"at\n"
"      offsets that are an even multiple of this number.  Defaults to 1.\n"
"\n"
"  :Locations (Location*)\n"
"      If the SB is :Finite, then this is a list of the offsets within the "
"SB\n"
"      that are in this SC.\n"
"\n"
"  :Reserve-Locations (Location*)\n"
"      A subset of the Locations that the register allocator should try to\n"
"      reserve for operand loading (instead of to hold variable values.)\n"
"\n"
"  :Save-P {T | NIL}\n"
"      If T, then values stored in this SC must be saved in one of the\n"
"      non-save-p :Alternate-SCs across calls.\n"
"\n"
"  :Alternate-SCs (SC*)\n"
"      Indicates other SCs that can be used to hold values from this SC "
"across\n"
"      calls or when storage in this SC is exhausted.  The SCs should be\n"
"      specified in order of decreasing \"goodness\".  There must be at least\n"
"      one SC in an unbounded SB, unless this SC is only used for restricted "
"or\n"
"      wired TNs.\n"
"\n"
"  :Constant-SCs (SC*)\n"
"      A list of the names of all the constant SCs that can be loaded into "
"this\n"
"      SC by a move function."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Alignment is not a power of two: ~S"
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "SC element ~D out of bounds for ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ":Locations is meaningless in a ~S SB."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Reserve-Locations not a subset of Locations."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Meaningless to specify alternate or constant SCs in a ~S SB."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"Define-Move-Function (Name Cost) lambda-list ({(From-SC*) (To-SC*)}*) form*\n"
"  Define the function Name and note it as the function used for moving "
"operands\n"
"  from the From-SCs to the To-SCs.  Cost is the cost of this move "
"operation.\n"
"  The function is called with three arguments: the VOP (for context), and "
"the\n"
"  source and destination TNs.  An ASSEMBLE form is wrapped around the body.\n"
"  All uses of DEFINE-MOVE-FUNCTION should be compiled before any uses of\n"
"  DEFINE-VOP."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Malformed SCs spec: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"Define-Move-VOP Name {:Move | :Move-Argument} {(From-SC*) (To-SC*)}*\n"
"  Make Name be the VOP used to move values in the specified From-SCs to the\n"
"  representation of the To-SCs.  If kind is :Move-Argument, then the VOP "
"takes\n"
"  an extra argument, which is the frame pointer of the frame to move into."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Unknown kind ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"Def-Primitive-Type Name (SC*) {Key Value}*\n"
"   Define a primitive type Name.  Each SC specifies a Storage Class that "
"values\n"
"   of this type may be allocated in.  The following keyword options are\n"
"   defined:\n"
"  \n"
"  :Type\n"
"      The type descriptor for the Lisp type that is equivalent to this type\n"
"      (defaults to Name.)"
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"DEF-PRIMITIVE-TYPE-ALIAS Name Result\n"
"  Define name to be an alias for Result in VOP operand type restrictions."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"Primitive-Type-VOP Vop (Kind*) Type*\n"
"  Annotate all the specified primitive Types with the named VOP under each "
"of\n"
"  the specified kinds:\n"
"\n"
"  :Check\n"
"      A one argument one result VOP that moves the argument to the result,\n"
"      checking that the value is of this type in the process."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Unknown kind: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Operand ~S isn't one of these kinds: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "~S is not an operand to ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "~S is not the name of a defined VOP."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "~:R argument missing: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Extra junk at end of ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "~:R argument is not a ~S: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Malformed time specifier: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Unknown phase in time specifier: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Cannot target a ~S operand: ~S."
msgstr ""

#: src/compiler/debug-dump.lisp src/compiler/checkgen.lisp
#: src/compiler/ir1util.lisp src/compiler/meta-vmdef.lisp
msgid "Shouldn't happen?"
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"No move function defined to ~:[save~;load~] SC ~S~\n"
"			  ~:[to~;from~] from SC ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"Can't tell whether to ~:[save~;load~] with ~S~@\n"
"				 or ~S when operand is in SC ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"SC ~S has no alternate~:[~; or constant~] SCs, yet it is~@\n"
"	          mentioned in the restriction for operand ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Malformed operand specifier: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "More operand isn't last: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Can only specify :FROM in a result: ~S"
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Can only specify :TO in an argument: ~S"
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Unknown keyword in operand specifier: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Cannot specify :TARGET in a :MORE operand."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Cannot specify :LOAD-IF in a :MORE operand."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Malformed temporary spec: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Malformed options list: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Odd number of arguments in keyword options: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Temporary spec allocates no temps:~%  ~S"
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Bad temporary name: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Must specify exactly one SC for a temporary."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Unknown temporary option: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Temporary lifetime doesn't begin before it ends: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Must specifiy :SC for all temporaries: ~S"
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Malformed option specification: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Unknown option specifier: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"No move function defined to move ~:[from~;to~] SC ~\n"
"	              ~S~%~:[to~;from~] alternate or constant SC ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Bad thing to be a operand type: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Bad PRIMITIVE-TYPE name in ~S: ~S"
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"Can't include primitive-type ~\n"
"				             alias ~S in a :OR restriction: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Can't :CONSTANT for a result."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Bad :CONSTANT argument type spec: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"In the ~A ~:[result~;argument~] to VOP ~S,~@\n"
"	            none of the SCs allowed by the operand type ~S can ~\n"
"		    directly be loaded~@\n"
"		    into any of the restriction's SCs:~%  ~S~:[~;~@\n"
"		    [* type operand must allow T's SCs.]~]"
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"~:[Result~;Argument~] ~A to VOP ~S~@\n"
"	         has SC restriction ~S which is ~\n"
"		 not allowed by the operand type:~%  ~S"
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Expected ~D ~:[result~;argument~] type: ~S."
msgid_plural "Expected ~D ~:[result~;argument~] types: ~S."
msgstr[0] ""

#: src/compiler/meta-vmdef.lisp
msgid "Can't use :CONSTANT on VOP more args."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Expected ~D variant values: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"Define-VOP (Name [Inherits]) Spec*\n"
"  Define the symbol Name to be a Virtual OPeration in the compiler.  If\n"
"  specified, Inherits is the name of a VOP that we default unspecified\n"
"  information from.  Each Spec is a list beginning with a keyword indicating"
"\n"
"  the interpretation of the other forms in the Spec:\n"
"  \n"
"  :Args {(Name {Key Value}*)}*\n"
"  :Results {(Name {Key Value}*)}*\n"
"      The Args and Results are specifications of the operand TNs passed to "
"the\n"
"      VOP.  If there is an inherited VOP, any unspecified options are "
"defaulted\n"
"      from the inherited argument (or result) of the same name.  The "
"following\n"
"      operand options are defined: \n"
"\n"
"      :SCs (SC*)\n"
"	  :SCs specifies good SCs for this operand.  Other SCs will be\n"
"	  penalized according to move costs.  A load TN will be allocated if\n"
"	  necessary, guaranteeing that the operand is always one of the\n"
"	  specified SCs.\n"
"\n"
"      :Load-TN Load-Name\n"
"          Load-Name is bound to the load TN allocated for this operand, or "
"to\n"
"	  NIL if no load TN was allocated.\n"
"\n"
"      :Load-If Expression\n"
"          Controls whether automatic operand loading is done.  Expression "
"is\n"
"	  evaluated with the fixed operand TNs bound.  If Expression is true,\n"
"	  then loading is done and the variable is bound to the load TN in\n"
"	  the generator body.  Otherwise, loading is not done, and the variable\n"
"	  is bound to the actual operand.\n"
"\n"
"      :More T-or-NIL\n"
"	  If specified, Name is bound to the TN-Ref for the first argument or\n"
"	  result following the fixed arguments or results.  A more operand must\n"
"	  appear last, and cannot be targeted or restricted.\n"
"\n"
"      :Target Operand\n"
"	  This operand is targeted to the named operand, indicating a desire to\n"
"	  pack in the same location.  Not legal for results.\n"
"\n"
"      :From Time-Spec\n"
"      :To Time-Spec\n"
"	  Specify the beginning or end of the operand's lifetime.  :From can\n"
"	  only be used with results, and :To only with arguments.  The default\n"
"	  for the N'th argument/result is (:ARGUMENT N)/(:RESULT N).  (The\n"
"          first argument/result is number 0.) These options are necessary\n"
"          primarily when operands are read or written out of order.\n"
"   \n"
"  :Conditional\n"
"      This is used in place of :RESULTS with conditional branch VOPs.  "
"There\n"
"      are no result values: the result is a transfer of control.  The "
"target\n"
"      label is passed as the first :INFO arg.  The second :INFO arg is true "
"if\n"
"      the sense of the test should be negated.  A side-effect is to set the\n"
"      PREDICATE attribute for functions in the :TRANSLATE option.\n"
"  \n"
"  :Temporary ({Key Value}*) Name*\n"
"      Allocate a temporary TN for each Name, binding that variable to the "
"TN\n"
"      within the body of the generators.  In addition to :Target (which is \n"
"      is the same as for operands), the following options are\n"
"      defined:\n"
"\n"
"      :SC SC-Name\n"
"      :Offset SB-Offset\n"
"	  Force the temporary to be allocated in the specified SC with the\n"
"	  specified offset.  Offset is evaluated at macroexpand time.  If\n"
"	  Offset is emitted, the register allocator chooses a free location in\n"
"	  SC.  If both SC and Offset are omitted, then the temporary is packed\n"
"	  according to its primitive type.\n"
"\n"
"      :From Time-Spec\n"
"      :To Time-Spec\n"
"	  Similar to the argument/result option, this specifies the start and\n"
"	  end of the temporarys' lives.  The defaults are :Load and :Save, i.e.\n"
"	  the duration of the VOP.  The other intervening phases are :Argument,\n"
"	  :Eval and :Result.  Non-zero sub-phases can be specified by a list,\n"
"	  e.g. by default the second argument's life ends at (:Argument 1).\n"
" \n"
"  :Generator Cost Form*\n"
"      Specifies the translation into assembly code. Cost is the estimated "
"cost\n"
"      of the code emitted by this generator. The body is arbitrary Lisp "
"code\n"
"      that emits the assembly language translation of the VOP.  An Assemble\n"
"      form is wrapped around the body, so code may be emitted by using the\n"
"      local Inst macro.  During the evaluation of the body, the names of "
"the\n"
"      operands and temporaries are bound to the actual TNs.\n"
"  \n"
"  :Effects Effect*\n"
"  :Affected Effect*\n"
"      Specifies the side effects that this VOP has and the side effects "
"that\n"
"      effect its execution.  If unspecified, these default to the worst "
"case.\n"
"  \n"
"  :Info Name*\n"
"      Define some magic arguments that are passed directly to the code\n"
"      generator.  The corresponding trailing arguments to VOP or %Primitive "
"are\n"
"      stored in the VOP structure.  Within the body of the generators, the\n"
"      named variables are bound to these values.  Except in the case of\n"
"      :Conditional VOPs, :Info arguments cannot be specified for VOPS that "
"are\n"
"      the direct translation for a function (specified by :Translate).\n"
"\n"
"  :Ignore Name*\n"
"      Causes the named variables to be declared IGNORE in the generator "
"body.\n"
"\n"
"  :Variant Thing*\n"
"  :Variant-Vars Name*\n"
"      These options provide a way to parameterize families of VOPs that "
"differ\n"
"      only trivially.  :Variant makes the specified evaluated Things be the\n"
"      \"variant\" associated with this VOP.  :Variant-Vars causes the named\n"
"      variables to be bound to the corresponding Things within the body of "
"the\n"
"      generator.\n"
"\n"
"  :Variant-Cost Cost\n"
"      Specifies the cost of this VOP, overriding the cost of any inherited\n"
"      generator.\n"
"\n"
"  :Note {String | NIL}\n"
"      A short noun-like phrase describing what this VOP \"does\", i.e. the\n"
"      implementation strategy.  If supplied, efficency notes will be "
"generated\n"
"      when type uncertainty prevents :TRANSLATE from working.  NIL inhibits "
"any\n"
"      efficency note.\n"
"\n"
"  :Arg-Types    {* | PType | (:OR PType*) | (:CONSTANT Type)}*\n"
"  :Result-Types {* | PType | (:OR PType*)}*\n"
"      Specify the template type restrictions used for automatic "
"translation.\n"
"      If there is a :More operand, the last type is the more type.  :CONSTAN"
"T\n"
"      specifies that the argument must be a compile-time constant of the\n"
"      specified Lisp type.  The constant values of :CONSTANT arguments are\n"
"      passed as additional :INFO arguments rather than as :ARGS.\n"
"  \n"
"  :Translate Name*\n"
"      This option causes the VOP template to be entered as an IR2 translatio"
"n\n"
"      for the named functions.\n"
"\n"
"  :Policy {:Small | :Fast | :Safe | :Fast-Safe}\n"
"      Specifies the policy under which this VOP is the best translation.\n"
"\n"
"  :Guard Form\n"
"      Specifies a Form that is evaluated in the global environment.  If\n"
"      form returns NIL, then emission of this VOP is prohibited even when\n"
"      all other restrictions are met.\n"
"\n"
"  :VOP-Var Name\n"
"  :Node-Var Name\n"
"      In the generator, bind the specified variable to the VOP or the Node "
"that\n"
"      generated this VOP.\n"
"\n"
"  :Save-P {NIL | T | :Compute-Only | :Force-To-Stack}\n"
"      Indicates how a VOP wants live registers saved.\n"
"\n"
"  :Move-Args {NIL | :Full-Call | :Local-Call | :Known-Return}\n"
"      Indicates if and how the more args should be moved into a different\n"
"      frame."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"Emit-Template Node Block Template Args Results [Info]\n"
"  Call the emit function for Template, linking the result in at the end of\n"
"  Block."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"VOP Name Node Block Arg* Info* Result*\n"
"  Emit the VOP (or other template) Name at the end of the IR2-Block Block,\n"
"  using Node for the source context.  The interpretation of the remaining\n"
"  arguments depends on the number of operands of various kinds that are\n"
"  declared in the template definition.  VOP cannot be used for templates "
"that\n"
"  have more-args or more-results, since the number of arguments and results "
"is\n"
"  indeterminate for these templates.  Use VOP* instead.\n"
"  \n"
"  Args and Results are the TNs that are to be referenced by the template\n"
"  as arguments and results.  If the template has codegen-info arguments, "
"then\n"
"  the appropriate number of Info forms following the Arguments are used for\n"
"  codegen info."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Cannot use VOP with variable operand count templates."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Called with ~D operands, but was expecting ~D."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"VOP* Name Node Block (Arg* More-Args) (Result* More-Results) Info*\n"
"  Like VOP, but allows for emission of templates with arbitrary numbers of\n"
"  arguments, and for emission of templates using already-created TN-Ref "
"lists.\n"
"\n"
"  The Arguments and Results are TNs to be referenced as the first arguments\n"
"  and results to the template.  More-Args and More-Results are heads of "
"TN-Ref\n"
"  lists that are added onto the end of the TN-Refs for the explicitly "
"supplied\n"
"  operand TNs.  The TN-Refs for the more operands must have the TN and "
"Write-P\n"
"  slots correctly initialized.\n"
"\n"
"  As with VOP, the Info forms are evaluated and passed as codegen info\n"
"  arguments."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Too many fixed arguments."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Too many fixed results."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Expected ~D info args."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"SC-Case TN {({(SC-Name*) | SC-Name | T} Form*)}*\n"
"  Case off of TN's SC.  The first clause containing TN's SC is evaulated,\n"
"  returning the values of the last form.  A clause beginning with T specifie"
"s a\n"
"  default.  If it appears, it must be last.  If no default is specified, "
"and no\n"
"  clause matches, then an error is signalled."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "Illegal SC-Case clause: ~S."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid "T case is not last in SC-Case."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"SC-Is TN SC*\n"
"  Returns true if TNs SC is any of the named SCs, false otherwise."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"Do-IR2-Blocks (Block-Var Component [Result]) Form*\n"
"  Iterate over the IR2 blocks in component, in emission order."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"DO-LIVE-TNS (TN-Var Live Block [Result]) Form*\n"
"  Iterate over all the TNs live at some point, with the live set represented"
" by\n"
"  a local conflicts bit-vector and the IR2-Block containing the location."
msgstr ""

#: src/compiler/meta-vmdef.lisp
msgid ""
"DO-ENVIRONMENT-IR2-BLOCKS (Block-Var Env [Result]) Form*\n"
"  Iterate over all the IR2 blocks in the environment Env, in emit order."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"The width of the column in which instruction-names are printed.\n"
"  NIL means use the default.  A value of zero gives the effect of not\n"
"  aligning the arguments at all."
msgstr ""

#: src/compiler/disassem.lisp
msgid "The column in which end-of-line comments for notes are started."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Specify global disassembler params for C:*TARGET-BACKEND*.\n"
"  Keyword arguments include:\n"
"      \n"
"  :INSTRUCTION-ALIGNMENT number\n"
"      Minimum alignment of instructions, in bits.\n"
"      \n"
"  :ADDRESS-SIZE number\n"
"      Size of a machine address, in bits.\n"
"      \n"
"  :OPCODE-COLUMN-WIDTH\n"
"      Width of the column used for printing the opcode portion of the\n"
"      instruction, or NIL to use the default."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"DEFINE-ARGUMENT-TYPE Name {Key Value}*\n"
"  Define a disassembler argument type NAME (which can then be referenced in\n"
"  another argument definition using the :TYPE keyword argument).  Keyword\n"
"  arguments are:\n"
"\n"
"  :SIGN-EXTEND boolean\n"
"      If non-NIL, the raw value of this argument is sign-extended.\n"
"\n"
"  :TYPE arg-type-name\n"
"      Inherit any properties of given argument-type.\n"
"\n"
"  :PREFILTER function\n"
"      A function which is called (along with all other prefilters, in the\n"
"      order that their arguments appear in the instruction- format) before\n"
"      any printing is done, to filter the raw value.  Any uses of READ-SUFFI"
"X\n"
"      must be done inside a prefilter.\n"
"      \n"
"  :PRINTER function-string-or-vector\n"
"      A function, string, or vector which is used to print an argument of\n"
"      this type.\n"
"      \n"
"  :USE-LABEL \n"
"      If non-NIL, the value of an argument of this type is used as an\n"
"      address, and if that address occurs inside the disassembled code, it "
"is\n"
"      replaced by a label.  If this is a function, it is called to filter "
"the\n"
"      value."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"DEFINE-INSTRUCTION-FORMAT (Name Length {Format-Key Value}*) Arg-Def*\n"
"  Define an instruction format NAME for the disassembler's use.  LENGTH is\n"
"  the length of the format in bits.\n"
"  Possible FORMAT-KEYs:\n"
"\n"
"  :INCLUDE other-format-name\n"
"      Inherit all arguments and properties of the given format.  Any\n"
"      arguments defined in the current format definition will either modify\n"
"      the copy of an existing argument (keeping in the same order with\n"
"      respect to when pre-filter's are called), if it has the same name as\n"
"      one, or be added to the end.\n"
"  :DEFAULT-PRINTER printer-list\n"
"      Use the given PRINTER-LIST as a format to print any instructions of\n"
"      this format when they don't specify something else.\n"
"\n"
"  Each ARG-DEF defines one argument in the format, and is of the form\n"
"    (Arg-Name {Arg-Key Value}*)\n"
"\n"
"  Possible ARG-KEYs (the values are evaulated unless otherwise specified):\n"
"  \n"
"  :FIELDS byte-spec-list\n"
"      The argument takes values from these fields in the instruction.  If\n"
"      the list is of length one, then the corresponding value is supplied "
"by\n"
"      itself; otherwise it is a list of the values.  The list may be NIL.\n"
"  :FIELD byte-spec\n"
"      The same as :FIELDS (list byte-spec).\n"
"\n"
"  :VALUE value\n"
"      If the argument only has one field, this is the value it should have,\n"
"      otherwise it's a list of the values of the individual fields.  This "
"can\n"
"      be overridden in an instruction-definition or a format definition\n"
"      including this one by specifying another, or NIL to indicate that "
"it's\n"
"      variable.\n"
"\n"
"  :SIGN-EXTEND boolean\n"
"      If non-NIL, the raw value of this argument is sign-extended,\n"
"      immediately after being extracted from the instruction (before any\n"
"      prefilters are run, for instance).  If the argument has multiple\n"
"      fields, they are all sign-extended.\n"
"\n"
"  :TYPE arg-type-name\n"
"      Inherit any properties of the given argument-type.\n"
"\n"
"  :PREFILTER function\n"
"      A function which is called (along with all other prefilters, in the\n"
"      order that their arguments appear in the instruction-format) before\n"
"      any printing is done, to filter the raw value.  Any uses of READ-SUFFI"
"X\n"
"      must be done inside a prefilter.\n"
"\n"
"  :PRINTER function-string-or-vector\n"
"      A function, string, or vector which is used to print this argument.\n"
"      \n"
"  :USE-LABEL \n"
"      If non-NIL, the value of this argument is used as an address, and if\n"
"      that address occurs inside the disassembled code, it is replaced by a\n"
"      label.  If this is a function, it is called to filter the value."
msgstr ""

#: src/compiler/disassem.lisp
msgid "~d bits is not a byte-multiple"
msgstr ""

#: src/compiler/disassem.lisp
msgid "Returns non-NIL if ADDRESS is aligned on a SIZE byte boundary."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Return ADDRESS aligned *upward* to a SIZE byte boundary."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"If CAR is eq to the car of OLD-CONS and CDR is eq to the CDR, return\n"
"  OLD-CONS, otherwise return (cons CAR CDR)."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"A simple (one list arg) mapcar that avoids consing up a new list\n"
"  as long as the results of calling FUN on the elements of LIST are\n"
"  eq to the original."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Can't dump functions, so function ref form must be quoted: ~s"
msgstr ""

#: src/compiler/disassem.lisp
msgid "Unknown argument ~s"
msgstr ""

#: src/compiler/disassem.lisp
msgid "~s must not have multiple values"
msgstr ""

#: src/compiler/disassem.lisp
msgid "Unknown arg-form kind ~s"
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Cannot label a multiple-field argument ~\n"
"			      unless using a function: ~s"
msgstr ""

#: src/compiler/disassem.lisp
msgid "Bogus!  Can't use the :printed value of an arg!"
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"number of constants doesn't match number of fields ~\n"
"			  in: (~s :constant~{ ~s~})"
msgstr ""

#: src/compiler/disassem.lisp
msgid "Can't compare differently sized fields: ~\n"
"		          (~s :same-as ~s)"
msgstr ""

#: src/compiler/disassem.lisp
msgid "Bogus test-form: ~s"
msgstr ""

#: src/compiler/disassem.lisp
msgid "Returns the first non-keyword symbol in a depth-first search of TREE."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Illegal printer: ~s"
msgstr ""

#: src/compiler/disassem.lisp
msgid "Unknown printer element: ~s"
msgstr ""

#: src/compiler/disassem.lisp
msgid "First arg to :USING must be a string or #'function"
msgstr ""

#: src/compiler/disassem.lisp
msgid "No suitable choice found in ~s"
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Returns a version of the disassembly-template PRINTER with compile-time\n"
"  tests (e.g. :constant without a value), and any :CHOOSE operators resolved"
"\n"
"  properly for the args ARGS.  (:CHOOSE Sub*) simply returns the first Sub "
"in\n"
"  which every field reference refers to a valid arg."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Unknown argument type: ~s"
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"~@<In arg ~s:  ~3i~:_~\n"
"          Can't specify fields except using DEFINE-INSTRUCTION-FORMAT.~:>"
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"~@<In arg ~s:  ~3i~:_~\n"
"				     Field ~s doesn't fit in an ~\n"
"				     instruction-format ~d bits wide.~:>"
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Generate a form to specify global disassembler params.  See the\n"
"  documentation for SET-DISASSEM-PARAMS for more info."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Generate a form to define a disassembler argument type.  See\n"
"  DEFINE-ARGUMENT-TYPE for more info."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Generate a form to define an instruction format.  See\n"
"  DEFINE-INSTRUCTION-FORMAT for more info."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Field ~s in arg ~s overlaps some other field"
msgstr ""

#: src/compiler/disassem.lisp
msgid "Unknown instruction format ~s"
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Returns non-NIL if the instruction SPECIAL is a more specific version of\n"
"  GENERAL (i.e., the same instruction, but with more constraints)."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Returns an integer corresponding to the specifivity of the instruction "
"INST."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Order the list of instructions INSTS with more specific (more constant\n"
"  bits, or same-as argument constains) ones first.  Returns the ordered "
"list."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Instructions either aren't related or conflict in some way:~%"
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Given a list of instructions INSTS, Sees if one of these instructions is a\n"
"  more general form of all the others, in which case they are put into its\n"
"  specializers list, and it is returned.  Otherwise an error is signaled."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Multiple specializing masters: ~s"
msgstr ""

#: src/compiler/disassem.lisp
msgid "Returns non-NIL if all constant-bits in INST match CHUNK."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Given an instruction object, INST, and a bit-pattern, CHUNK, picks the\n"
"  most specific instruction on INST's specializer list who's constraints "
"are\n"
"  met by CHUNK.  If none do, then INST is returned."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Returns the instruction object within INST-SPACE corresponding to the\n"
"  bit-pattern CHUNK, or NIL if there isn't one."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Returns an instruction-space object corresponding to the list of\n"
"  instructions INSTS.  If the optional parameter INITIAL-MASK is supplied, "
"only\n"
"  bits it has set are used."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Prints a nicely formatted version of INST-SPACE."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Print the inst space for the specified backend"
msgstr ""

#: src/compiler/disassem.lisp
msgid "Converts a word-offset NUM to a byte-offset."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Converts a byte-offset NUM to a word-offset."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Get the value of the property called NAME in DSTATE.  Also setf'able."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Returns the absolute address of the current instruction in DSTATE."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Returns the absolute address of the next instruction in DSTATE."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Offset of FUNCTION from the start of its code-component's instruction area."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Offset of FUNCTION from the start of its code-component."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Returns the length of the instruction area in CODE-COMPONENT."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Returns the address of the instruction area in CODE-COMPONENT."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Returns the first function in CODE-COMPONENT."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Possible ~A header word"
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Print the function-header (entry-point) pseudo-instruction at the current\n"
"  location in DSTATE to STREAM."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Iterate through the instructions in SEGMENT, calling FUNCTION\n"
"  for each instruction, with arguments of CHUNK, STREAM, and DSTATE."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Make an initial non-printing disassembly pass through DSTATE, noting any\n"
"  addresses that are referenced by instructions in this segment."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"If any labels in DSTATE have been added since the last call to this\n"
"  function, give them label-numbers, enter them in the hash-table, and make\n"
"  sure the label list is in sorted order."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Get the instruction-space from PARAMS, creating it if necessary."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Print the current address in DSTATE to STREAM, plus any labels that\n"
"  correspond to it, and leave the cursor in the instruction column."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Print a newline to STREAM, inserting any pending notes in DSTATE as\n"
"  end-of-line comments.  If there is more than one note, a separate line\n"
"  will be used for each one."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Disassemble NUM bytes to STREAM as simple `BYTE' instructions"
msgstr ""

#: src/compiler/disassem.lisp
msgid "Disassemble NUM machine-words to STREAM as simple `WORD' instructions"
msgstr ""

#: src/compiler/disassem.lisp
msgid "Make a disassembler-state object."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Return a memory segment located at the system-area-pointer returned by\n"
"  SAP-MAKER and LENGTH bytes long in the disassem-state object DSTATE.\n"
"  Optional keyword arguments include :VIRTUAL-LOCATION (by default the same "
"as\n"
"  the address), :DEBUG-FUNCTION, :SOURCE-FORM-CACHE (a source-form-cache\n"
"  object), and :HOOKS (a list of offs-hook objects)."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Code-header ~s: size: ~s, trace-table-offset: ~s~%"
msgstr ""

#: src/compiler/disassem.lisp
msgid "Fun-header ~s at offset ~d (words): ~s~a => ~s~%"
msgstr ""

#: src/compiler/disassem.lisp
msgid "The source file ~s no longer seems to exist"
msgstr ""

#: src/compiler/disassem.lisp
msgid "No start positions map"
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Source file ~s has been modified; ~@\n"
"					 Using form offset instead of file index"
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Bogus form-number in form!  The source file has probably ~@\n"
"		  been changed too much to cope with"
msgstr ""

#: src/compiler/disassem.lisp
msgid "Return the vector of debug-variables currently associated with DSTATE."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Given the OFFSET of a location within the location-group called LG-NAME,\n"
"  see if there's a current mapping to a source variable in DSTATE, and if "
"so,\n"
"  return the offset of that variable in the current debug-variable vector."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Return a new vector which has the same contents as the old one VEC, plus\n"
"  new cells (for a total size of NEW-LEN).  The additional elements are\n"
"  initailized to INITIAL-ELEMENT."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Returns a STORAGE-INFO struction describing the object-to-source\n"
"  variable mappings from DEBUG-FUNCTION."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Add hooks to track to track the source code in SEGMENT during\n"
"  disassembly.  SFCACHE can be either NIL or it can be a SOURCE-FORM-CACHE\n"
"  structure, in which case it is used to cache forms from files."
msgstr ""

#: src/compiler/disassem.lisp
msgid "No-arg-parsing entry point"
msgstr ""

#: src/compiler/disassem.lisp
msgid "~s entry point"
msgstr ""

#: src/compiler/disassem.lisp
msgid "Return the PC of FUNCTION's header."
msgstr ""

#: src/compiler/disassem.lisp
msgid "If non-NIL, disassemble flets/labels too"
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Returns a list of the segments of memory containing machine code\n"
"  instructions for FUNCTION."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Returns a list of the segments of memory containing machine code\n"
"  instructions for the code-component CODE.  If START-OFFS and/or LENGTH is\n"
"  supplied, only that part of the code-segment is used (but these are\n"
"  constrained to lie within the code-segment)."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Return the address of the instructions for function and its length.\n"
"  The length is computed using a heuristic, and so may not be accurate."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Returns two values:  the amount by which the last instruction in the\n"
"  segment goes past the end of the segment, and the offset of the end of "
"the\n"
"  segment from the beginning of that instruction.  If all instructions fit\n"
"  perfectly, this will return 0 and 0."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Computes labels for all the memory segments in SEGLIST and adds them to\n"
"  DSTATE.  It's important to call this function with all the segments "
"you're\n"
"  interested in, so it can find references from one to another."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Disassemble the machine code instructions in SEGMENT to STREAM."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Disassemble the machine code instructions in each memory segment in\n"
"  SEGMENTS in turn to STREAM."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Disassemble the machine code instructions for FUNCTION."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Cannot compile a lexical closure"
msgstr ""

#: src/compiler/disassem.lisp
msgid "Can't make a compiled function from ~S"
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Disassemble the machine code associated with OBJECT, which can be a\n"
"  function, a lambda expression, or a symbol with a function definition.  "
"If\n"
"  it is not already compiled, the compiler is called to produce something "
"to\n"
"  disassemble.\n"
"\n"
"  :Stream stream\n"
"      The dissassembly is written to this stream.\n"
"  :Use-labels\n"
"      Labels are generated instead of using instruction addresses.\n"
"  :Base\n"
"  :Case\n"
"  :Radix\n"
"      The disassembler uses the specified base, case, and radix when\n"
"      printing the disassembled code.  The default values are 16,\n"
"      :downcase, and *print-radix*, respectively."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Disassembles the given area of memory starting at ADDRESS and\n"
"  LENGTH (octets) long.  Note that if CODE-COMPONENT is NIL and this\n"
"  memory could move during a GC, you'd better disable it around the\n"
"  call to this function.  ADDRESS can be either an integer or a\n"
"  system-area-pointer.\n"
"\n"
"  :Stream stream\n"
"      The dissassembly is written to this stream.\n"
"  :Use-labels\n"
"      Labels are generated instead of using instruction addresses.\n"
"  :Base\n"
"  :Case\n"
"  :Radix\n"
"      The disassembler uses the specified base, case, and radix when\n"
"      printing the disassembled code.  The default values are 16,\n"
"      :downcase, and *print-radix*, respectively. "
msgstr ""

#: src/compiler/disassem.lisp
msgid " Address ~x not in the code component ~s."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Disassemble the machine code instructions associated with\n"
"  CODE-COMPONENT (this may include multiple entry points)."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Disassemble the machine code instructions associated with\n"
"  ASSEM-SEGMENT (of type new-assem:segment)."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"An alist of (SYMBOL-SLOT-OFFSET . ACCESS-FUNCTION-NAME) for slots in a\n"
"symbol object that we know about."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Given ADDRESS, try and figure out if which slot of which symbol is being\n"
"  refered to.  Of course we can just give up, so it's not a big deal...\n"
"  Returns two values, the symbol and the name of the access function of the\n"
"  slot."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Given a BYTE-OFFSET from NIL, try and figure out if which slot of which\n"
"  symbol is being refered to.  Of course we can just give up, so it's not a "
"big\n"
"  deal...  Returns two values, the symbol and the access function."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Returns the lisp object located BYTE-OFFSET from NIL."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Returns two values; the lisp-object located at BYTE-OFFSET in the constant\n"
"  area of the code-object in the current segment and T, or NIL and NIL if\n"
"  there is no code-object in the current segment."
msgstr ""

#: src/compiler/disassem.lisp
msgid "Build an address-name hash-table from the name-address hash"
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Returns the name of the primitive lisp assembler routine or foreign\n"
"  symbol located at ADDRESS, or NIL if there isn't one."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Store NOTE (which can be either a string or a function with a single\n"
"  stream argument) to be printed as an end-of-line comment after the "
"current\n"
"  instruction is disassembled."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Store a note about the lisp constant located BYTE-OFFSET bytes from the\n"
"  current code-component, to be printed as an end-of-line comment after the\n"
"  current instruction is disassembled."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"Store a note about the lisp constant located at ADDR in the\n"
"  current code-component, to be printed as an end-of-line comment after the\n"
"  current instruction is disassembled."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"If the memory address located NIL-BYTE-OFFSET bytes from the constant NIL\n"
"  is a valid slot in a symbol, store a note describing which symbol and "
"slot,\n"
"  to be printed as an end-of-line comment after the current instruction is\n"
"  disassembled.  Returns non-NIL iff a note was recorded."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"If the memory address located NIL-BYTE-OFFSET bytes from the constant NIL\n"
"  is a valid lisp object, store a note describing which symbol and slot, to\n"
"  be printed as an end-of-line comment after the current instruction is\n"
"  disassembled.  Returns non-NIL iff a note was recorded."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"If ADDRESS is the address of a primitive assembler routine or\n"
"  foreign symbol, store a note describing which one, to be printed as\n"
"  an end-of-line comment after the current instruction is disassembled.\n"
"  Returns non-NIL iff a note was recorded.  If NOTE-ADDRESS-P is non-NIL, a\n"
"  note of the address is also made."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"If NIL-BYTE-OFFSET is the offset of static function, store a note\n"
"  describing which one, to be printed as an end-of-line comment after\n"
"  the current instruction is disassembled.  Returns non-NIL iff a note\n"
"  was recorded."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"If there's a valid mapping from OFFSET in the storage class SC-NAME to a\n"
"  source variable, make a note of the source-variable name, to be printed "
"as\n"
"  an end-of-line comment after the current instruction is disassembled.\n"
"  Returns non-NIL iff a note was recorded."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"If there's a valid mapping from OFFSET in the storage-base called SB-NAME\n"
"  to a source variable, make a note equating ASSOC-WITH with the\n"
"  source-variable name, to be printed as an end-of-line comment after the\n"
"  current instruction is disassembled.  Returns non-NIL iff a note was\n"
"  recorded."
msgstr ""

#: src/compiler/disassem.lisp
msgid ""
"When called from an error break instruction's :DISASSEM-CONTROL (or\n"
"  :DISASSEM-PRINTER) function, will correctly deal with printing the\n"
"  arguments to the break.\n"
"\n"
"  ERROR-PARSE-FUN should be a function that accepts:\n"
"    1) a SYSTEM-AREA-POINTER\n"
"    2) a BYTE-OFFSET from the SAP to begin at\n"
"    3) optionally, LENGTH-ONLY, which if non-NIL, means to only return\n"
"       the byte length of the arguments (to avoid unnecessary consing)\n"
"  It should read information from the SAP starting at BYTE-OFFSET, and "
"return\n"
"  four values:\n"
"    1) the error number\n"
"    2) the total length, in bytes, of the information\n"
"    3) a list of SC-OFFSETs of the locations of the error parameters\n"
"    4) a list of the length (as read from the SAP), in bytes, of each of "
"the\n"
"       return-values."
msgstr ""

#: src/compiler/new-assem.lisp
msgid "Set up the assembler."
msgstr ""

#: src/compiler/new-assem.lisp
msgid ""
"Execute BODY (as a progn) without scheduling any of the instructions\n"
"   generated inside it.  DO NOT throw or return-from out of it."
msgstr ""

#: src/compiler/new-assem.lisp
msgid "Emit BYTE to SEGMENT."
msgstr ""

#: src/compiler/new-assem.lisp
msgid "Output AMOUNT zeros (in bytes) to SEGMENT."
msgstr ""

#: src/compiler/new-assem.lisp
msgid "Attempt to emit ~S for the second time."
msgstr ""

#: src/compiler/new-assem.lisp
msgid ""
"Note that the instruction stream has to be back-patched when label positions"
"\n"
"   are finally known.  SIZE bytes are reserved in SEGMENT, and function "
"will\n"
"   be called with two arguments: the segment and the position.  The function"
"\n"
"   should look at the position and the position of any labels it wants to\n"
"   and emit the correct sequence.  (And it better be the same size as SIZE)"
".\n"
"   SIZE can be zero, which is useful if you just want to find out where "
"things\n"
"   ended up."
msgstr ""

#: src/compiler/new-assem.lisp
msgid ""
"Note that the instruction stream here depends on the actual positions of\n"
"   various labels, so can't be output until label positions are known.  "
"Space\n"
"   is made in SEGMENT for at least SIZE bytes.  When all output has been\n"
"   generated, the MAYBE-SHRINK functions for all choosers are called with\n"
"   three arguments: the segment, the position, and a magic value.  The "
"MAYBE-\n"
"   SHRINK decides if it can use a shorter sequence, and if so, emits that\n"
"   sequence to the segment and returns T.  If it can't do better than the\n"
"   worst case, it should return NIL (without emitting anything).  When "
"calling\n"
"   LABEL-POSITION, it should pass it the position and the magic-value it "
"was\n"
"   passed so that LABEL-POSITION can return the correct result.  If the "
"chooser\n"
"   never decides to use a shorter sequence, the WORST-CASE-FUN will be "
"called,\n"
"   just like a BACK-PATCH.  (See EMIT-BACK-PATCH.)"
msgstr ""

#: src/compiler/new-assem.lisp
msgid "~S emitted ~D bytes, but claimed it's max was ~D"
msgstr ""

#: src/compiler/new-assem.lisp
msgid ""
"~S shrunk by ~D bytes, but claimed that it ~\n"
"			    preserve ~D bits of alignment."
msgstr ""

#: src/compiler/new-assem.lisp
msgid "Chooser ~S passed, but not before emitting ~D bytes."
msgstr ""

#: src/compiler/new-assem.lisp
msgid "Alignment ~S needs more space now?  It was ~D, ~\n"
"			    and is ~D now."
msgstr ""

#: src/compiler/new-assem.lisp
msgid "~S emitted ~D bytes, but claimed it's was ~D"
msgstr ""

#: src/compiler/new-assem.lisp
msgid "Execute BODY (as a progn) with SEGMENT as the current segment."
msgstr ""

#: src/compiler/new-assem.lisp
msgid "Duplicate nested labels: ~S"
msgstr ""

#: src/compiler/new-assem.lisp
msgid "Emit the specified instruction to the current segment."
msgstr ""

#: src/compiler/new-assem.lisp
msgid "Unknown instruction: ~S"
msgstr ""

#: src/compiler/new-assem.lisp
msgid "Emit LABEL at this location in the current segment."
msgstr ""

#: src/compiler/new-assem.lisp
msgid "Emit an alignment restriction to the current segment."
msgstr ""

#: src/compiler/new-assem.lisp
msgid ""
"Return the current position for LABEL.  Chooser maybe-shrink functions\n"
"   should supply IF-AFTER and DELTA to assure correct results."
msgstr ""

#: src/compiler/new-assem.lisp
msgid ""
"Append OTHER-SEGMENT to the end of SEGMENT.  Don't use OTHER-SEGMENT\n"
"   for anything after this."
msgstr ""

#: src/compiler/new-assem.lisp
msgid ""
"Does any final processing of SEGMENT and returns the total number of bytes\n"
"   covered by this segment."
msgstr ""

#: src/compiler/new-assem.lisp
msgid ""
"Call FUNCTION on all the output accumulated in SEGMENT.  FUNCTION is called\n"
"   zero or more times with two arguments: a SAP and a number of bytes."
msgstr ""

#: src/compiler/new-assem.lisp
msgid "Releases any output buffers held on to by segment."
msgstr ""

#: src/compiler/new-assem.lisp
msgid ""
"Byte spec ~S either overlaps another byte spec, or ~\n"
"		    extends past the end in emitter ~S."
msgstr ""

#: src/compiler/new-assem.lisp
msgid "There are holes in emitter ~S."
msgstr ""

#: src/compiler/new-assem.lisp
msgid "~D isn't an even multiple of ~D in emitter ~S"
msgstr ""

#: src/compiler/new-assem.lisp
msgid "Can only specify one emitter per instruction."
msgstr ""

#: src/compiler/new-assem.lisp
msgid "Can only specify delay once per instruction."
msgstr ""

#: src/compiler/new-assem.lisp
msgid "Can only specify :vop-var once."
msgstr ""

#: src/compiler/alloc.lisp
msgid ""
"defallocators {((name lambda-list [real-lambda-list]) thread-slot\n"
"                   (deinit-form*)\n"
"		   (reinit-form*))}*"
msgstr ""

#: src/compiler/knownfun.lisp
msgid "optimize"
msgstr ""

#: src/compiler/knownfun.lisp
msgid "~S is not a known function."
msgstr ""

#: src/compiler/main.lisp
msgid "The default value for the :Block-Compile argument to COMPILE-FILE."
msgstr ""

#: src/compiler/main.lisp
msgid "The default value for the :Byte-Compile argument to COMPILE-FILE."
msgstr ""

#: src/compiler/main.lisp
msgid ""
"Similar to *BYTE-COMPILE-DEFAULT*, but controls the compilation of top-level"
"\n"
"  forms (evaluated at load-time) when the :BYTE-COMPILE argument is :MAYBE\n"
"  (the default.)  When true, we decide to byte-compile."
msgstr ""

#: src/compiler/main.lisp
msgid "Whether loop analysis should be done or not."
msgstr ""

#: src/compiler/main.lisp
msgid "Whether the compiler should record cross-reference information."
msgstr ""

#: src/compiler/main.lisp
msgid "The default for the :VERBOSE argument to COMPILE-FILE."
msgstr ""

#: src/compiler/main.lisp
msgid "The default for the :PRINT argument to COMPILE-FILE."
msgstr ""

#: src/compiler/main.lisp
msgid "The default for the :PROGRESS argument to COMPILE-FILE."
msgstr ""

#: src/compiler/main.lisp
msgid ""
"The defaulted pathname of the file currently being compiled, or NIL if not\n"
"  compiling."
msgstr ""

#: src/compiler/main.lisp
msgid ""
"The TRUENAME of the file currently being compiled, or NIL if not\n"
"  compiling."
msgstr ""

#: src/compiler/main.lisp
msgid ""
"The user supplied source-info for the current compilation.  \n"
"  This is the :source-info argument to COMPILE-FROM-STREAM and will be\n"
"  stored in the INFO slot of the DEBUG-SOURCE in code components and \n"
"  in the user USER-INFO slot of STREAM-SOURCE-LOCATIONs."
msgstr ""

#: src/compiler/main.lisp
msgid ""
"The upper limit on the number of times that we will consecutively do IR1\n"
"  optimization that doesn't introduce any new code.  A finite limit is\n"
"  necessary, since type inference may take arbitrarily long to converge."
msgstr ""

#: src/compiler/main.lisp
msgid "~|~%Disassembly of code for ~S~2%"
msgstr ""

#: src/compiler/main.lisp
msgid "~:[~;Byte ~]Compiling ~A: "
msgstr ""

#: src/compiler/main.lisp
msgid "Undefined ~(~A~) ~S~@[ ~A~]"
msgstr ""

#: src/compiler/main.lisp
msgid "~D more use~:P of undefined ~(~A~) ~S."
msgstr ""

#: src/compiler/main.lisp
msgid ""
"~:[This ~(~A~) is~;These ~(~A~)s are~] undefined:~\n"
"		~%  ~{~<~%  ~1:;~S~>~^ ~}"
msgstr ""

#: src/compiler/main.lisp
msgid ""
"~2&; Compilation unit ~:[finished~;aborted~].~\n"
"      ~[~:;~:*~&;   ~D fatal error~:P~]~\n"
"      ~[~:;~:*~&;   ~D error~:P~]~\n"
"      ~[~:;~:*~&;   ~D warning~:P~]~\n"
"      ~[~:;~:*~&;   ~D note~:P~]~2%"
msgstr ""

#: src/compiler/main.lisp
msgid "~|~%;;;; Component: ~S~2%"
msgstr ""

#: src/compiler/main.lisp
msgid "~%~|~%;;;; IR2 component: ~S~2%"
msgstr ""

#: src/compiler/main.lisp
msgid "Entries:~%"
msgstr ""

#: src/compiler/main.lisp
msgid "~4TL~D: ~S~:[~; [Closure]~]~%"
msgstr ""

#: src/compiler/main.lisp
msgid "Read error at ~D:~% \"~A/\\~A\"~%~A"
msgstr ""

#: src/compiler/main.lisp
msgid "Unable to recover from read error."
msgstr ""

#: src/compiler/main.lisp
msgid "Read error in form starting at ~D:~%~@[ \"~A\"~%~]~A"
msgstr ""

#: src/compiler/ir1tran.lisp src/compiler/main.lisp
msgid "(during macroexpansion)~%~A"
msgstr ""

#: src/compiler/main.lisp
msgid ""
"If non-Nil, use git to derive the file-comment.  This info includes\n"
"  the sha1 hash, the time and the author of the change.  Otherwise,\n"
"  just use the supplied file-comment."
msgstr ""

#: src/compiler/main.lisp
msgid "Bad FILE-COMMENT form: ~S."
msgstr ""

#: src/compiler/main.lisp
msgid "Ignoring extra file comment:~%  ~S."
msgstr ""

#: src/compiler/main.lisp
msgid "~&; Comment: ~A~2&"
msgstr ""

#: src/compiler/main.lisp
msgid "EVAL-WHEN form is too short: ~S."
msgstr ""

#: src/compiler/main.lisp
msgid "MACROLET form is too short: ~S."
msgstr ""

#: src/compiler/main.lisp
msgid "Load Time Value of ~S"
msgstr ""

#: src/compiler/main.lisp
msgid "(while making load form for ~S)~%~A"
msgstr ""

#: src/compiler/main.lisp
msgid "Circular references in creation form for ~S"
msgstr ""

#: src/compiler/main.lisp
msgid "Creation Form for ~A"
msgstr ""

#: src/compiler/main.lisp
msgid "Init Form~:[~;s~] for ~{~A~^, ~}"
msgstr ""

#: src/compiler/main.lisp
msgid "~2&Fatal error, aborting compilation...~%"
msgstr ""

#: src/compiler/main.lisp
msgid "Can't compile with no source files."
msgstr ""

#: src/compiler/main.lisp
msgid ""
"Similar to COMPILE-FILE, but compiles text from Stream into the current "
"lisp\n"
"  environment.  Stream is closed when compilation is complete.  These "
"keywords\n"
"  are supported:\n"
"\n"
"  :Error-Stream\n"
"      The stream to write compiler error output to (default *ERROR-OUTPUT*.)"
"\n"
"  :Trace-Stream\n"
"      The stream that we write compiler trace output to, or NIL (the "
"default)\n"
"      to inhibit trace output.\n"
"  :Block-Compile {T, NIL, :SPECIFIED}\n"
"        If true, then function names may be resolved at compile time.\n"
"  :Source-Info\n"
"        Some object to be placed in the DEBUG-SOURCE-INFO.\n"
"  :Byte-Compile {T, NIL, :MAYBE}\n"
"        If true, then may compile to interpreted byte code."
msgstr ""

#: src/compiler/main.lisp
msgid "~2&; Python version ~A, VM version ~A on ~A.~%"
msgstr ""

#: src/compiler/main.lisp
msgid "; Compiling: ~A ~A~%"
msgstr ""

#: src/compiler/main.lisp
msgid "~&; Compilation ~:[aborted after~;finished in~] ~A.~&"
msgstr ""

#: src/compiler/main.lisp
msgid ""
"Compiles Source, producing a corresponding FASL file.  Source may be a list\n"
"  of files, in which case the files are compiled as a unit, producing a "
"single\n"
"  FASL file.  The output file names are defaulted from the first (or only)\n"
"  input file name.  (The use of a list for Source is a CMUCL extension, not\n"
"  specified in CLHS.)\n"
"\n"
"  These keywords are supported:\n"
"\n"
"  :Output-File\n"
"     The name of the FASL to output, NIL for none, T for the default.\n"
"     (Note the difference between the treatment of NIL :Output-File\n"
"     here and in COMPILE-FILE-PATHNAME.)  The returned pathname of the\n"
"     output file may differ from the pathname of the :Output-File\n"
"     parameter, e.g. when the latter is a designator for a directory.\n"
"  :Load\n"
"     Load the compiled file; T here requires :Output-File to be\n"
"     non-NIL, as well.  The default for :Load is NIL.\n"
"  :Error-File\n"
"     The name of the error listing file, NIL for none (the default), T for "
".err.\n"
"  :Trace-File\n"
"     If specified, internal data structures are dumped to this file.  T for\n"
"     the .trace default.\n"
"  :Error-Output\n"
"     If a stream, then error output is sent there as well as to the listing\n"
"     file.  NIL suppresses this additional error output.  The default is T,\n"
"     which means use *ERROR-OUTPUT*.\n"
"  :Block-Compile {NIL | :SPECIFIED | T}\n"
"     Determines whether multiple functions are compiled together as a unit,\n"
"     resolving function references at compile time.  NIL means that global\n"
"     function names are never resolved at compilation time.  :SPECIFIED "
"means\n"
"     that names are resolved at compile-time when convenient (as in a\n"
"     self-recursive call), but the compiler doesn't combine top-level "
"DEFUNs.\n"
"     With :SPECIFIED, an explicit START-BLOCK declaration will enable block\n"
"     compilation.  A value of T indicates that all forms in the file(s) "
"should\n"
"     be compiled as a unit.  The default is the value of\n"
"     EXT:*BLOCK-COMPILE-DEFAULT*, which is initially :SPECIFIED.\n"
"  :Entry-Points\n"
"     This specifies a list of function names for functions in the file(s) "
"that\n"
"     must be given global definitions.  This only applies to block\n"
"     compilation, and is useful mainly when :BLOCK-COMPILE T is specified "
"on a\n"
"     file that lacks START-BLOCK declarations.  If the value is NIL (the\n"
"     default) then all functions will be globally defined.\n"
"  :Byte-Compile {T | NIL | :MAYBE}\n"
"     Determines whether to compile into interpreted byte code instead of\n"
"     machine instructions.  Byte code is several times smaller, but much\n"
"     slower.  If :MAYBE, then only byte-compile when SPEED is 0 and\n"
"     DEBUG <= 1.  The default is the value of EXT:*BYTE-COMPILE-DEFAULT*,\n"
"     which is initially :MAYBE.\n"
"  :Xref\n"
"     If non-NIL, enable recording of cross-reference information.  The "
"default\n"
"     is the value of C:*RECORD-XREF-INFO*\n"
"  :External-Format\n"
"     The external format to use when opening the source file.\n"
"  :Decoding-Error\n"
"     How to handle decoding errors in the external format when reading the\n"
"     source file.  Default (T) is to signal an error.  NIL means silently\n"
"     continue, replacing the invalid sequence with a suitable replacment\n"
"     character."
msgstr ""

#: src/compiler/main.lisp
msgid "~2&; ~A written.~%"
msgstr ""

#: src/compiler/main.lisp
msgid "Can't :LOAD with no output file."
msgstr ""

#: src/compiler/main.lisp
msgid "~S was defined in a non-null environment."
msgstr ""

#: src/compiler/main.lisp
msgid "Can't find a definition for ~S."
msgstr ""

#: src/compiler/main.lisp
msgid ""
"Compiles the function (or macro-function) whose name is NAME.  If\n"
"  DEFINITION is supplied, it should be a lambda expression which will\n"
"  be compiled.  IF NAME names a macro, then the compiled expression\n"
"  replaces the existing macro-function.  If NAME names a function, the\n"
"  compiled expression is placed in the function cell of NAME.  If NAME\n"
"  is NIL, the compiled code object is returned."
msgstr ""

#: src/compiler/main.lisp
msgid ""
"Attempt to replace Name's definition with an interpreted version of that\n"
"  definition.  If no interpreted definition is to be found, then signal an\n"
"  error."
msgstr ""

#: src/compiler/main.lisp
msgid "~S is already interpreted."
msgstr ""

#: src/compiler/main.lisp
msgid ""
"Return a pathname describing what file COMPILE-FILE would write to\n"
"  given these arguments.  The returned pathname of the output file may\n"
"  differ from the pathname of the :Output-File parameter, e.g. when\n"
"  the latter is a designator for a directory. The CMUCL caveat: NIL is\n"
"  accepted for :Output-File there but not here, which is probably not\n"
"  in line with CLHS."
msgstr ""

#: src/compiler/main.lisp
msgid ""
"The ~A parameter is a ~S, which is an invalid value ~@\n"
"            to COMPILE-FILE-PATHNAME."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"If true, argument and result type information derived from compilation of\n"
"  DEFUNs is used when compiling calls to that function.  If false, only\n"
"  information from FTYPE proclamations will be used."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"If NIL, never trust dynamic-extent declarations.\n"
"\n"
"   If T, always trust dynamic-extent declarations.\n"
"\n"
"   Otherwise, the value of this variable must be a function of four\n"
"   arguments SAFETY, SPACE, SPEED, and DEBUG.  If the function returns\n"
"   true when called, dynamic-extent declarations are trusted,\n"
"   otherwise they are not trusted."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "~@<Invalid name ~s in a dynamic-extent declaration.~@:>"
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Can't find slot ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Found macro name ~S ~A."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Found special-form name ~S ~A."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Cannot dump objects of type ~S into fasl files."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "~S has already ended."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "~S already has successors."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "~S is already a predecessor of ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Misplaced declaration."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Illegal function call."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Reading an ignored variable: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "~&dynamic-extent args ~:s in ~s~%"
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Conflicting type declarations ~\n"
"				   ~S and ~S for ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Can't declare type of Alien variable: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Declaring symbol-macro ~S special."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Ignored variable ~S is being declared special."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"Ignoring ~A declaration not at ~\n"
"				   definition of local function:~%  ~S"
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Unrecognizable function or variable name: ~S"
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Ignoring free ignore declaration for ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Ignore declaration for unknown variable ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Declaring special variable ~S to be ignored."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "If true, processing of the VALUES declaration is inhibited."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "No type specified in FTYPE declaration: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Abbreviated type declaration: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Unrecognized declaration: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Malformed declaration specifier ~S in ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Declaring an alien variable to be special: ~S"
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Declaring a constant to be special: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Lambda-variable is not a symbol: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Repeated variable in lambda-list: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Name of lambda-variable is a constant: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Multiple uses of keyword ~S in lambda-list."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Found a ~S when expecting a lambda expression:~%  ~S"
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Expecting a lambda, but form begins with ~S:~%  ~S"
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Lambda-list absent or not a list:~%  ~S"
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "ir1-convert-lambda: called by: ~S, parent-form: ~S~%"
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Arg specifier is too long: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Malformed &aux binding specifier: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Malformed keyword arg specifier: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"Progn Form*\n"
"  Evaluates each Form in order, returing the values of the last form.  With "
"no\n"
"  forms, returns NIL."
msgstr ""

#: src/compiler/ir2tran.lisp src/compiler/ltv.lisp src/compiler/ir1tran.lisp
msgid "Can't funcall the SYMBOL-FUNCTION of the special form ~A."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"If Predicate Then [Else]\n"
"  If Predicate evaluates to non-null, evaluate Then and returns its values,\n"
"  otherwise evaluate Else and return its values.  Else defaults to NIL."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Block name is not a symbol: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"Block Name Form*\n"
"  Evaluate the Forms as a PROGN.  Within the lexical scope of the body,\n"
"  (RETURN-FROM Name Value-Form) can be used to exit the form, returning the\n"
"  result of Value-Form."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Return for unknown block: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"Return-From Block-Name Value-Form\n"
"  Evaluate the Value-Form, returning its values from the lexically enclosing"
"\n"
"  BLOCK Block-Name.  This is constrained to be used only within the dynamic\n"
"  extent of the BLOCK."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Repeated tagbody tag: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Illegal tagbody statement: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"Tagbody {Tag | Statement}*\n"
"  Define tags for used with GO.  The Statements are evaluated in order\n"
"  (skipping Tags) and NIL is returned.  If a statement contains a GO to a\n"
"  defined Tag within the lexical scope of the form, then control is transfer"
"red\n"
"  to the next statement following that tag.  A Tag must an integer or a\n"
"  symbol.  A statement must be a list.  Other objects are illegal within "
"the\n"
"  body."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Go to nonexistent tag: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"Go Tag\n"
"  Transfer control to the named Tag in the lexically enclosing TAGBODY.  "
"This\n"
"  is constrained to be used only within the dynamic extent of the TAGBODY."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Bad compiler-let binding spec: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"EVAL-WHEN (Situation*) Form*\n"
"  Evaluate the Forms in the specified Situations, any of :COMPILE-TOPLEVEL,\n"
"  :LOAD-TOPLEVEL, :EXECUTE."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Macro name ~S is not a symbol."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Local macro ~S has argument list that is not a list: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Local macro ~S is too short to be a legal definition."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"MACROLET ({(Name Lambda-List Form*)}*) Body-Form*\n"
"  Evaluate the Body-Forms in an environment with the specified local macros\n"
"  defined.  Name is the local macro name, Lambda-List is the DEFMACRO style\n"
"  destructuring lambda list, and the Forms evaluate to the expansion."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Bogus binding for ~\n"
"						     COMPILER-OPTION-BIND: ~S"
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"Compiler-Option-Bind ({(Name Value-Form)}*) Body-Form*\n"
"   Establish the specified compiler options for the (lexical) duration of\n"
"   the body.  The Value-Forms are evaluated at compile time."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Lisp error during evaluation of info args:~%~A"
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "%Primitive name is not a symbol: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Undefined primitive name: ~A."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"Primitive called with ~R argument~:P, ~\n"
"	    		         but wants at least ~R."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Primitive called with ~R argument~:P, ~\n"
"				 but wants exactly ~R."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "%Primitive used with a conditional template."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "%Primitive used with an unknown values template."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "QUOTE Value\n"
"  Return Value without evaluating it."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Illegal function name: ~S"
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"FUNCTION Name\n"
"  Return the lexically apparent definition of the function Name.  Name may "
"also\n"
"  be a lambda."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Might be a symbol, so must call FDEFINITION at runtime."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Malformed symbol macro binding: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"Attempt to bind a special or constant variable with SYMBOL-MACROLET: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Repeated name in SYMBOL-MACROLET: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"SYMBOL-MACROLET ({(Name Expansion)}*) Decl* Form*\n"
"  Define the Names as symbol macros with the given Expansions.  Within the\n"
"  body, references to a Name will effectively be replaced with the Expansion"
"."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Name is not a symbol: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "New proclaimed type ~S for ~S conflicts with old type ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Attempt to proclaim constant ~S to be special."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Malformed TYPE proclamation: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Malformed FUNCTION proclamation: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Malformed FTYPE proclamation: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Malformed ~S binding spec: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"LET ({(Var [Value]) | Var}*) Declaration* Form*\n"
"  During evaluation of the Forms, Bind the Vars to the result of evaluating "
"the\n"
"  Value forms.  The variables are bound in parallel after all of the Values "
"are\n"
"  evaluated."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"LOCALLY Declaration* Form*\n"
"   Sequentially evaluates a body of Form's in a lexical environment\n"
"   where the given Declaration's have effect."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"LET* ({(Var [Value]) | Var}*) Declaration* Form*\n"
"  Similar to LET, but the variables are bound sequentially, allowing each "
"Value\n"
"  form to reference any of the previous Vars."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Malformed ~S definition spec: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"FLET ({(Name Lambda-List Declaration* Form*)}*) Declaration* Body-Form*\n"
"  Evaluate the Body-Forms with some local function definitions.   The "
"bindings\n"
"  do not enclose the definitions; any use of Name in the Forms will refer "
"to\n"
"  the lexically apparent function definition in the enclosing environment."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"LABELS ({(Name Lambda-List Declaration* Form*)}*) Declaration* Body-Form*\n"
"  Evaluate the Body-Forms with some local function definitions.  The "
"bindings\n"
"  enclose the new definitions, so the defined functions can call themselves "
"or\n"
"  each other."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Type ~S in ~S declaration conflicts with enclosing assertion:~%   ~S"
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"THE Type Form\n"
"  Assert that Form evaluates to the specified type (which may be a VALUES\n"
"  type.)"
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"Truly-The Type Value\n"
"  Like the THE special form, except that it believes whatever you tell it.  "
"It\n"
"  will never generate a type check, but will cause a warning if the compiler"
"\n"
"  can prove the assertion is wrong."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Odd number of args to SETQ: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Attempt to set constant ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Setting an ignored variable: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"SETQ {Var Value}*\n"
"  Set the variables to the values.  If more than one pair is supplied, the\n"
"  assignments are done sequentially.  If Var names a symbol macro, SETF the\n"
"  expansion."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"Throw Tag Form\n"
"  Do a non-local exit, return the values of Form from the CATCH whose tag\n"
"  evaluates to the same thing as Tag."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"Catch Tag Form*\n"
"  Evaluates Tag and instantiates it as a catcher while the body forms are\n"
"  evaluated in an implicit PROGN.  If a THROW is done to Tag within the "
"dynamic\n"
"  scope of the body, then control will be transferred to the end of the "
"body\n"
"  and the thrown values will be returned."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"Unwind-Protect Protected Cleanup*\n"
"  Evaluate the form Protected, returning its values.  The cleanup forms are\n"
"  evaluated whenever the dynamic scope of the Protected form is exited "
"(either\n"
"  due to normal completion or a non-local exit such as THROW)."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"MULTIPLE-VALUE-CALL Function Values-Form*\n"
"  Call Function, passing all the values of each Values-Form as arguments,\n"
"  values from the first Values-Form making up the first argument, etc."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid ""
"MULTIPLE-VALUE-PROG1 Values-Form Form*\n"
"  Evaluate Values-Form and then the Forms, but return all the values of\n"
"  Values-Form."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Macro name is not a symbol: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Defining ~S to be a macro when it was ~(~A~) to be a function."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Attempt to redefine special form ~S as a macro."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "~&; Converted ~S.~%"
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Attempt to define a compiler-macro for special form ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Constant name is not a symbol: ~S."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Can't change T."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Nihil ex nihil (Can't change NIL)."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Can't change the value of keywords."
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Redefining constant ~S as:~%  ~S"
msgstr ""

#: src/compiler/ir1tran.lisp
msgid "Redefining ~(~A~) ~S to be a constant."
msgstr ""

#: src/compiler/ir1util.lisp
msgid ""
"Return the TLF-NUMBER and FORM-NUMBER encoded as fixnum, if\n"
"  possible.  Otherwise, return Nil."
msgstr ""

#: src/compiler/ir1util.lisp
msgid "Return the tlf-number and form-number from an encoded FIXNUM."
msgstr ""

#: src/compiler/ir1util.lisp
msgid "Return a source-location for the call site."
msgstr ""

#: src/compiler/ir1util.lisp
msgid "Deleting unused function~:[.~;~:*~%  ~S~]"
msgstr ""

#: src/compiler/ir1util.lisp
msgid "Block is already deleted."
msgstr ""

#: src/compiler/ir1util.lisp
msgid "Variable ~S defined but never used."
msgstr ""

#: src/compiler/ir1util.lisp
msgid "Deleting unreachable code."
msgstr ""

#: src/compiler/ir1util.lisp
msgid ""
"If CONT is a call to FUN with NUM-ARGS args, change those arguments\n"
"   to feed directly to the continuation-dest of CONT, which must be\n"
"   a combination."
msgstr ""

#: src/compiler/ir1util.lisp
msgid ""
"An upper limit on the number of inline function calls that will be expanded\n"
"   in any given code object (single function or block compilation.)"
msgstr ""

#: src/compiler/ir1util.lisp
msgid ""
"*Inline-Expansion-Limit* (~D) exceeded, ~\n"
"			     probably trying to~%  ~\n"
"			     inline a recursive function."
msgstr ""

#: src/compiler/ir1util.lisp
msgid "The value for *Print-Level* when printing compiler error messages."
msgstr ""

#: src/compiler/ir1util.lisp
msgid "The value for *Print-Length* when printing compiler error messages."
msgstr ""

#: src/compiler/ir1util.lisp
msgid "The value for *Print-Lines* when printing compiler error messages."
msgstr ""

#: src/compiler/ir1util.lisp
msgid ""
"The maximum number of enclosing non-original source forms (i.e. from\n"
"  macroexpansion) that we print in full.  For additional enclosing forms, "
"we\n"
"  print only the CAR."
msgstr ""

#: src/compiler/ir1util.lisp
msgid ""
"DEF-SOURCE-CONTEXT Name Lambda-List Form*\n"
"   This macro defines how to extract an abbreviated source context from the\n"
"   Named form when it appears in the compiler input.  Lambda-List is a "
"DEFMACRO\n"
"   style lambda-list used to parse the arguments.  The Body should return a\n"
"   list of subforms suitable for a \"~{~S ~}\" format string."
msgstr ""

#: src/compiler/ir1util.lisp
msgid "Compiler-Error with no bailout."
msgstr ""

#: src/compiler/ir1util.lisp
msgid ""
"This is the function called by the compiler to specially note a\n"
"warning, comment, or error. The function must take five arguments: the\n"
"severity, a string describing the nature of the notification, a string\n"
"for context, the file namestring, and the file position. The severity\n"
"is one of :note, :warning, or :error. Except for the severity, all of\n"
"these can be NIL if unavailable or inapplicable."
msgstr ""

#: src/compiler/ir1util.lisp
msgid "[Last message occurs ~D times]"
msgstr ""

#: src/compiler/ir1util.lisp
msgid "~2&File: ~A"
msgstr ""

#: src/compiler/ir1util.lisp
msgid "In:~{~<~%   ~4:;~{ ~S~}~>~^ =>~}"
msgstr ""

#: src/compiler/ir1util.lisp
msgid "replace form with call to ERROR."
msgstr ""

#: src/compiler/ir1util.lisp
msgid "ignore it."
msgstr ""

#: src/compiler/ir1util.lisp
msgid ""
"If non-null, then an upper limit on the number of unknown function or type\n"
"  warnings that the compiler will print for any given name in a single\n"
"  compilation.  This prevents excessive amounts of output when there really "
"is\n"
"  a missing definition (as opposed to a typo in the use.)"
msgstr ""

#: src/compiler/ir1util.lisp
msgid "Lisp error during ~A:~%~A"
msgstr ""

#: src/compiler/ir1opt.lisp
msgid "New inferred type ~S conflicts with old type:~\n"
"		~%  ~S~%*** Bug?"
msgstr ""

#: src/compiler/ir1opt.lisp
msgid "The return value of ~A should not be discarded."
msgstr ""

#: src/compiler/ir1opt.lisp
msgid ""
"This function is used to throw out of an IR1 transform, aborting this\n"
"  attempt to transform the call, but admitting the possibility that this or\n"
"  some other transform will later suceed.  If arguments are supplied, they "
"are\n"
"  format arguments for an efficiency note."
msgstr ""

#: src/compiler/ir1opt.lisp
msgid ""
"This function is used to throw out of an IR1 transform and force a normal\n"
"  call to the function at run time.  No further optimizations will be\n"
"  attempted."
msgstr ""

#: src/compiler/ir1opt.lisp
msgid ""
"This function is used to throw out of an IR1 transform, and delay the\n"
"  transform on the node until later. The reasons specifies when the transfor"
"m\n"
"  will be later retried. The :optimize reason causes the transform to be\n"
"  delayed until after the current IR1 optimization pass. The :constraint\n"
"  reason causes the transform to be delayed until after constraint\n"
"  propagation."
msgstr ""

#: src/compiler/ir1opt.lisp
msgid ""
"MULTIPLE-VALUE-CALL with ~R values when the function expects ~\n"
"	     at least ~R."
msgstr ""

#: src/compiler/ir1opt.lisp
msgid ""
"MULTIPLE-VALUE-CALL with ~R values when the function expects ~\n"
"	     at most ~R."
msgstr ""

#: src/compiler/ir1final.lisp
msgid "Unable to ~A because:~%~6T~?"
msgstr ""

#: src/compiler/ir1final.lisp
msgid ""
"Unable to ~A due to type uncertainty:~@\n"
"	                      ~{~6T~?~^~&~}"
msgstr ""

#: src/compiler/ir1final.lisp
msgid ""
"The result type from previous declaration:~%  ~S~@\n"
"				  conflicts with the result type:~%  ~S"
msgstr ""

#: src/compiler/array-tran.lisp
msgid "Default initial element ~s is not a ~s."
msgstr ""

#: src/compiler/array-tran.lisp
msgid "Cannot open-code creation of ~S"
msgstr ""

#: src/compiler/array-tran.lisp
msgid "Element-Type is not constant."
msgstr ""

#: src/compiler/array-tran.lisp
msgid "Element-type not constant; cannot open code array creation"
msgstr ""

#: src/compiler/array-tran.lisp
msgid "Dimension list not constant; cannot open code array creation"
msgstr ""

#: src/compiler/array-tran.lisp
msgid "Dimension list contains something other than an integer: ~S"
msgstr ""

#: src/compiler/array-tran.lisp
msgid "Array rank not known at compile time: ~S"
msgstr ""

#: src/compiler/array-tran.lisp
msgid "Axis not constant."
msgstr ""

#: src/compiler/array-tran.lisp
msgid "Array dimensions unknown, must call array-dimension at runtime."
msgstr ""

#: src/compiler/array-tran.lisp
msgid "Array has dimensions ~S, ~D is too large."
msgstr ""

#: src/compiler/array-tran.lisp
msgid "Can't tell if array is simple."
msgstr ""

#: src/compiler/array-tran.lisp
msgid "Vector length unknown, must call length at runtime."
msgstr ""

#: src/compiler/array-tran.lisp
msgid "Can't tell the rank at compile time."
msgstr ""

#: src/compiler/array-tran.lisp
msgid ""
"Array type ambiguous; must call ~\n"
"	              array-has-fill-pointer-p at runtime."
msgstr ""

#: src/compiler/seqtran.lisp
msgid "Item might be a number"
msgstr ""

#: src/compiler/seqtran.lisp
msgid "Specified output type ~S is not a sequence type"
msgstr ""

#: src/compiler/typetran.lisp
msgid ""
"Define-Type-Predicate Name Type\n"
"  Establish an association between the type predicate Name and the\n"
"  corresponding Type.  This causes the type predicate to be recognized for\n"
"  purposes of optimization."
msgstr ""

#: src/compiler/typetran.lisp
msgid "Can't open-code test of non-constant type."
msgstr ""

#: src/compiler/typetran.lisp
msgid "Can't open-code test of unknown type ~S."
msgstr ""

#: src/compiler/typetran.lisp
msgid "Can't compile TYPEP of anonymous or undefined ~\n"
"			class:~%  ~S"
msgstr ""

#: src/compiler/typetran.lisp
msgid "Illegal type specifier for Typep: ~S."
msgstr ""

#: src/compiler/float-tran.lisp
msgid "use inline fixnum operations"
msgstr ""

#: src/compiler/float-tran.lisp
msgid "use inline (unsigned-byte 32) operations"
msgstr ""

#: src/compiler/float-tran.lisp
msgid "Shouldn't happen"
msgstr ""

#: src/compiler/float-tran.lisp
msgid "Can't open-code float to rational comparison."
msgstr ""

#: src/compiler/float-tran.lisp
msgid "~S doesn't have a precise float representation."
msgstr ""

#: src/compiler/float-tran.lisp
msgid ""
"Unable to avoid inline argument range check~@\n"
"                      because the argument range (~s) was not within 2^~D"
msgstr ""

#: src/compiler/float-tran.lisp
msgid ""
"Unable to avoid inline argument range check~@\n"
"                   because the argument range (~s) was not within 2^~D"
msgstr ""

#: src/compiler/float-tran.lisp
msgid "Float zero bound ~s not correctly canonicalised?"
msgstr ""

#: src/compiler/float-tran-dd.lisp
msgid "Compute fl(a*b) and err(a*b)"
msgstr ""

#: src/compiler/float-tran-dd.lisp
msgid ""
"Compute fl(a*a) and err(a*b).  This is a more efficient\n"
"  implementation of two-prod"
msgstr ""

#: src/compiler/float-tran-dd.lisp
msgid "Computes fl(a+b) and err(a+b), assuming |a| >= |b|"
msgstr ""

#: src/compiler/float-tran-dd.lisp
msgid "Computes fl(a+b) and err(a+b)"
msgstr ""

#: src/compiler/float-tran-dd.lisp
msgid "Add the double-double A0,A1 to the double-double B0,B1"
msgstr ""

#: src/compiler/float-tran-dd.lisp
msgid "Compute fl(a-b) and err(a-b), assuming |a| >= |b|"
msgstr ""

#: src/compiler/float-tran-dd.lisp
msgid "Compute fl(a-b) and err(a-b)"
msgstr ""

#: src/compiler/float-tran-dd.lisp
msgid "Subtract the double-double B0,B1 from A0,A1"
msgstr ""

#: src/compiler/float-tran-dd.lisp
msgid "Compute double-double = double - double-double"
msgstr ""

#: src/compiler/float-tran-dd.lisp
msgid "Subtract the double B from the double-double A0,A1"
msgstr ""

#: src/compiler/float-tran-dd.lisp
msgid ""
"Split the double-float number a into a-hi and a-lo such that a =\n"
"  a-hi + a-lo and a-hi contains the upper 26 significant bits of a and\n"
"  a-lo contains the lower 26 bits."
msgstr ""

#: src/compiler/float-tran-dd.lisp
msgid "Multiply the double-double A0,A1 with B0,B1"
msgstr ""

#: src/compiler/float-tran-dd.lisp
msgid "Add the double-double A0,A1 to the double B"
msgstr ""

#: src/compiler/float-tran-dd.lisp
msgid "Divide the double-double A0,A1 by B0,B1"
msgstr ""

#: src/compiler/float-tran-dd.lisp
msgid "Square"
msgstr ""

#: src/compiler/saptran.lisp
msgid "FOREIGN-SYMBOL-ADDRESS flavor ~S is not :CODE or :DATA"
msgstr ""

#: src/compiler/srctran.lisp
msgid "Function doesn't have fixed argument count."
msgstr ""

#: src/compiler/srctran.lisp
msgid "Unknown bound type in make-interval!"
msgstr ""

#: src/compiler/srctran.lisp
msgid "This shouldn't happen!"
msgstr ""

#: src/compiler/srctran.lisp
msgid "BOOLE code is not a constant."
msgstr ""

#: src/compiler/srctran.lisp
msgid "~S illegal control arg to BOOLE."
msgstr ""

#: src/compiler/srctran.lisp
msgid "Unexpected types: ~s ~s~%"
msgstr ""

#: src/compiler/srctran.lisp
msgid "Operands might not be the same type."
msgstr ""

#: src/compiler/srctran.lisp
msgid "~s: too few args (~d), need at least ~d"
msgstr ""

#: src/compiler/srctran.lisp
msgid "~s: too many args (~d), wants at most ~d"
msgstr ""

#: src/compiler/srctran.lisp
msgid "Control string is not a constant."
msgstr ""

#: src/compiler/srctran.lisp
msgid ""
"When non-NIL, the compiler will generate code utilizing modular\n"
"  arithmetic.  Set to NIL to disable this, if you don't want modular\n"
"  arithmetic in some cases."
msgstr ""

#: src/compiler/locall.lisp
msgid ""
"Couldn't inline expand because expansion ~\n"
"				   calls this let-converted local function:~\n"
"				   ~%  ~S"
msgstr ""

#: src/compiler/locall.lisp
msgid "Function called with ~R argument~:P, but wants exactly ~R."
msgstr ""

#: src/compiler/locall.lisp
msgid "Function called with ~R argument~:P, but wants at least ~R."
msgstr ""

#: src/compiler/locall.lisp
msgid "Function called with ~R argument~:P, but wants at most ~R."
msgstr ""

#: src/compiler/locall.lisp
msgid "Can't local-call functions with &MORE args."
msgstr ""

#: src/compiler/locall.lisp
msgid ""
"Function called with odd number of ~\n"
"	  		     arguments in keyword portion."
msgstr ""

#: src/compiler/locall.lisp
msgid "Non-constant keyword in keyword call."
msgstr ""

#: src/compiler/locall.lisp
msgid "non-constant :ALLOW-OTHER-KEYS value"
msgstr ""

#: src/compiler/locall.lisp
msgid "Function called with unknown argument keyword ~S."
msgstr ""

#: src/compiler/dfo.lisp
msgid "Top-Level Form"
msgstr ""

#: src/compiler/checkgen.lisp
msgid "~:[This~;~:*~A~] is not a ~<~%~9T~:;~S:~>~%  ~S"
msgstr ""

#: src/compiler/checkgen.lisp
msgid "~:[Result~;~:*~A~] is a ~S, ~<~%~9T~:;not a ~S.~>"
msgstr ""

#: src/compiler/checkgen.lisp
msgid "~:[A possible~;The~] binding of ~S"
msgstr ""

#: src/compiler/checkgen.lisp
msgid "Type assertion too complex to check:~% ~S."
msgstr ""

#: src/compiler/constraint.lisp
msgid "*** Unreachable code in constraint ~\n"
"			  propagation...  Bug?"
msgstr ""

#: src/compiler/tn.lisp
msgid ""
"Do-Packed-TNs (TN-Var Component [Result]) Declaration* Form*\n"
"  Iterate over all packed TNs allocated in Component."
msgstr ""

#: src/compiler/tn.lisp
msgid "SC ~S has no :unbounded :save-p NIL alternate SC."
msgstr ""

#: src/compiler/life.lisp
msgid "More operand ~S used more than once in its VOP."
msgstr ""

#: src/compiler/debug-dump.lisp
msgid ""
"Extract the namestring from FILE-INFO for the DEBUG-SOURCE.  \n"
"Return FILE-INFO's untruename (e.g., target:foo) if it is absolute;\n"
"otherwise the truename."
msgstr ""

#: src/compiler/generic/utils.lisp
msgid "Make a fixnum out of NUM.  (i.e. shift by two bits if it will fit.)"
msgstr ""

#: src/compiler/generic/utils.lisp
msgid "~D is too big for a fixnum."
msgstr ""

#: src/compiler/generic/utils.lisp
msgid "Returns the byte offset of the static symbol Symbol."
msgstr ""

#: src/compiler/generic/utils.lisp
msgid "~S is not a static symbol."
msgstr ""

#: src/compiler/generic/utils.lisp
msgid "Given a byte offset, Offset, returns the appropriate static symbol."
msgstr ""

#: src/compiler/generic/utils.lisp
msgid "Byte offset, ~D, is not correct."
msgstr ""

#: src/compiler/generic/utils.lisp
msgid ""
"Return the (byte) offset from NIL to the start of the fdefn object\n"
"   for the static function NAME."
msgstr ""

#: src/compiler/generic/utils.lisp
msgid "~S isn't a static function."
msgstr ""

#: src/compiler/generic/utils.lisp
msgid ""
"Given a byte offset, Offset, returns the appropriate static function\n"
"   symbol."
msgstr ""

#: src/compiler/generic/primtype.lisp
msgid ""
"An a-list for mapping simple array element types to their\n"
"  corresponding primitive types."
msgstr ""

#: src/compiler/aliencomp.lisp
msgid "Slot is not constant, so cannot open code access."
msgstr ""

#: src/compiler/aliencomp.lisp
msgid "~S doesn't have a slot named ~S"
msgstr ""

#: src/compiler/aliencomp.lisp
msgid "Too many indices for pointer deref: ~D"
msgstr ""

#: src/compiler/aliencomp.lisp
msgid "Unknown element size."
msgstr ""

#: src/compiler/aliencomp.lisp
msgid "Unknown element alignment."
msgstr ""

#: src/compiler/aliencomp.lisp
msgid "Incorrect number of indices."
msgstr ""

#: src/compiler/aliencomp.lisp
msgid "Element size unknown."
msgstr ""

#: src/compiler/aliencomp.lisp
msgid "Element alignment unknown."
msgstr ""

#: src/compiler/aliencomp.lisp
msgid "~S not either a pointer or array type."
msgstr ""

#: src/compiler/aliencomp.lisp
msgid "Info not constant; can't open code."
msgstr ""

#: src/compiler/aliencomp.lisp
msgid "Aliens of type ~S cannot be represented immediately."
msgstr ""

#: src/compiler/aliencomp.lisp
msgid "Local Alien Info isn't constant?"
msgstr ""

#: src/compiler/aliencomp.lisp
msgid "This shouldn't happen."
msgstr ""

#: src/compiler/aliencomp.lisp
msgid "Alien type not constant; cannot open code."
msgstr ""

#: src/compiler/aliencomp.lisp
msgid ""
"Could not optimize away %SAP-ALIEN: forced to do runtime ~@\n"
"	    allocation of alien-value structure."
msgstr ""

#: src/compiler/aliencomp.lisp
msgid "Type not constant at compile time; can't open code."
msgstr ""

#: src/compiler/aliencomp.lisp
msgid "Can't tell function type at compile time."
msgstr ""

#: src/compiler/aliencomp.lisp
msgid "Wrong number of arguments.  Expected ~D, got ~D."
msgstr ""

#: src/compiler/aliencomp.lisp
msgid "Something is broken."
msgstr ""

#: src/compiler/aliencomp.lisp
msgid "No unique move-arg-vop for moves in SC ~S."
msgstr ""

#: src/compiler/ltv.lisp
msgid "(during EVAL of LOAD-TIME-VALUE)~%~A"
msgstr ""

#: src/compiler/ltv.lisp
msgid ""
"Arrange for FORM to be evaluated at load-time and use the value produced\n"
"   as if it were a constant.  If READ-ONLY-P is non-NIL, then the resultant\n"
"   object is guaranteed to never be modified, so it can be put in read-only\n"
"   storage."
msgstr ""

#: src/compiler/gtn.lisp
msgid ""
"Return value count mismatch prevents known return ~\n"
"		       from these functions:~\n"
"		       ~{~%  ~A~}"
msgstr ""

#: src/compiler/gtn.lisp
msgid ""
"Return type not fixed values, so can't use known return ~\n"
"		      convention:~%  ~S"
msgstr ""

#: src/compiler/ltn.lisp
msgid ""
"Unable to check type assertion in unknown-values ~\n"
"	                context:~% ~S"
msgstr ""

#: src/compiler/represent.lisp src/compiler/ir2tran.lisp src/compiler/ltn.lisp
msgid "Neither CONT nor TN supplied."
msgstr ""

#: src/compiler/ltn.lisp
msgid "~S has :MORE results with :TRANSLATE."
msgstr ""

#: src/compiler/ltn.lisp
msgid ""
"This is the maximum number of possible optimization alternatives will be\n"
"  mentioned in a particular efficiency note.  NIL means no limit."
msgstr ""

#: src/compiler/ltn.lisp
msgid ""
"This is the minumum cost difference between the chosen implementation and\n"
"  the next alternative that justifies an efficiency note."
msgstr ""

#: src/compiler/ltn.lisp
msgid "This shouldn't happen!  Bug?"
msgstr ""

#: src/compiler/ltn.lisp
msgid "Template guard failed."
msgstr ""

#: src/compiler/ltn.lisp
msgid "Template is not safe, yet we were counting on it."
msgstr ""

#: src/compiler/ltn.lisp
msgid "Argument types invalid."
msgstr ""

#: src/compiler/ltn.lisp
msgid "Argument primitive types:~%  ~S"
msgstr ""

#: src/compiler/ltn.lisp
msgid "Argument type assertions:~%  ~S"
msgstr ""

#: src/compiler/ltn.lisp
msgid "Conditional in a non-conditional context."
msgstr ""

#: src/compiler/ltn.lisp
msgid "Result types invalid."
msgstr ""

#: src/compiler/ltn.lisp
msgid "etc."
msgstr ""

#: src/compiler/ltn.lisp
msgid "Unable to do ~A (cost ~D) because:"
msgstr ""

#: src/compiler/ltn.lisp
msgid "Can't trust output type assertion under safe ~\n"
"		       policy."
msgstr ""

#: src/compiler/ltn.lisp
msgid "Forced to do ~A (cost ~D)."
msgstr ""

#: src/compiler/ltn.lisp
msgid "Forced to do full call."
msgstr ""

#: src/compiler/ltn.lisp
msgid "Recursive known function definition."
msgstr ""

#: src/compiler/ir2tran.lisp
msgid ""
"Always perform stack clearing if non-NIL, independent of the\n"
"compilation policy"
msgstr ""

#: src/compiler/ir2tran.lisp
msgid ""
"If non-NIL and the compilation policy allows, stack clearing is enabled."
msgstr ""

#: src/compiler/ir2tran.lisp
msgid "~@<~2I~_~S ~_not found in ~_~S~:>"
msgstr ""

#: src/compiler/represent.lisp
msgid "Couldn't find REF?"
msgstr ""

#: src/compiler/represent.lisp
msgid ""
"Representation selection flamed out for no obvious reason.~@\n"
"	          Try again after recompiling the VM definition."
msgstr ""

#: src/compiler/represent.lisp
msgid ""
"~S is not valid as the ~:R ~:[result~;argument~] to the~@\n"
"	        ~S VOP, since the TN's primitive type ~S allows SCs:~%  ~S~@\n"
"		~:[which cannot be coerced or loaded into the allowed SCs:~\n"
"		~%  ~S~;~*~]~:[~;~@\n"
"		Current cost info inconsistent with that in effect at compile ~\n"
"		time.  Recompile.~%Compilation order may be incorrect.~]"
msgstr ""

#: src/compiler/represent.lisp
msgid ""
"Representation selection flamed out for no ~\n"
"		             obvious reason."
msgstr ""

#: src/compiler/represent.lisp
msgid ""
"~S is not valid as the ~:R ~:[result~;argument~] to VOP:~\n"
"	        ~%  ~S~%Primitive type: ~S~@\n"
"		SC restrictions:~%  ~S~@\n"
"		~@[The primitive type disallows these loadable SCs:~%  ~S~%~]~\n"
"		~@[No move VOPs are defined to coerce to these allowed SCs:~\n"
"		~%  ~S~%~]~\n"
"		~@[These move VOPs couldn't be used due to operand type ~\n"
"		restrictions:~%  ~S~%~]~\n"
"		~:[~;~@\n"
"		Current cost info inconsistent with that in effect at compile ~\n"
"		time.  Recompile.~%Compilation order may be incorrect.~]"
msgstr ""

#: src/compiler/represent.lisp
msgid ""
"No :MOVE-ARGUMENT VOP defined to move ~S (SC ~S) to ~\n"
"          ~S (SC ~S.)"
msgstr ""

#: src/compiler/represent.lisp
msgid ""
"No move function defined to load SC ~S from constant ~\n"
"	             SC ~S."
msgstr ""

#: src/compiler/represent.lisp
msgid ""
"No move function defined to load SC ~S from alternate ~\n"
"	             SC ~S."
msgstr ""

#: src/compiler/represent.lisp
msgid ""
"No move function defined to save SC ~S to alternate ~\n"
"	             SC ~S."
msgstr ""

#: src/compiler/represent.lisp
msgid "<return value>"
msgstr ""

#: src/compiler/represent.lisp
msgid ""
"Doing ~A (cost ~D)~:[~2*~; ~:[to~;from~] ~S~], for:~%~6T~\n"
"	       The ~:R ~:[result~;argument~] of ~A."
msgstr ""

#: src/compiler/represent.lisp
msgid "Doing ~A (cost ~D)~@[ from ~S~]~@[ to ~S~]."
msgstr ""

#: src/compiler/represent.lisp
msgid "Couldn't fine op?  Bug!"
msgstr ""

#: src/compiler/codegen.lisp
msgid "Returns the number of bytes used by the code object header."
msgstr ""

#: src/compiler/codegen.lisp
msgid ""
"The size of the Name'd SB in the currently compiled component.  Useful\n"
"  mainly for finding the size for allocating stack frames."
msgstr ""

#: src/compiler/codegen.lisp
msgid ""
"Return the TN that is used to hold the number stack frame-pointer in VOP's\n"
"  function.  Returns NIL if no number stack frame was allocated."
msgstr ""

#: src/compiler/codegen.lisp
msgid ""
"Return the TN that is used to hold the number stack frame-pointer in the\n"
"  function designated by 2env.  Returns NIL if no number stack frame was\n"
"  allocated."
msgstr ""

#: src/compiler/codegen.lisp
msgid ""
"Return the TN used for passing the return PC in a local call to the function"
"\n"
"  designated by 2env."
msgstr ""

#: src/compiler/codegen.lisp
msgid ""
"Set to NIL to inhibit assembly-level optimization.  For compiler debugging,\n"
"  rather than policy control."
msgstr ""

#: src/compiler/codegen.lisp
msgid "In the ~A segment:~%"
msgstr ""

#: src/compiler/codegen.lisp
msgid "~|~%Assembly code for ~S~2%"
msgstr ""

#: src/compiler/codegen.lisp
msgid "Missing generator for ~S.~%"
msgstr ""

#: src/compiler/debug.lisp
msgid ""
"This variable is bound to the format arguments when an error is signalled\n"
"  by Barf or Burp."
msgstr ""

#: src/compiler/debug.lisp
msgid ""
"Action taken by the Burp function when a possible compiler bug is detected.\n"
"  One of :Warn, :Error or :None."
msgstr ""

#: src/compiler/debug.lisp
msgid ""
"Return a list of a the TNs that conflict with TN.  Sort of, kind of.  For\n"
"  debugging use only.  Probably doesn't work on :COMPONENT TNs."
msgstr ""

#: src/compiler/debug.lisp
msgid "Return the Nth VOP in the IR2-Block pointed to by Thing."
msgstr ""

#: src/compiler/xref.lisp
msgid "Reinitialize the cross-reference database."
msgstr ""

#: src/compiler/xref.lisp
msgid ""
"Return a list of those program contexts where a globally-defined\n"
"function may be called at runtime."
msgstr ""

#: src/compiler/xref.lisp
msgid ""
"Return a list of those program contexts where GLOBAL-VARIABLE\n"
"may be referenced at runtime."
msgstr ""

#: src/compiler/xref.lisp
msgid ""
"Return a list of those program contexts where GLOBAL-VARIABLE may\n"
"be bound at runtime."
msgstr ""

#: src/compiler/xref.lisp
msgid ""
"Return a list of those program contexts where GLOBAL-VARIABLE may\n"
"be set at runtime."
msgstr ""

#: src/compiler/dyncount.lisp
msgid ""
"When T, emit extra code to collect dynamic statistics about vop usages."
msgstr ""

#: src/compiler/dyncount.lisp
msgid "Holds the TN for the counts vector."
msgstr ""

#: src/compiler/dump.lisp
msgid "Compiler bug: ~S not a legal fasload operator."
msgstr ""

#: src/compiler/dump.lisp
msgid "Tried to output ~D bytes, but only ~D made it."
msgstr ""

#: src/compiler/dump.lisp
msgid "This object cannot be dumped into a fasl file:~% ~S"
msgstr ""

#: src/compiler/dump.lisp
msgid "~S already dumped?"
msgstr ""

#: src/compiler/dump.lisp
msgid "Attempt to dump invalid structure:~%  ~S~%How did this happen?"
msgstr ""

#: src/compiler/dump.lisp
msgid "Dumping reference to obsolete class: ~S"
msgstr ""

#: src/compiler/generic/core.lisp
msgid "Unknown foreign symbol: ~S"
msgstr ""

#: src/compiler/generic/core.lisp
msgid "Unresolved forward reference."
msgstr ""

#: src/compiler/generic/core.lisp
msgid "#<Code Instruction Stream for ~S>"
msgstr ""

#: src/compiler/generic/core.lisp
msgid "Writing ~D bytes to ~S would cause it to overflow."
msgstr ""

#: src/compiler/generic/core.lisp
msgid "Writing another byte to ~S would cause it to overflow."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid "Rounds number up to be an integral multiple of size."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid "Handle on Nil."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid "Number of bits in the low half of the descriptor"
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid ""
"Alignment requirement for spaces in the target.\n"
"  Must be at least (ash 1 descriptor-low-bits"
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid ""
"Return a descriptor for a block of LENGTH bytes out of SPACE.  The free\n"
"  pointer is boosted as necessary.  If any additional memory is needed, we\n"
"  vm_allocate it.  The descriptor returned is a pointer of type LOWTAG."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid "Return the lowtag bits for DES."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid "Return the bits of DES."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid ""
"Return a SAP pointing to the piece of memory DES refers to.  The lowtag\n"
"  bits of DES are ignored."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid "Handle on the trap object."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid "Head of list of functions to be called when the Lisp starts up."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid "Used by normal loader."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid ""
"Write VALUE (a descriptor) INDEX words from ADDRESS (also a descriptor)."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid "Write VALUE (a descriptor) at ADDRESS (also a descriptor)."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid ""
"Return the value (as a descriptor) INDEX words from ADDRESS (a descriptor)."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid "Return the value at ADDRESS (a descriptor)."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid ""
"Allocate LENGTH words in SPACE and return a new descriptor of type LOWTAG\n"
"  pointing to them."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid ""
"Allocate LENGTH units of ELEMENT-SIZE bits plus a header word in SPACE and\n"
"  return an ``other-pointer'' descriptor to them.  Initialize the header "
"word\n"
"  with the resultant length and TYPE."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid ""
"Allocate LENGTH units of ELEMENT-SIZE plus a header plus a length slot in\n"
"  SPACE and return an ``other-pointer'' descriptor to them.  Initialize the\n"
"  header word with TYPE and the length slot with LENGTH."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid "Copy string into the CORE and return a descriptor to it."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid "Copy the bignum to the core."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid "Makes a number pair of TYPE (ratio or complex) and fills it in."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid ""
"Copy the given number to the core, or flame out if we can't deal with it."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid "Allocate a cons cell in SPACE and fill it in with CAR and CDR."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid "Generates code to push the THING onto the given cold load LIST."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid "Initializes the cold load symbol-hacking data structures."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid "FOP functions for cold loading."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid "Loads the file named by FileName into the cold load image being built."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid ""
"Return the version number from the symbol table file Filename.\n"
"  Value is 0 if Filename is null or the file doesn't exist."
msgstr ""

#: src/compiler/generic/new-genesis.lisp
msgid ""
"Builds a kernel Lisp image from the .FASL files specified in the given\n"
"  File-List and writes it to a file named by Core-Name."
msgstr ""

#: src/compiler/eval-comp.lisp
msgid "Fatal error, aborting evaluation."
msgstr ""

#: src/compiler/eval-comp.lisp
msgid "Wrong argument count, wanted ~D and got ~D."
msgstr ""

#: src/compiler/eval-comp.lisp
msgid "Wrong number of arguments passed -- ~S."
msgstr ""

#: src/compiler/eval-comp.lisp
msgid "Function called with odd number of keyword arguments."
msgstr ""

#: src/compiler/eval-comp.lisp
msgid "Unknown keyword argument -- ~S."
msgstr ""

#: src/compiler/eval.lisp
msgid "[PUSH: growing stack.]~%"
msgstr ""

#: src/compiler/eval.lisp
msgid "pushing ~D.~%"
msgstr ""

#: src/compiler/eval.lisp
msgid "Attempt to pop empty eval stack."
msgstr ""

#: src/compiler/eval.lisp
msgid "popping ~D --> ~S.~%"
msgstr ""

#: src/compiler/eval.lisp
msgid "[EXTEND: growing stack.]~%"
msgstr ""

#: src/compiler/eval.lisp
msgid "extending to ~D.~%"
msgstr ""

#: src/compiler/eval.lisp
msgid "shrinking to ~D.~%"
msgstr ""

#: src/compiler/eval.lisp
msgid "setting top to ~D.~%"
msgstr ""

#: src/compiler/eval.lisp
msgid ""
"If the interpreted function cache has more functions than this come GC time,"
"\n"
"  then attempt to prune it according to\n"
"  *INTERPRETED-FUNCTION-CACHE-THRESHOLD*."
msgstr ""

#: src/compiler/eval.lisp
msgid ""
"If an interpreted function goes uncalled for more than this many GCs, then\n"
"  it is eligible for flushing from the cache."
msgstr ""

#: src/compiler/eval.lisp
msgid ""
"Clear all entries in the eval function cache.  This allows the internal\n"
"  representation of the functions to be reclaimed, and also lazily forces\n"
"  macroexpansions to be recomputed."
msgstr ""

#: src/compiler/eval.lisp
msgid "C::%UNKNOWN-VALUES should never be in interpreter's IR1."
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "Unknown XOP ~S"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "Unknown inline function: ~S"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "Can't find ~S"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "~|~%;;;; Byte component ~S~2%"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid ";;; Functions:~%"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "~%;;;Disassembly:~2%"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "<bogus index>"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "Entry point, frame-size=~D~%"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "push-local ~D"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "push-arg ~D"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "push-const ~S"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "push-sys-const ~S"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "push-int ~D"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "push-neg-int ~D"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "pop-local ~D"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "pop-n ~D"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "~:[~;named-~]call, ~D args"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "~:[~;named-~]tail-call, ~D args"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "~:[~;named-~]multiple-call, ~D args"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "local call ~D, ~D args"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "local tail-call ~D, ~D args"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "local multiple-call ~D, ~D args"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "return, ~D vals"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "branch ~D"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "if-true ~D"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "if-false ~D"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "if-eq ~D"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "xop ~A~@[ ~D~]"
msgstr ""

#: src/compiler/byte-comp.lisp
msgid "inline ~A"
msgstr ""

#: src/pcl/init.lisp src/pcl/defclass.lisp src/pcl/macros.lisp
msgid "Malformed plist in doplist, odd number of elements."
msgstr ""

#: src/pcl/macros.lisp
msgid "~@<~S is not a legal class name.~@:>"
msgstr ""

#: src/pcl/macros.lisp
msgid "No class named ~S."
msgstr ""

#: src/pcl/macros.lisp
msgid "~S is not a legal class name."
msgstr ""

#: src/pcl/macros.lisp
msgid ""
"Returns the PCL class metaobject named by SYMBOL. An error of type\n"
"   SIMPLE-ERROR is signaled if the class does not exist unless ERRORP\n"
"   is NIL in which case NIL is returned. SYMBOL cannot be a keyword."
msgstr ""

#: src/pcl/low.lisp
msgid "Set the name of a compiled function object and return the function."
msgstr ""

#: src/pcl/low.lisp
msgid ""
"PCL debugging aid that breaks into the debugger each time\n"
"`compile-lambda' is invoked."
msgstr ""

#: src/pcl/low.lisp
msgid ""
"If true (the default), then `compile-lambda' will try to silence\n"
"the compiler as completely as possible.  Currently this means that\n"
"`*compile-print*' will be bound to nil during compilation."
msgstr ""

#: src/pcl/info.lisp
msgid ""
"~@<The declaration ~S is not understood by ~S. ~\n"
"                               Please put ~S on one of the lists ~S, ~S, or "
"~S. ~\n"
"                               (Assuming it is a variable declarations "
"without ~\n"
"                               argument).~@:>"
msgstr ""

#: src/pcl/info.lisp
msgid "~@<Invalid slot access specifier ~s in ~s.~@:>"
msgstr ""

#: src/pcl/info.lisp
msgid "~@<Invalid slot access declaration ~s.~@:>"
msgstr ""

#: src/pcl/info.lisp
msgid "~@<Invalid auto-compile specifier ~s in ~s.~@:>"
msgstr ""

#: src/pcl/info.lisp
msgid "~@<Invalid auto-compile declaration ~s.~@:>"
msgstr ""

#: src/pcl/fin.lisp
msgid ""
"~@<Attempt to funcall a funcallable instance without first ~\n"
"          setting its function.~@:>"
msgstr ""

#: src/pcl/defclass.lisp
msgid "Defclass already names a declaration: ~S."
msgstr ""

#: src/pcl/defclass.lisp
msgid "~S is not a legal defclass option."
msgstr ""

#: src/pcl/defclass.lisp
msgid ""
"~@<The value of the ~s option (~s) is not a legal ~\n"
"	        class name.~@:>"
msgstr ""

#: src/pcl/defclass.lisp
msgid "~@<~S is not a legal slot specification.~@:>"
msgstr ""

#: src/pcl/defclass.lisp
msgid ""
"~@<In the class definintion of ~s, the slot specification ~s ~\n"
"                 is obsolete.  Convert it to ~s.~@:>"
msgstr ""

#: src/pcl/defclass.lisp
msgid "~@<~S is not a class in *early-class-definitions*.~@:>"
msgstr ""

#: src/pcl/defclass.lisp
msgid ""
"~@<More than one early class defines a slot with the ~\n"
"                    name ~S.  This can't work because the bootstrap ~\n"
"                    object system doesn't know how to compute effective ~\n"
"                    slots.~@:>"
msgstr ""

#: src/pcl/defclass.lisp
msgid "Discard it."
msgstr ""

#: src/pcl/defclass.lisp
msgid ""
"~@<The defclass option ~S is not supported by ~\n"
"                                 the bootstrap object system.~@:>"
msgstr ""

#: src/pcl/defclass.lisp
msgid "Slot ~S not found in class ~S"
msgstr ""

#: src/pcl/defs.lisp
msgid ""
"~@<Trying to load (or compile) PCL in an environment in which it ~\n"
"            has already been loaded.  This doesn't work, you will have to ~\n"
"            get a fresh lisp (reboot) and then load PCL.~@:>"
msgstr ""

#: src/pcl/defs.lisp
msgid "Try loading (or compiling) PCL anyways."
msgstr ""

#: src/pcl/defs.lisp
msgid "Obsolete, don't use."
msgstr ""

#: src/pcl/defs.lisp
msgid "~@<~S is not a legal specializer type.~@:>"
msgstr ""

#: src/pcl/defs.lisp
msgid "~@<~s is neither a type nor a specializer.~@:>"
msgstr ""

#: src/pcl/defs.lisp
msgid "Bad argument to type-class."
msgstr ""

#: src/pcl/defs.lisp
msgid "~s is not a type."
msgstr ""

#: src/pcl/defs.lisp
msgid ""
"For class slots, the class defininig the slot.\n"
"For inherited class slots, this is the superclass from which the slot\n"
"was inherited."
msgstr ""

#: src/pcl/fngen.lisp
msgid ""
"Flush cached emf functions.  If GF is supplied, it should be a\n"
"   generic function metaobject or the name of a generic function, and\n"
"   this function flushes all cached emfs for the given generic\n"
"   function.  If GF is not supplied, all cached emfs are flushed."
msgstr ""

#: src/pcl/cache.lisp
msgid "Wrapper ~S"
msgstr ""

#: src/pcl/cache.lisp
msgid "Unknown wrapper state"
msgstr ""

#: src/pcl/cache.lisp
msgid ""
"~@<PCL cannot handle the specializer ~S ~\n"
"                                (meta-specializer ~S).~@:>"
msgstr ""

#: src/pcl/cache.lisp
msgid "Line is reserved."
msgstr ""

#: src/pcl/cache.lisp
msgid ""
"~@<Bad cache ~S: Value at location ~D is ~D ~\n"
"                               lines from its home, limit is ~D.~@:>"
msgstr ""

#: src/pcl/cache.lisp
msgid "Attempt to fill a reserved cache line."
msgstr ""

#: src/pcl/cache.lisp
msgid "Transfering something into a reserved cache line."
msgstr ""

#: src/pcl/dlisp.lisp
msgid "Every metatype is T."
msgstr ""

#: src/pcl/dlisp.lisp
msgid "Can't do a slot reg for this metatype."
msgstr ""

#: src/pcl/boot.lisp
msgid "~~@<Generic function ~a: ~?.~~@:>"
msgstr ""

#: src/pcl/boot.lisp
msgid "Invalid generic function parameter name ~a"
msgstr ""

#: src/pcl/boot.lisp
msgid ""
"Optional and key parameters of generic functions ~\n"
"                   may not have default values or supplied-p ~\n"
"                   parameters: ~<~s~>"
msgstr ""

#: src/pcl/boot.lisp
msgid "~s is not allowed in generic function lambda lists"
msgstr ""

#: src/pcl/boot.lisp
msgid "~~@<Generic function ~~s: ~?.~~@:>"
msgstr ""

#: src/pcl/boot.lisp
msgid "The option ~s appears more than once"
msgstr ""

#: src/pcl/boot.lisp
msgid "Declaration specifier ~s is not allowed"
msgstr ""

#: src/pcl/boot.lisp
msgid ""
"Argument precedence order must list all ~\n"
"                           required parameters and only those: ~s"
msgstr ""

#: src/pcl/boot.lisp
msgid ""
"Duplicate parameter names in argument ~\n"
"                           precedence order: ~s"
msgstr ""

#: src/pcl/boot.lisp
msgid "Special operators cannot be made generic functions"
msgstr ""

#: src/pcl/boot.lisp
msgid "Unsupported option ~s"
msgstr ""

#: src/pcl/boot.lisp
msgid "If true, allow inlining of methods in effective methods."
msgstr ""

#: src/pcl/boot.lisp
msgid ""
"~@<Defining method ~s ~s ~s using inline slot access in a ~\n"
"                   non-null lexical environment means that it cannot be ~\n"
"                   automatically recompiled.~@:>"
msgstr ""

#: src/pcl/boot.lisp
msgid ""
"The method-lambda argument to make-method-function, ~S,~\n"
"            is not a lambda form"
msgstr ""

#: src/pcl/boot.lisp
msgid "~@<The ~s argument to ~s, ~s, is not a lambda form.~@:>"
msgstr ""

#: src/pcl/boot.lisp
msgid ""
"Assignment to method parameter~p ~{~s~^, ~} ~\n"
"                           might prevent CLOS optimizations"
msgstr ""

#: src/pcl/boot.lisp
msgid "Wrong number of args."
msgstr ""

#: src/pcl/boot.lisp
msgid "1 or 2 args expected."
msgstr ""

#: src/pcl/boot.lisp
msgid "1 arg expected."
msgstr ""

#: src/pcl/boot.lisp
msgid ""
"~@<The set of methods ~s applicable to argument~p ~\n"
"                ~{~s~^, ~} to call-next-method is different from ~\n"
"                the set of methods ~s applicable to the original ~\n"
"                method argument~p ~{~s~^, ~}.~@:>"
msgstr ""

#: src/pcl/boot.lisp
msgid "When true, compile interpreted method functions."
msgstr ""

#: src/pcl/boot.lisp
msgid ""
"~&~@<At the time the method with qualifiers ~S and ~\n"
"               specializers ~S on the generic function ~S ~\n"
"               was compiled, the method class for that generic function was "
"~\n"
"               ~S.  But, the method class is now ~S, this ~\n"
"               may mean that this method was compiled improperly.~@:>"
msgstr ""

#: src/pcl/boot.lisp
msgid ""
"~@<~S already names an ordinary function or a macro.  ~\n"
"	If you want to replace it with a generic function, you should remove ~\n"
"        the existing definition beforehand.~@:>"
msgstr ""

#: src/pcl/boot.lisp
msgid "~@<Discard the existing definition of ~S.~@:>"
msgstr ""

#: src/pcl/boot.lisp
msgid ""
"~@<The lambda-list ~S is incompatible with ~\n"
"                      existing methods of ~S.~@:>"
msgstr ""

#: src/pcl/boot.lisp
msgid ""
"~~@<Attempt to add the method ~~S to the generic ~\n"
"                           function ~~S, but ~?.~~@:>"
msgstr ""

#: src/pcl/boot.lisp
msgid "more"
msgstr ""

#: src/pcl/boot.lisp
msgid "fewer"
msgstr ""

#: src/pcl/boot.lisp
msgid ""
"the method has ~A required arguments than the ~\n"
"                 generic function"
msgstr ""

#: src/pcl/boot.lisp
msgid ""
"the method has ~S optional arguments than the ~\n"
"                 generic function"
msgstr ""

#: src/pcl/boot.lisp
msgid ""
"the method and generic function differ in whether ~\n"
"                 they accept rest or keyword arguments"
msgstr ""

#: src/pcl/boot.lisp
msgid ""
"the method does not accept each of the keyword ~\n"
"                   arguments ~S"
msgstr ""

#: src/pcl/boot.lisp
msgid "~@<The function ~S is not already defined.~@:>"
msgstr ""

#: src/pcl/boot.lisp
msgid "~@<~S should be on the list ~S.~@:>"
msgstr ""

#: src/pcl/boot.lisp
msgid ""
"~@<The function of the funcallable instance ~S ~\n"
"			 has not been set.~@:>"
msgstr ""

#: src/pcl/boot.lisp
msgid "~@<No way to determine the lambda list~@:>"
msgstr ""

#: src/pcl/boot.lisp
msgid ""
"~@<The ~s argument (~S) was neither a class nor a ~\n"
"                    symbol naming a class.~@:>"
msgstr ""

#: src/pcl/boot.lisp
msgid "~S is not an early-method."
msgstr ""

#: src/pcl/boot.lisp
msgid "Early add-method didn't get a funcallable instance."
msgstr ""

#: src/pcl/boot.lisp
msgid "Early add-method didn't get an early method."
msgstr ""

#: src/pcl/boot.lisp
msgid "Early remove-method didn't get a funcallable instance."
msgstr ""

#: src/pcl/boot.lisp
msgid "Early remove-method didn't get an early method."
msgstr ""

#: src/pcl/boot.lisp
msgid "Can't get early method."
msgstr ""

#: src/pcl/boot.lisp
msgid "~@<Qualifiers must be non-null atoms: ~s~@:>"
msgstr ""

#: src/pcl/boot.lisp
msgid ""
"~@<~S used as a specializer, ~\n"
"                             but is not the name of a class.~@:>"
msgstr ""

#: src/pcl/boot.lisp
msgid "~S is not a legal specializer."
msgstr ""

#: src/pcl/method-slot-access-optimization.lisp
msgid "Set to true to activate the inline slot access optimization."
msgstr ""

#: src/pcl/method-slot-access-optimization.lisp
msgid "When true, check slot values against specified slot types."
msgstr ""

#: src/pcl/method-slot-access-optimization.lisp
msgid "When true, optimize slot access through slot reader/writer functions."
msgstr ""

#: src/pcl/method-slot-access-optimization.lisp
msgid "Cannot optimize slot access to"
msgstr ""

#: src/pcl/method-slot-access-optimization.lisp
msgid "The class is not a standard class"
msgstr ""

#: src/pcl/method-slot-access-optimization.lisp
msgid "The class doesn't contain a slot with name ~s"
msgstr ""

#: src/pcl/method-slot-access-optimization.lisp
msgid "Slot ~s is a class slot"
msgstr ""

#: src/pcl/method-slot-access-optimization.lisp
msgid "There are non-standard accessors for slot ~s"
msgstr ""

#: src/pcl/method-slot-access-optimization.lisp
msgid ""
"Slot ~s is not at the same location ~\n"
"                               in the class and all of its subclasses"
msgstr ""

#: src/pcl/method-slot-access-optimization.lisp
msgid "Auto-compiling method ~s."
msgstr ""

#: src/pcl/method-slot-access-optimization.lisp
msgid ""
"Methods may need to be recompiled for the changed ~\n"
"                    class layout of"
msgstr ""

#: src/pcl/method-slot-access-optimization.lisp
msgid "The class is not defined at compile time"
msgstr ""

#: src/pcl/method-slot-access-optimization.lisp
msgid ""
"~s has a method that is not a standard ~\n"
"                                    slot accessor"
msgstr ""

#: src/pcl/method-slot-access-optimization.lisp
msgid "Methods of ~s access different slots"
msgstr ""

#: src/pcl/slots-boot.lisp
msgid "~@<~S is not a standard-class.~@:>"
msgstr ""

#: src/pcl/slots-boot.lisp
msgid ""
"~@<Slot ~S in class ~S ~\n"
"                       does not have standard allocation.~@:>"
msgstr ""

#: src/pcl/slots-boot.lisp
msgid ""
"~@<Slot ~S in class ~S ~\n"
"                      does not have standard allocation.~@:>"
msgstr ""

#: src/pcl/slots-boot.lisp
msgid ""
"~@<The wrapper for class ~S does not have ~\n"
"                               the slot ~S.~@:>"
msgstr ""

#: src/pcl/defcombin.lisp src/pcl/combin.lisp
msgid "has more than one qualifier"
msgstr ""

#: src/pcl/combin.lisp
msgid "has an invalid qualifier"
msgstr ""

#: src/pcl/combin.lisp
msgid ""
"~@<~s was called outside the dynamic scope ~\n"
"            of a method combination function (inside the body of ~\n"
"            ~s or a method on the generic function ~s).~@:>"
msgstr ""

#: src/pcl/combin.lisp
msgid "~@<~S used outside of a effective method form.~@:>"
msgstr ""

#: src/pcl/combin.lisp
msgid ""
"~@<Invalid keyword argument~p ~{~s~^, ~}.  ~\n"
"               Valid keywords are: ~{~s~^, ~}.~@:>"
msgstr ""

#: src/pcl/combin.lisp
msgid "Invalid keyword argument ~s"
msgstr ""

#: src/pcl/dfun.lisp
msgid "~@<Slot ~s of class ~s is unbound in object ~s~@:>"
msgstr ""

#: src/pcl/dfun.lisp
msgid ""
"~@<Cannot get standard value of slot ~s of class ~s ~\n"
"                in object ~s~@:>"
msgstr ""

#: src/pcl/dfun.lisp
msgid "~&Name ~S  caching cost ~D  dispatch cost ~D~%"
msgstr ""

#: src/pcl/dfun.lisp
msgid ""
"Precompute effective methods at method load time if the generic\n"
"   function has less than this number of methods.  If zero,\n"
"   no effective methods are precomputed at method load time."
msgstr ""

#: src/pcl/dfun.lisp
msgid "~@<The function ~S requires at least ~D arguments.~@:>"
msgstr ""

#: src/pcl/dfun.lisp
msgid "~<The function ~S requires at least ~D arguments.~@:>"
msgstr ""

#: src/pcl/dfun.lisp
msgid ""
"~@<Vicious metacircle:  The computation of an ~\n"
"	   effective method of ~s for arguments of types ~s uses ~\n"
"	   the effective method being computed.~@:>"
msgstr ""

#: src/pcl/dfun.lisp
msgid "This can't happen."
msgstr ""

#: src/pcl/dfun.lisp
msgid "~@<~s cannot handle the second argument ~s.~@:>"
msgstr ""

#: src/pcl/dfun.lisp
msgid "~&There are ~4d dfuns of type ~s"
msgstr ""

#: src/pcl/dfun.lisp
msgid "~&DFUN constructor caching is ~A."
msgstr ""

#: src/pcl/dfun.lisp
msgid "enabled"
msgstr ""

#: src/pcl/dfun.lisp
msgid "disabled"
msgstr ""

#: src/pcl/ctor.lisp
msgid "~@<Not a property list: ~S.~@:>"
msgstr ""

#: src/pcl/braid.lisp
msgid ""
"~@<The function of the funcallable instance ~S ~\n"
"                 has not been set.~@:>"
msgstr ""

#: src/pcl/braid.lisp
msgid ""
"~@<Slot allocation ~S is not supported ~\n"
"                          in bootstrap.~@:>"
msgstr ""

#: src/pcl/braid.lisp
msgid "The standard method combination."
msgstr ""

#: src/pcl/braid.lisp
msgid ""
"In *built-in-classes*: ~S has ~S as a superclass,~%~\n"
"                but ~S is not itself a class in *built-in-classes*."
msgstr ""

#: src/pcl/braid.lisp
msgid "~@<~S is not the name of a class.~@:>"
msgstr ""

#: src/pcl/braid.lisp
msgid ""
"~@<No matching method for the generic function ~\n"
"                             ~S, when called with arguments ~S.~@:>"
msgstr ""

#: src/pcl/braid.lisp
msgid "Retry call to ~S."
msgstr ""

#: src/pcl/braid.lisp
msgid "~@<In method ~S: No next method for arguments ~S.~@:>"
msgstr ""

#: src/pcl/braid.lisp
msgid ""
"~@<Generic function ~S: ~\n"
"                             No primary method given arguments ~S~@:>"
msgstr ""

#: src/pcl/braid.lisp
msgid ""
"~@<In a call to ~s with arguments ~:s: ~\n"
"              The method ~s has invalid qualifiers for method ~\n"
"              combination ~s.~@:>"
msgstr ""

#: src/pcl/braid.lisp
msgid ""
"~@<In a call to ~s with arguments ~:s: ~\n"
"              The methods ~{~s~^, ~} have invalid qualifiers for ~\n"
"              method combination ~s.~@:>"
msgstr ""

#: src/pcl/slots.lisp
msgid "~@<The slot ~S is unbound in the object ~S.~@:>"
msgstr ""

#: src/pcl/slots.lisp
msgid "is not a symbol and so cannot be bound"
msgstr ""

#: src/pcl/slots.lisp
msgid "is a keyword and so cannot be bound"
msgstr ""

#: src/pcl/slots.lisp
msgid "cannot be bound"
msgstr ""

#: src/pcl/slots.lisp
msgid "is a constant and so cannot be bound"
msgstr ""

#: src/pcl/slots.lisp
msgid ""
"~@<The slot ~s has neither ~s nor ~s ~\n"
"                           allocation, so it can't be read by the default "
"~s ~\n"
"                           method.~@:>"
msgstr ""

#: src/pcl/slots.lisp
msgid ""
"~@<The slot ~s has neither ~s nor ~s allocation, ~\n"
"               so it can't be written by the default ~s method.~@:>"
msgstr ""

#: src/pcl/slots.lisp
msgid ""
"~@<The slot ~s has neither ~s nor ~s ~\n"
"                           allocation, so it can't be read by the default "
"~s ~\n"
"			   method.~@:>"
msgstr ""

#: src/pcl/slots.lisp
msgid "Structure slots cannot be unbound."
msgstr ""

#: src/pcl/slots.lisp
msgid "Condition slots cannot be unbound."
msgstr ""

#: src/pcl/slots.lisp
msgid ""
"~~@<When attempting to ~A, the slot ~S is missing ~\n"
"                from the object ~S.~~@:>"
msgstr ""

#: src/pcl/slots.lisp
msgid "read the slot's value (slot-value)"
msgstr ""

#: src/pcl/slots.lisp
msgid "set the slot's value to ~S (setf of slot-value)"
msgstr ""

#: src/pcl/slots.lisp
msgid "test to see if slot is bound (slot-boundp)"
msgstr ""

#: src/pcl/slots.lisp
msgid "make the slot unbound (slot-makunbound)"
msgstr ""

#: src/pcl/slots.lisp
msgid "~@<Can't allocate an instance of class ~S.~@:>"
msgstr ""

#: src/pcl/init.lisp
msgid ""
"~@<Invalid initialization argument~P ~2I~_~\n"
"                         ~<~{~S~^, ~}~@:> ~I~_in call for class ~S.~:>"
msgstr ""

#: src/pcl/seal.lisp
msgid "~@<Invalid sealing specifier ~s.~@:>"
msgstr ""

#: src/pcl/seal.lisp
msgid "~s is sealed wrt ~a"
msgstr ""

#: src/pcl/cpl.lisp
msgid ""
"~~@<While computing the class precedence list ~\n"
"                of the class ~A: ~?.~~@:>"
msgstr ""

#: src/pcl/cpl.lisp
msgid "named ~S"
msgstr ""

#: src/pcl/cpl.lisp
msgid "The class ~A is a forward referenced class"
msgstr ""

#: src/pcl/cpl.lisp
msgid ""
"The class ~A is a forward referenced class. ~\n"
"                      The class ~A is ~A."
msgstr ""

#: src/pcl/cpl.lisp
msgid "a direct superclass of the class ~A"
msgstr ""

#: src/pcl/cpl.lisp
msgid ""
"reached from the class ~A by following~@\n"
"                                  the direct superclass chain through: ~A~\n"
"                                  ~%  ending at the class ~A"
msgstr ""

#: src/pcl/cpl.lisp
msgid "~{~%  the class ~A,~}"
msgstr ""

#: src/pcl/cpl.lisp
msgid ""
"It is not possible to compute the class precedence list because ~\n"
"       there ~A in the local precedence relations.  ~\n"
"       ~A because:~{~%  ~A~}."
msgstr ""

#: src/pcl/cpl.lisp
msgid "are circularities"
msgstr ""

#: src/pcl/cpl.lisp
msgid "is a circularity"
msgstr ""

#: src/pcl/cpl.lisp
msgid "These arise"
msgstr ""

#: src/pcl/cpl.lisp
msgid "This arises"
msgstr ""

#: src/pcl/cpl.lisp
msgid "the class ~A appears in the supers of the class ~A"
msgstr ""

#: src/pcl/cpl.lisp
msgid "the class ~A follows the class ~A in the supers of the class ~A"
msgstr ""

#: src/pcl/methods.lisp
msgid "Instance"
msgstr ""

#: src/pcl/methods.lisp
msgid "~@<Structure slots must have ~s allocation.~@:>"
msgstr ""

#: src/pcl/methods.lisp
msgid "~@<~S doesn't seem to have a method function.~@:>"
msgstr ""

#: src/pcl/methods.lisp
msgid ""
"~@<Attempt to reinitialize the method ~S.  ~\n"
"          Method objects cannot be reinitialized.~@:>"
msgstr ""

#: src/pcl/methods.lisp
msgid ""
"~@<When initializing the method ~S, ~\n"
"                   the ~S initialization argument was ~S, ~\n"
"                   which ~A.~@:>"
msgstr ""

#: src/pcl/methods.lisp
msgid "is not a string or NULL"
msgstr ""

#: src/pcl/methods.lisp
msgid "is not a function"
msgstr ""

#: src/pcl/methods.lisp
msgid "Contains ~S which ~A"
msgstr ""

#: src/pcl/methods.lisp
msgid "is not a non-null atom"
msgstr ""

#: src/pcl/methods.lisp
msgid "is neither a class object nor an eql specializer"
msgstr ""

#: src/pcl/methods.lisp
msgid "The value of the ~s initarg, ~s, ~A."
msgstr ""

#: src/pcl/methods.lisp
msgid ""
"~~@<When initializing the generic-function ~S: ~\n"
"                               The ~S initialization argument was ~A.  ~\n"
"                               It must be ~A.~~@:>"
msgstr ""

#: src/pcl/methods.lisp
msgid "~@<~S does not name a generic function.~@:>"
msgstr ""

#: src/pcl/methods.lisp
msgid ""
"~@<There is no method for the generic function ~S ~\n"
"                   matching argument specifiers ~S.~@:>"
msgstr ""

#: src/pcl/methods.lisp
msgid ""
"~@<No method on ~S with qualifiers ~S and ~\n"
"           specializers ~S.~@:>"
msgstr ""

#: src/pcl/methods.lisp
msgid ""
"~@<No method on ~S with qualifiers ~S and ~\n"
"            specializers ~S.~@:>"
msgstr ""

#: src/pcl/methods.lisp
msgid "~@<The generic function ~s takes ~d required argument~p.~@:>"
msgstr ""

#: src/pcl/methods.lisp
msgid ""
"~@<The method ~S is already part of the generic ~\n"
"            function ~S.  It can't be added to another generic ~\n"
"            function until it is removed from the first one.~@:>"
msgstr ""

#: src/pcl/methods.lisp
msgid ""
"~@<Method ~s contains invalid qualifiers for ~\n"
"                        the standard method combination.~@:>"
msgstr ""

#: src/pcl/methods.lisp
msgid ""
"~@<Method ~s contains invalid qualifiers for ~\n"
"                          the method combination ~s.~@:>"
msgstr ""

#: src/pcl/methods.lisp
msgid "~@<Generic function ~S requires at least ~D arguments.~@:>"
msgstr ""

#: src/pcl/methods.lisp
msgid "In get-accessor-method-function."
msgstr ""

#: src/pcl/methods.lisp
msgid "The key for the last case arg to mcase was not T."
msgstr ""

#: src/pcl/defcombin.lisp
msgid ""
"~@<Invalid options to a short method combination type.  ~\n"
"            The method combination type ~S accepts one option which ~\n"
"            must be either ~s or ~s.~@:>"
msgstr ""

#: src/pcl/defcombin.lisp
msgid ""
"~@<The method ~S ~A.  ~\n"
"                    The method combination type ~S was defined with the ~\n"
"                    short form of ~s and so requires all methods have ~\n"
"		    either the single qualifier ~S or the single qualifier ~\n"
"		    ~s.~@:>"
msgstr ""

#: src/pcl/defcombin.lisp
msgid "has no qualifiers"
msgstr ""

#: src/pcl/defcombin.lisp
msgid "has an illegal qualifier"
msgstr ""

#: src/pcl/defcombin.lisp
msgid ""
"~@<More than one method of type ~S ~\n"
"                                     with the same specializers.~@:>"
msgstr ""

#: src/pcl/defcombin.lisp
msgid "No ~S methods."
msgstr ""

#: src/pcl/defcombin.lisp
msgid ""
"~@<In the method group specifier ~S, ~\n"
"                   ~S isn't a valid qualifier pattern.~@:>"
msgstr ""

#: src/pcl/defcombin.lisp
msgid "methods matching one of the patterns: ~{~S, ~} ~S"
msgstr ""

#: src/pcl/defcombin.lisp
msgid "methods matching the pattern: ~S"
msgstr ""

#: src/pcl/defcombin.lisp
msgid "Invalid parameter specifier: ~s"
msgstr ""

#: src/pcl/env.lisp
msgid "~%~S is an instance of class ~S:"
msgstr ""

#: src/pcl/env.lisp
msgid "~% The following slots have :INSTANCE allocation:"
msgstr ""

#: src/pcl/env.lisp
msgid "~% The following slots have :CLASS allocation:"
msgstr ""

#: src/pcl/env.lisp
msgid "~% The following slots have allocation as shown:"
msgstr ""

#: src/pcl/env.lisp
msgid "~A is a generic function.~%"
msgstr ""

#: src/pcl/env.lisp
msgid "Its lambda-list is:~%  ~S~%"
msgstr ""

#: src/pcl/env.lisp
msgid "Generic function documentation:~%  ~s~%"
msgstr ""

#: src/pcl/env.lisp
msgid "Its methods are:~%"
msgstr ""

#: src/pcl/env.lisp
msgid "    Method documentation: ~s~%"
msgstr ""

#: src/pcl/env.lisp
msgid "~&~@<~S is a class, it is an instance of ~S.~@:>~%"
msgstr ""

#: src/pcl/env.lisp
msgid "Its proper name is ~S.~%"
msgstr ""

#: src/pcl/env.lisp
msgid "Its name is ~S, but this is not a proper name.~%"
msgstr ""

#: src/pcl/env.lisp
msgid "It has no name (the name is NIL).~%"
msgstr ""

#: src/pcl/env.lisp
msgid ""
"The direct superclasses are: ~:S, and the direct~%~\n"
"           subclasses are: ~:S.  The class is ~:[not ~;~]finalized.  ~\n"
"           The class precedence list is:~%~S~%~\n"
"           There are ~D methods specialized for this class."
msgstr ""

#: src/pcl/env.lisp
msgid "~&Its direct slots are:~%"
msgstr ""

#: src/pcl/env.lisp
msgid "  ~a, documentation ~s~%"
msgstr ""

#: src/pcl/env.lisp
msgid "~&~S is a ~S.~%"
msgstr ""

#: src/pcl/env.lisp
msgid "You can also call it~@[ ~{~S~^, ~} or~] ~S.~%"
msgstr ""

#: src/pcl/env.lisp
msgid "It has ~D internal and ~D external symbols (~D total).~%"
msgstr ""

#: src/pcl/env.lisp
msgid "It uses the packages ~{~S~^, ~}.~%"
msgstr ""

#: src/pcl/env.lisp
msgid "It is used by the packages ~{~S~^, ~}.~%"
msgstr ""

#: src/pcl/env.lisp
msgid "~&~S is an ~a hash table."
msgstr ""

#: src/pcl/env.lisp
msgid "~&Its size is ~d buckets."
msgstr ""

#: src/pcl/env.lisp
msgid "~&Its rehash-size is ~d."
msgstr ""

#: src/pcl/env.lisp
msgid "~&Its rehash-threshold is ~d."
msgstr ""

#: src/pcl/env.lisp
msgid "~@<Default ~s method for ~s called.~@>"
msgstr ""

#: src/pcl/env.lisp
msgid "~@<Can't dump wrapper for anonymous class ~S.~@:>"
msgstr ""

#: src/pcl/env.lisp
msgid "~@<Can't use anonymous or undefined class as constant: ~S~:@>"
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"Returns a type specifier for the kind of object returned by the\n"
"  Stream. Class FUNDAMENTAL-CHARACTER-STREAM provides a default method\n"
"  which returns CHARACTER."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"Return true if Stream is not closed.  A default method is provided\n"
"  by class FUNDAMENTAL-STREAM which returns true if CLOSE has not been\n"
"  called on the stream."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"Closes the given Stream.  No more I/O may be performed, but\n"
"  inquiries may still be made.  If :Abort is non-nil, an attempt is made\n"
"  to clean up the side effects of having created the stream."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"This reads one character from the stream.  It returns either a\n"
"  character object, or the symbol :EOF if the stream is at end-of-file.\n"
"  Every subclass of FUNDAMENTAL-CHARACTER-INPUT-STREAM must define a\n"
"  method for this function."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"Un-does the last call to STREAM-READ-CHAR, as in UNREAD-CHAR.\n"
"  Returns NIL.  Every subclass of FUNDAMENTAL-CHARACTER-INPUT-STREAM\n"
"  must define a method for this function."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"This is used to implement READ-CHAR-NO-HANG.  It returns either a\n"
"  character, or NIL if no input is currently available, or :EOF if\n"
"  end-of-file is reached.  The default method provided by\n"
"  FUNDAMENTAL-CHARACTER-INPUT-STREAM simply calls STREAM-READ-CHAR; this\n"
"  is sufficient for file streams, but interactive streams should define\n"
"  their own method."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"Used to implement PEEK-CHAR; this corresponds to peek-type of NIL.\n"
"  It returns either a character or :EOF.  The default method calls\n"
"  STREAM-READ-CHAR and STREAM-UNREAD-CHAR."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"Used by LISTEN.  Returns true or false.  The default method uses\n"
"  STREAM-READ-CHAR-NO-HANG and STREAM-UNREAD-CHAR.  Most streams should \n"
"  define their own method since it will usually be trivial and will\n"
"  always be more efficient than the default method."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"Used by READ-LINE.  A string is returned as the first value.  The\n"
"  second value is true if the string was terminated by end-of-file\n"
"  instead of the end of a line.  The default method uses repeated\n"
"  calls to STREAM-READ-CHAR."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"Implements CLEAR-INPUT for the stream, returning NIL.  The default\n"
"  method does nothing."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid "Implements READ-SEQUENCE for the stream."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"Writes character to the stream and returns the character.  Every\n"
"  subclass of FUNDAMENTAL-CHARACTER-OUTPUT-STREAM must have a method\n"
"  defined for this function."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"This function returns the column number where the next character\n"
"  will be written, or NIL if that is not meaningful for this stream.\n"
"  The first column on a line is numbered 0.  This function is used in\n"
"  the implementation of PPRINT and the FORMAT ~T directive.  For every\n"
"  character output stream class that is defined, a method must be\n"
"  defined for this function, although it is permissible for it to\n"
"  always return NIL."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid "Return the stream line length or Nil."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"This is a predicate which returns T if the stream is positioned at\n"
"  the beginning of a line, else NIL.  It is permissible to always return\n"
"  NIL.  This is used in the implementation of FRESH-LINE.  Note that\n"
"  while a value of 0 from STREAM-LINE-COLUMN also indicates the\n"
"  beginning of a line, there are cases where STREAM-START-LINE-P can be\n"
"  meaningfully implemented although STREAM-LINE-COLUMN can't be.  For\n"
"  example, for a window using variable-width characters, the column\n"
"  number isn't very meaningful, but the beginning of the line does have\n"
"  a clear meaning.  The default method for STREAM-START-LINE-P on class\n"
"  FUNDAMENTAL-CHARACTER-OUTPUT-STREAM uses STREAM-LINE-COLUMN, so if\n"
"  that is defined to return NIL, then a method should be provided for\n"
"  either STREAM-START-LINE-P or STREAM-FRESH-LINE."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"This is used by WRITE-STRING.  It writes the string to the stream,\n"
"  optionally delimited by start and end, which default to 0 and NIL.\n"
"  The string argument is returned.  The default method provided by\n"
"  FUNDAMENTAL-CHARACTER-OUTPUT-STREAM uses repeated calls to\n"
"  STREAM-WRITE-CHAR."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"Writes an end of line, as for TERPRI.  Returns NIL.  The default\n"
"  method does (STREAM-WRITE-CHAR stream #NEWLINE)."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"Outputs a new line to the Stream if it is not positioned at the\n"
"  begining of a line.  Returns T if it output a new line, nil\n"
"  otherwise. Used by FRESH-LINE. The default method uses\n"
"  STREAM-START-LINE-P and STREAM-TERPRI."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"Attempts to ensure that all output sent to the Stream has reached\n"
"  its destination, and only then returns false. Implements\n"
"  FINISH-OUTPUT.  The default method does nothing."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"Attempts to force any buffered output to be sent. Implements\n"
"  FORCE-OUTPUT.  The default method does nothing."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"Clears the given output Stream. Implements CLEAR-OUTPUT.  The\n"
"  default method does nothing."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"Writes enough blank space so that the next character will be\n"
"  written at the specified column.  Returns true if the operation is\n"
"  successful, or NIL if it is not supported for this stream.  This is\n"
"  intended for use by by PPRINT and FORMAT ~T.  The default method uses\n"
"  STREAM-LINE-COLUMN and repeated calls to STREAM-WRITE-CHAR with a\n"
"  #SPACE character; it returns NIL if STREAM-LINE-COLUMN returns NIL."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid "Implements WRITE-SEQUENCE for the stream."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid "Implements FILE-POSITION for the stream."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid "Implements FILE-POSITION for the stream for setting the position."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"Used by READ-BYTE; returns either an integer, or the symbol :EOF\n"
"  if the stream is at end-of-file."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid ""
"Implements WRITE-BYTE; writes the integer to the stream and\n"
"  returns the integer as the result."
msgstr ""

#: src/pcl/gray-streams.lisp
msgid "    Gray Streams Protocol Support"
msgstr ""

msgid ""
"US ASCII 7-bit encoding.  Illegal input sequences are replaced with\n"
"the Unicode replacment character.  Illegal output characters are\n"
"replaced with a question mark."
msgstr ""

msgid ""
"MAC-ROMAN is an 8-bit character encoding for Western European\n"
"languages including English.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"CP1250 is a Windows code page to represent texts in Central and\n"
"Eastern European languages such as Polish, Czech, Slovak, Hungarian,\n"
"Slovene, Bosnian, Croation, Serbian, Romanian, and Albanian.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"CP1251 is a Windows code page to represent texts that use the\n"
"Cyrillic alphabet such as Russian, Bulgarian, Serbian Cyrillic, and\n"
"others.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"CP1252 is a Windows code page for the Latin alphabet.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"CP1253 is a Windows code page for Greek.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"CP1254 is a Windows code page for Turkish.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"CP1255 is a Windows code page for Hebrew.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"CP1256 is a Windows code page for Arabic.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"CP1257 is a Windows code page for Estonian, Latvian, and Lithuanian.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"CP1258 is a Windows code page for Vietnamese.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"EUC-KR is an variable-length character encoding generally intended for\n"
"Korean Hangul.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"ISO8859-2 is an 8-bit character encoding generally intended for\n"
"Eastern European languages including Bosnian, Croation, Czech, German,\n"
"Hungarian, Polish, Romanian, Serbian Latin, Slovak, Slovene, Upper\n"
"Sorbian, and Lower Sorbian.  \n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"ISO8859-10 is an 8-bit character encoding intended to cover Nordic\n"
"languages.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"ISO8859-13 is an 8-bit character encoding for the Baltic languages.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"ISO8859-14 is an 8-bit character encoding intended for the Celtic\n"
"languages such as Irish, Manx, Scottish Gaelic, Welsh, and Breton.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"ISO8859-15 is an 8-bit character encoding similar to ISO8859-1 but\n"
"replaces some less common symbols with others, including adding the\n"
"Euro sign.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"ISO8859-3 is an 8-bit character encoding intended for South European\n"
"languages including Turkish, Maltese, and Esperanto.  For Turkish,\n"
"ISO8859-9 supersedes ISO8859-3.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"ISO8859-4 is an 8-bit character encoding for North European languages\n"
"including Estonian, Latvian, Lithuanian, Greenlandic, and Sami.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"ISO8859-5, informallly referred to as Latin/Cyrillic, is an 8-bit\n"
"character encoding intended for languages using a Cyrillic alphabet\n"
"such as Bulgarian, Belarusian, Russian, Serbian, and Macedonian.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"ISO8859-6 is an 8-bit character encoding generally intended languages\n"
"using the Arabic alphabet.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"ISO8859-7 is an 8-bit character encoding for the modern Greek\n"
"language.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"ISO8859-8 is an 8-bit character encoding intended for Hebrew.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"ISO8859-9 is an 8-bit character encoding for the Turkish language.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"KOI8-R is an 8-bit character encoding designed to cover Russian.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"MAC-CYRILLIC is an 8-bit character encoding for Cyrillic text on\n"
"Apple Macintosh computers.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"MAC-GREEK is an 8-bit character encoding for Greek text on Apple\n"
"Macintosh computers.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"MAC-ICELANDIC is an 8-bit character encoding for Icelandic text on\n"
"Apple Macintosh computers.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"MAC-LATIN2 is an 8-bit character encoding for Central European text\n"
"on Apple Macintosh computers.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"MAC-TURKISH is an 8-bit character encoding for Turkish text on\n"
"Apple Macintosh computers.\n"
"\n"
"By default, illegal inputs are replaced by the Unicode replacement\n"
"character and illegal outputs are replaced by a question mark."
msgstr ""

msgid ""
"UTF-16 is a variable length character encoding for Unicode.  On\n"
"input, a byte-order mark is recognized.  If no byte-order mark is\n"
"given on input, then the encoding is assumed to be big-endian.  For\n"
"output, the byte-order mark is not written, and the output is\n"
"big-endian.  (This is specified by the Unicode standard.)\n"
"\n"
"By default, illegal inputs and illegal outputs are replaced by the\n"
"Unicode replacement character."
msgstr ""

msgid ""
"UTF-16-BE is a variable length character encoding for Unicode.  For\n"
"both input and output, the data is assumed to be in big-endian order.\n"
"No byte-order mark is allowed on input, and no byte-order mark is\n"
"produced on output.  (This is specified by the Unicode standard.)\n"
"\n"
"By default, illegal inputs and illegal outputs are replaced by the\n"
"Unicode replacement character."
msgstr ""

msgid ""
"UTF-16-LE is a variable length character encoding for Unicode.  For\n"
"both input and output, the data is assumed to be in little-endian\n"
"order.  No byte-order mark is allowed on input, and no byte-order mark\n"
"is produced on output.  (This is specified by the Unicode standard.)\n"
"\n"
"By default, illegal inputs and illegal outputs are replaced by the\n"
"Unicode replacement character."
msgstr ""

msgid ""
"UTF-32 is a fixed-length character encoding of 4 octets for Unicode.\n"
"On input, a byte-order mark is recognized.  If no byte-order mark is\n"
"given on input, then the encoding is assumed to be big-endian.  For\n"
"output, the byte-order mark is not written, and the output is\n"
"big-endian.  (This is specified by the Unicode standard.)\n"
"\n"
"By default, illegal inputs and illegal outputs are replaced by the\n"
"Unicode replacement character."
msgstr ""

msgid ""
"UTF-32-BE is a fixed-length character encoding of 4 octets for\n"
"Unicode.  For both input and output, the data is assumed to be in\n"
"big-endian order.  No byte-order mark is allowed on input, and no\n"
"byte-order mark is produced on output.  (This is specified by the\n"
"Unicode standard.)\n"
"\n"
"By default, illegal inputs and illegal outputs are replaced by the\n"
"Unicode replacement character."
msgstr ""

msgid ""
"UTF-32-LE is a fixed-length character encoding of 4 octets for\n"
"Unicode.  For both input and output, the data is assumed to be in\n"
"little-endian order.  No byte-order mark is allowed on input, and no\n"
"byte-order mark is produced on output.  (This is specified by the\n"
"Unicode standard.)\n"
"\n"
"By default, illegal inputs and illegal outputs are replaced by the\n"
"Unicode replacement character."
msgstr ""

